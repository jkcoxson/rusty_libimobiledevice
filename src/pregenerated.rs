// jkcoxson
// Danger: this file was NOT generated at run time and could be out of date
// Choke on this, rust-analyzer (https://github.com/rust-analyzer/rust-analyzer/issues/9720)

/* automatically generated by rust-bindgen 0.59.1 */

pub const __WORDSIZE: u32 = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 120100;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const __DARWIN_FD_SETSIZE: u32 = 1024;
pub const __DARWIN_NBBY: u32 = 8;
pub const NBBY: u32 = 8;
pub const FD_SETSIZE: u32 = 1024;
pub const S_IFMT: u32 = 61440;
pub const S_IFIFO: u32 = 4096;
pub const S_IFCHR: u32 = 8192;
pub const S_IFDIR: u32 = 16384;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const S_IFWHT: u32 = 57344;
pub const S_IRWXU: u32 = 448;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXG: u32 = 56;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXO: u32 = 7;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_ISTXT: u32 = 512;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const ACCESSPERMS: u32 = 511;
pub const ALLPERMS: u32 = 4095;
pub const DEFFILEMODE: u32 = 438;
pub const S_BLKSIZE: u32 = 512;
pub const UF_SETTABLE: u32 = 65535;
pub const UF_NODUMP: u32 = 1;
pub const UF_IMMUTABLE: u32 = 2;
pub const UF_APPEND: u32 = 4;
pub const UF_OPAQUE: u32 = 8;
pub const UF_COMPRESSED: u32 = 32;
pub const UF_TRACKED: u32 = 64;
pub const UF_DATAVAULT: u32 = 128;
pub const UF_HIDDEN: u32 = 32768;
pub const SF_SUPPORTED: u32 = 10420224;
pub const SF_SETTABLE: u32 = 1073676288;
pub const SF_SYNTHETIC: u32 = 3221225472;
pub const SF_ARCHIVED: u32 = 65536;
pub const SF_IMMUTABLE: u32 = 131072;
pub const SF_APPEND: u32 = 262144;
pub const SF_RESTRICTED: u32 = 524288;
pub const SF_NOUNLINK: u32 = 1048576;
pub const SF_FIRMLINK: u32 = 8388608;
pub const SF_DATALESS: u32 = 1073741824;
pub const EF_MAY_SHARE_BLOCKS: u32 = 1;
pub const EF_NO_XATTRS: u32 = 2;
pub const EF_IS_SYNC_ROOT: u32 = 4;
pub const EF_IS_PURGEABLE: u32 = 8;
pub const EF_IS_SPARSE: u32 = 16;
pub const EF_IS_SYNTHETIC: u32 = 32;
pub const UTIME_NOW: i32 = -1;
pub const UTIME_OMIT: i32 = -2;
pub const __GNUC_VA_LIST: u32 = 1;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const CLOCKS_PER_SEC: u32 = 1000000;
pub const TIME_UTC: u32 = 1;
pub const GNUTLS_VERSION: &'static [u8; 7usize] = b"3.6.16\0";
pub const GNUTLS_VERSION_MAJOR: u32 = 3;
pub const GNUTLS_VERSION_MINOR: u32 = 6;
pub const GNUTLS_VERSION_PATCH: u32 = 16;
pub const GNUTLS_VERSION_NUMBER: u32 = 198160;
pub const GNUTLS_MAX_ALGORITHM_NUM: u32 = 64;
pub const GNUTLS_MAX_SESSION_ID_SIZE: u32 = 32;
pub const GNUTLS_SERVER: u32 = 1;
pub const GNUTLS_CLIENT: u32 = 2;
pub const GNUTLS_DATAGRAM: u32 = 4;
pub const GNUTLS_NONBLOCK: u32 = 8;
pub const GNUTLS_NO_EXTENSIONS: u32 = 16;
pub const GNUTLS_NO_REPLAY_PROTECTION: u32 = 32;
pub const GNUTLS_NO_SIGNAL: u32 = 64;
pub const GNUTLS_ALLOW_ID_CHANGE: u32 = 128;
pub const GNUTLS_ENABLE_FALSE_START: u32 = 256;
pub const GNUTLS_FORCE_CLIENT_CERT: u32 = 512;
pub const GNUTLS_NO_TICKETS: u32 = 1024;
pub const GNUTLS_ENABLE_CERT_TYPE_NEG: u32 = 0;
pub const GNUTLS_KU_PEER: u32 = 1;
pub const GNUTLS_SIGN_FLAG_SECURE_FOR_CERTS: u32 = 1;
pub const GNUTLS_HEARTBEAT_WAIT: u32 = 1;
pub const GNUTLS_RECORD_WAIT: u32 = 1;
pub const GNUTLS_HB_PEER_ALLOWED_TO_SEND: u32 = 1;
pub const GNUTLS_HB_PEER_NOT_ALLOWED_TO_SEND: u32 = 2;
pub const GNUTLS_HB_LOCAL_ALLOWED_TO_SEND: u32 = 4;
pub const GNUTLS_PRIORITY_INIT_DEF_APPEND: u32 = 1;
pub const GNUTLS_PRIORITY_LIST_INIT_KEYWORDS: u32 = 1;
pub const GNUTLS_PRIORITY_LIST_SPECIAL: u32 = 2;
pub const GNUTLS_MAX_SESSION_ID: u32 = 32;
pub const GNUTLS_HOOK_POST: u32 = 1;
pub const GNUTLS_HOOK_PRE: u32 = 0;
pub const GNUTLS_HOOK_BOTH: i32 = -1;
pub const GNUTLS_OCSP_SR_IS_AVAIL: u32 = 1;
pub const GNUTLS_IDNA_FORCE_2008: u32 = 2;
pub const GNUTLS_KEY_DIGITAL_SIGNATURE: u32 = 128;
pub const GNUTLS_KEY_NON_REPUDIATION: u32 = 64;
pub const GNUTLS_KEY_KEY_ENCIPHERMENT: u32 = 32;
pub const GNUTLS_KEY_DATA_ENCIPHERMENT: u32 = 16;
pub const GNUTLS_KEY_KEY_AGREEMENT: u32 = 8;
pub const GNUTLS_KEY_KEY_CERT_SIGN: u32 = 4;
pub const GNUTLS_KEY_CRL_SIGN: u32 = 2;
pub const GNUTLS_KEY_ENCIPHER_ONLY: u32 = 1;
pub const GNUTLS_KEY_DECIPHER_ONLY: u32 = 32768;
pub const GNUTLS_SCOMMIT_FLAG_ALLOW_BROKEN: u32 = 1;
pub const GNUTLS_UTF8_IGNORE_ERRS: u32 = 1;
pub const GNUTLS_EXT_RAW_FLAG_TLS_CLIENT_HELLO: u32 = 1;
pub const GNUTLS_EXT_RAW_FLAG_DTLS_CLIENT_HELLO: u32 = 2;
pub const GNUTLS_FIPS140_SET_MODE_THREAD: u32 = 1;
pub const GNUTLS_E_SUCCESS: u32 = 0;
pub const GNUTLS_E_UNKNOWN_COMPRESSION_ALGORITHM: i32 = -3;
pub const GNUTLS_E_UNKNOWN_CIPHER_TYPE: i32 = -6;
pub const GNUTLS_E_LARGE_PACKET: i32 = -7;
pub const GNUTLS_E_UNSUPPORTED_VERSION_PACKET: i32 = -8;
pub const GNUTLS_E_UNEXPECTED_PACKET_LENGTH: i32 = -9;
pub const GNUTLS_E_INVALID_SESSION: i32 = -10;
pub const GNUTLS_E_FATAL_ALERT_RECEIVED: i32 = -12;
pub const GNUTLS_E_UNEXPECTED_PACKET: i32 = -15;
pub const GNUTLS_E_WARNING_ALERT_RECEIVED: i32 = -16;
pub const GNUTLS_E_ERROR_IN_FINISHED_PACKET: i32 = -18;
pub const GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET: i32 = -19;
pub const GNUTLS_E_UNKNOWN_CIPHER_SUITE: i32 = -21;
pub const GNUTLS_E_UNWANTED_ALGORITHM: i32 = -22;
pub const GNUTLS_E_MPI_SCAN_FAILED: i32 = -23;
pub const GNUTLS_E_DECRYPTION_FAILED: i32 = -24;
pub const GNUTLS_E_MEMORY_ERROR: i32 = -25;
pub const GNUTLS_E_DECOMPRESSION_FAILED: i32 = -26;
pub const GNUTLS_E_COMPRESSION_FAILED: i32 = -27;
pub const GNUTLS_E_AGAIN: i32 = -28;
pub const GNUTLS_E_EXPIRED: i32 = -29;
pub const GNUTLS_E_DB_ERROR: i32 = -30;
pub const GNUTLS_E_KEYFILE_ERROR: i32 = -31;
pub const GNUTLS_E_INSUFFICIENT_CREDENTIALS: i32 = -32;
pub const GNUTLS_E_INSUFICIENT_CREDENTIALS: i32 = -32;
pub const GNUTLS_E_INSUFFICIENT_CRED: i32 = -32;
pub const GNUTLS_E_INSUFICIENT_CRED: i32 = -32;
pub const GNUTLS_E_HASH_FAILED: i32 = -33;
pub const GNUTLS_E_BASE64_DECODING_ERROR: i32 = -34;
pub const GNUTLS_E_MPI_PRINT_FAILED: i32 = -35;
pub const GNUTLS_E_REHANDSHAKE: i32 = -37;
pub const GNUTLS_E_GOT_APPLICATION_DATA: i32 = -38;
pub const GNUTLS_E_RECORD_LIMIT_REACHED: i32 = -39;
pub const GNUTLS_E_ENCRYPTION_FAILED: i32 = -40;
pub const GNUTLS_E_PK_ENCRYPTION_FAILED: i32 = -44;
pub const GNUTLS_E_PK_DECRYPTION_FAILED: i32 = -45;
pub const GNUTLS_E_PK_SIGN_FAILED: i32 = -46;
pub const GNUTLS_E_X509_UNSUPPORTED_CRITICAL_EXTENSION: i32 = -47;
pub const GNUTLS_E_KEY_USAGE_VIOLATION: i32 = -48;
pub const GNUTLS_E_NO_CERTIFICATE_FOUND: i32 = -49;
pub const GNUTLS_E_INVALID_REQUEST: i32 = -50;
pub const GNUTLS_E_SHORT_MEMORY_BUFFER: i32 = -51;
pub const GNUTLS_E_INTERRUPTED: i32 = -52;
pub const GNUTLS_E_PUSH_ERROR: i32 = -53;
pub const GNUTLS_E_PULL_ERROR: i32 = -54;
pub const GNUTLS_E_RECEIVED_ILLEGAL_PARAMETER: i32 = -55;
pub const GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE: i32 = -56;
pub const GNUTLS_E_PKCS1_WRONG_PAD: i32 = -57;
pub const GNUTLS_E_RECEIVED_ILLEGAL_EXTENSION: i32 = -58;
pub const GNUTLS_E_INTERNAL_ERROR: i32 = -59;
pub const GNUTLS_E_DH_PRIME_UNACCEPTABLE: i32 = -63;
pub const GNUTLS_E_FILE_ERROR: i32 = -64;
pub const GNUTLS_E_TOO_MANY_EMPTY_PACKETS: i32 = -78;
pub const GNUTLS_E_UNKNOWN_PK_ALGORITHM: i32 = -80;
pub const GNUTLS_E_TOO_MANY_HANDSHAKE_PACKETS: i32 = -81;
pub const GNUTLS_E_RECEIVED_DISALLOWED_NAME: i32 = -82;
pub const GNUTLS_E_CERTIFICATE_REQUIRED: i32 = -112;
pub const GNUTLS_E_NO_TEMPORARY_RSA_PARAMS: i32 = -84;
pub const GNUTLS_E_NO_COMPRESSION_ALGORITHMS: i32 = -86;
pub const GNUTLS_E_NO_CIPHER_SUITES: i32 = -87;
pub const GNUTLS_E_OPENPGP_GETKEY_FAILED: i32 = -88;
pub const GNUTLS_E_PK_SIG_VERIFY_FAILED: i32 = -89;
pub const GNUTLS_E_ILLEGAL_SRP_USERNAME: i32 = -90;
pub const GNUTLS_E_KEYFILE_PARSING_ERROR: i32 = -91;
pub const GNUTLS_E_NO_TEMPORARY_DH_PARAMS: i32 = -93;
pub const GNUTLS_E_ASN1_ELEMENT_NOT_FOUND: i32 = -67;
pub const GNUTLS_E_ASN1_IDENTIFIER_NOT_FOUND: i32 = -68;
pub const GNUTLS_E_ASN1_DER_ERROR: i32 = -69;
pub const GNUTLS_E_ASN1_VALUE_NOT_FOUND: i32 = -70;
pub const GNUTLS_E_ASN1_GENERIC_ERROR: i32 = -71;
pub const GNUTLS_E_ASN1_VALUE_NOT_VALID: i32 = -72;
pub const GNUTLS_E_ASN1_TAG_ERROR: i32 = -73;
pub const GNUTLS_E_ASN1_TAG_IMPLICIT: i32 = -74;
pub const GNUTLS_E_ASN1_TYPE_ANY_ERROR: i32 = -75;
pub const GNUTLS_E_ASN1_SYNTAX_ERROR: i32 = -76;
pub const GNUTLS_E_ASN1_DER_OVERFLOW: i32 = -77;
pub const GNUTLS_E_OPENPGP_UID_REVOKED: i32 = -79;
pub const GNUTLS_E_CERTIFICATE_ERROR: i32 = -43;
pub const GNUTLS_E_X509_CERTIFICATE_ERROR: i32 = -43;
pub const GNUTLS_E_CERTIFICATE_KEY_MISMATCH: i32 = -60;
pub const GNUTLS_E_UNSUPPORTED_CERTIFICATE_TYPE: i32 = -61;
pub const GNUTLS_E_X509_UNKNOWN_SAN: i32 = -62;
pub const GNUTLS_E_OPENPGP_FINGERPRINT_UNSUPPORTED: i32 = -94;
pub const GNUTLS_E_X509_UNSUPPORTED_ATTRIBUTE: i32 = -95;
pub const GNUTLS_E_UNKNOWN_HASH_ALGORITHM: i32 = -96;
pub const GNUTLS_E_UNKNOWN_PKCS_CONTENT_TYPE: i32 = -97;
pub const GNUTLS_E_UNKNOWN_PKCS_BAG_TYPE: i32 = -98;
pub const GNUTLS_E_INVALID_PASSWORD: i32 = -99;
pub const GNUTLS_E_MAC_VERIFY_FAILED: i32 = -100;
pub const GNUTLS_E_CONSTRAINT_ERROR: i32 = -101;
pub const GNUTLS_E_WARNING_IA_IPHF_RECEIVED: i32 = -102;
pub const GNUTLS_E_WARNING_IA_FPHF_RECEIVED: i32 = -103;
pub const GNUTLS_E_IA_VERIFY_FAILED: i32 = -104;
pub const GNUTLS_E_UNKNOWN_ALGORITHM: i32 = -105;
pub const GNUTLS_E_UNSUPPORTED_SIGNATURE_ALGORITHM: i32 = -106;
pub const GNUTLS_E_SAFE_RENEGOTIATION_FAILED: i32 = -107;
pub const GNUTLS_E_UNSAFE_RENEGOTIATION_DENIED: i32 = -108;
pub const GNUTLS_E_UNKNOWN_SRP_USERNAME: i32 = -109;
pub const GNUTLS_E_PREMATURE_TERMINATION: i32 = -110;
pub const GNUTLS_E_MALFORMED_CIDR: i32 = -111;
pub const GNUTLS_E_BASE64_ENCODING_ERROR: i32 = -201;
pub const GNUTLS_E_INCOMPATIBLE_GCRYPT_LIBRARY: i32 = -202;
pub const GNUTLS_E_INCOMPATIBLE_CRYPTO_LIBRARY: i32 = -202;
pub const GNUTLS_E_INCOMPATIBLE_LIBTASN1_LIBRARY: i32 = -203;
pub const GNUTLS_E_OPENPGP_KEYRING_ERROR: i32 = -204;
pub const GNUTLS_E_X509_UNSUPPORTED_OID: i32 = -205;
pub const GNUTLS_E_RANDOM_FAILED: i32 = -206;
pub const GNUTLS_E_BASE64_UNEXPECTED_HEADER_ERROR: i32 = -207;
pub const GNUTLS_E_OPENPGP_SUBKEY_ERROR: i32 = -208;
pub const GNUTLS_E_ALREADY_REGISTERED: i32 = -209;
pub const GNUTLS_E_HANDSHAKE_TOO_LARGE: i32 = -210;
pub const GNUTLS_E_CRYPTODEV_IOCTL_ERROR: i32 = -211;
pub const GNUTLS_E_CRYPTODEV_DEVICE_ERROR: i32 = -212;
pub const GNUTLS_E_CHANNEL_BINDING_NOT_AVAILABLE: i32 = -213;
pub const GNUTLS_E_BAD_COOKIE: i32 = -214;
pub const GNUTLS_E_OPENPGP_PREFERRED_KEY_ERROR: i32 = -215;
pub const GNUTLS_E_INCOMPAT_DSA_KEY_WITH_TLS_PROTOCOL: i32 = -216;
pub const GNUTLS_E_INSUFFICIENT_SECURITY: i32 = -217;
pub const GNUTLS_E_HEARTBEAT_PONG_RECEIVED: i32 = -292;
pub const GNUTLS_E_HEARTBEAT_PING_RECEIVED: i32 = -293;
pub const GNUTLS_E_UNRECOGNIZED_NAME: i32 = -294;
pub const GNUTLS_E_PKCS11_ERROR: i32 = -300;
pub const GNUTLS_E_PKCS11_LOAD_ERROR: i32 = -301;
pub const GNUTLS_E_PARSING_ERROR: i32 = -302;
pub const GNUTLS_E_PKCS11_PIN_ERROR: i32 = -303;
pub const GNUTLS_E_PKCS11_SLOT_ERROR: i32 = -305;
pub const GNUTLS_E_LOCKING_ERROR: i32 = -306;
pub const GNUTLS_E_PKCS11_ATTRIBUTE_ERROR: i32 = -307;
pub const GNUTLS_E_PKCS11_DEVICE_ERROR: i32 = -308;
pub const GNUTLS_E_PKCS11_DATA_ERROR: i32 = -309;
pub const GNUTLS_E_PKCS11_UNSUPPORTED_FEATURE_ERROR: i32 = -310;
pub const GNUTLS_E_PKCS11_KEY_ERROR: i32 = -311;
pub const GNUTLS_E_PKCS11_PIN_EXPIRED: i32 = -312;
pub const GNUTLS_E_PKCS11_PIN_LOCKED: i32 = -313;
pub const GNUTLS_E_PKCS11_SESSION_ERROR: i32 = -314;
pub const GNUTLS_E_PKCS11_SIGNATURE_ERROR: i32 = -315;
pub const GNUTLS_E_PKCS11_TOKEN_ERROR: i32 = -316;
pub const GNUTLS_E_PKCS11_USER_ERROR: i32 = -317;
pub const GNUTLS_E_CRYPTO_INIT_FAILED: i32 = -318;
pub const GNUTLS_E_TIMEDOUT: i32 = -319;
pub const GNUTLS_E_USER_ERROR: i32 = -320;
pub const GNUTLS_E_ECC_NO_SUPPORTED_CURVES: i32 = -321;
pub const GNUTLS_E_ECC_UNSUPPORTED_CURVE: i32 = -322;
pub const GNUTLS_E_PKCS11_REQUESTED_OBJECT_NOT_AVAILBLE: i32 = -323;
pub const GNUTLS_E_CERTIFICATE_LIST_UNSORTED: i32 = -324;
pub const GNUTLS_E_ILLEGAL_PARAMETER: i32 = -325;
pub const GNUTLS_E_NO_PRIORITIES_WERE_SET: i32 = -326;
pub const GNUTLS_E_X509_UNSUPPORTED_EXTENSION: i32 = -327;
pub const GNUTLS_E_SESSION_EOF: i32 = -328;
pub const GNUTLS_E_TPM_ERROR: i32 = -329;
pub const GNUTLS_E_TPM_KEY_PASSWORD_ERROR: i32 = -330;
pub const GNUTLS_E_TPM_SRK_PASSWORD_ERROR: i32 = -331;
pub const GNUTLS_E_TPM_SESSION_ERROR: i32 = -332;
pub const GNUTLS_E_TPM_KEY_NOT_FOUND: i32 = -333;
pub const GNUTLS_E_TPM_UNINITIALIZED: i32 = -334;
pub const GNUTLS_E_TPM_NO_LIB: i32 = -335;
pub const GNUTLS_E_NO_CERTIFICATE_STATUS: i32 = -340;
pub const GNUTLS_E_OCSP_RESPONSE_ERROR: i32 = -341;
pub const GNUTLS_E_RANDOM_DEVICE_ERROR: i32 = -342;
pub const GNUTLS_E_AUTH_ERROR: i32 = -343;
pub const GNUTLS_E_NO_APPLICATION_PROTOCOL: i32 = -344;
pub const GNUTLS_E_SOCKETS_INIT_ERROR: i32 = -345;
pub const GNUTLS_E_KEY_IMPORT_FAILED: i32 = -346;
pub const GNUTLS_E_INAPPROPRIATE_FALLBACK: i32 = -347;
pub const GNUTLS_E_CERTIFICATE_VERIFICATION_ERROR: i32 = -348;
pub const GNUTLS_E_PRIVKEY_VERIFICATION_ERROR: i32 = -349;
pub const GNUTLS_E_UNEXPECTED_EXTENSIONS_LENGTH: i32 = -350;
pub const GNUTLS_E_ASN1_EMBEDDED_NULL_IN_STRING: i32 = -351;
pub const GNUTLS_E_SELF_TEST_ERROR: i32 = -400;
pub const GNUTLS_E_NO_SELF_TEST: i32 = -401;
pub const GNUTLS_E_LIB_IN_ERROR_STATE: i32 = -402;
pub const GNUTLS_E_PK_GENERATION_ERROR: i32 = -403;
pub const GNUTLS_E_IDNA_ERROR: i32 = -404;
pub const GNUTLS_E_NEED_FALLBACK: i32 = -405;
pub const GNUTLS_E_SESSION_USER_ID_CHANGED: i32 = -406;
pub const GNUTLS_E_HANDSHAKE_DURING_FALSE_START: i32 = -407;
pub const GNUTLS_E_UNAVAILABLE_DURING_HANDSHAKE: i32 = -408;
pub const GNUTLS_E_PK_INVALID_PUBKEY: i32 = -409;
pub const GNUTLS_E_PK_INVALID_PRIVKEY: i32 = -410;
pub const GNUTLS_E_NOT_YET_ACTIVATED: i32 = -411;
pub const GNUTLS_E_INVALID_UTF8_STRING: i32 = -412;
pub const GNUTLS_E_NO_EMBEDDED_DATA: i32 = -413;
pub const GNUTLS_E_INVALID_UTF8_EMAIL: i32 = -414;
pub const GNUTLS_E_INVALID_PASSWORD_STRING: i32 = -415;
pub const GNUTLS_E_CERTIFICATE_TIME_ERROR: i32 = -416;
pub const GNUTLS_E_RECORD_OVERFLOW: i32 = -417;
pub const GNUTLS_E_ASN1_TIME_ERROR: i32 = -418;
pub const GNUTLS_E_INCOMPATIBLE_SIG_WITH_KEY: i32 = -419;
pub const GNUTLS_E_PK_INVALID_PUBKEY_PARAMS: i32 = -420;
pub const GNUTLS_E_PK_NO_VALIDATION_PARAMS: i32 = -421;
pub const GNUTLS_E_OCSP_MISMATCH_WITH_CERTS: i32 = -422;
pub const GNUTLS_E_NO_COMMON_KEY_SHARE: i32 = -423;
pub const GNUTLS_E_REAUTH_REQUEST: i32 = -424;
pub const GNUTLS_E_TOO_MANY_MATCHES: i32 = -425;
pub const GNUTLS_E_CRL_VERIFICATION_ERROR: i32 = -426;
pub const GNUTLS_E_MISSING_EXTENSION: i32 = -427;
pub const GNUTLS_E_DB_ENTRY_EXISTS: i32 = -428;
pub const GNUTLS_E_EARLY_DATA_REJECTED: i32 = -429;
pub const GNUTLS_E_X509_DUPLICATE_EXTENSION: i32 = -430;
pub const GNUTLS_E_UNIMPLEMENTED_FEATURE: i32 = -1250;
pub const GNUTLS_E_INT_RET_0: i32 = -1251;
pub const GNUTLS_E_INT_CHECK_AGAIN: i32 = -1252;
pub const GNUTLS_E_APPLICATION_ERROR_MAX: i32 = -65000;
pub const GNUTLS_E_APPLICATION_ERROR_MIN: i32 = -65500;
pub const GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT: u32 = 0;
pub const LIBGNUTLS_VERSION: &'static [u8; 7usize] = b"3.6.16\0";
pub const LIBGNUTLS_VERSION_MAJOR: u32 = 3;
pub const LIBGNUTLS_VERSION_MINOR: u32 = 6;
pub const LIBGNUTLS_VERSION_PATCH: u32 = 16;
pub const LIBGNUTLS_VERSION_NUMBER: u32 = 198160;
pub const LIBGNUTLS_EXTRA_VERSION: &'static [u8; 7usize] = b"3.6.16\0";
pub const GNUTLS_SUPPLEMENTAL_USER_MAPPING_DATA: u32 = 0;
pub const USERPREF_DEVICE_CERTIFICATE_KEY: &'static [u8; 18usize] = b"DeviceCertificate\0";
pub const USERPREF_ESCROW_BAG_KEY: &'static [u8; 10usize] = b"EscrowBag\0";
pub const USERPREF_HOST_CERTIFICATE_KEY: &'static [u8; 16usize] = b"HostCertificate\0";
pub const USERPREF_ROOT_CERTIFICATE_KEY: &'static [u8; 16usize] = b"RootCertificate\0";
pub const USERPREF_HOST_PRIVATE_KEY_KEY: &'static [u8; 15usize] = b"HostPrivateKey\0";
pub const USERPREF_ROOT_PRIVATE_KEY_KEY: &'static [u8; 15usize] = b"RootPrivateKey\0";
pub const USERPREF_HOST_ID_KEY: &'static [u8; 7usize] = b"HostID\0";
pub const USERPREF_SYSTEM_BUID_KEY: &'static [u8; 11usize] = b"SystemBUID\0";
pub const USERPREF_WIFI_MAC_ADDRESS_KEY: &'static [u8; 15usize] = b"WiFiMACAddress\0";
pub const DEVICE_CLASS_IPHONE: u32 = 1;
pub const DEVICE_CLASS_IPAD: u32 = 2;
pub const DEVICE_CLASS_IPOD: u32 = 3;
pub const DEVICE_CLASS_APPLETV: u32 = 4;
pub const DEVICE_CLASS_WATCH: u32 = 5;
pub const DEVICE_CLASS_UNKNOWN: u32 = 255;
pub const LOCKDOWN_PROTOCOL_VERSION: &'static [u8; 2usize] = b"2\0";
pub const INSTPROXY_SERVICE_NAME: &'static [u8; 36usize] = b"com.apple.mobile.installation_proxy\0";
pub const DEBUGSERVER_SERVICE_NAME: &'static [u8; 22usize] = b"com.apple.debugserver\0";
pub const DEBUGSERVER_SECURE_SERVICE_NAME: &'static [u8; 43usize] =
    b"com.apple.debugserver.DVTSecureSocketProxy\0";
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__mbstate8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>()))._mbstateL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU16 {
    pub __val: u16,
}
#[test]
fn bindgen_test_layout__OSUnalignedU16() {
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU16>(),
        2usize,
        concat!("Size of: ", stringify!(_OSUnalignedU16))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU16>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU16))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OSUnalignedU16>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU16),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU32 {
    pub __val: u32,
}
#[test]
fn bindgen_test_layout__OSUnalignedU32() {
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU32>(),
        4usize,
        concat!("Size of: ", stringify!(_OSUnalignedU32))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU32>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OSUnalignedU32>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU32),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU64 {
    pub __val: u64,
}
#[test]
fn bindgen_test_layout__OSUnalignedU64() {
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU64>(),
        8usize,
        concat!("Size of: ", stringify!(_OSUnalignedU64))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU64>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OSUnalignedU64>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU64),
            "::",
            stringify!(__val)
        )
    );
}
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = i64;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type daddr_t = i32;
pub type dev_t = __darwin_dev_t;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type mode_t = __darwin_mode_t;
pub type nlink_t = __uint16_t;
pub type id_t = __darwin_id_t;
pub type pid_t = __darwin_pid_t;
pub type off_t = __darwin_off_t;
pub type segsz_t = i32;
pub type swblk_t = i32;
pub type uid_t = __darwin_uid_t;
pub type clock_t = __darwin_clock_t;
pub type size_t = __darwin_size_t;
pub type ssize_t = __darwin_ssize_t;
pub type time_t = __darwin_time_t;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
extern "C" {
    pub fn __darwin_check_fd_set_overflow(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type fd_mask = __int32_t;
pub type pthread_attr_t = __darwin_pthread_attr_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ostat {
    pub st_dev: __uint16_t,
    pub st_ino: ino_t,
    pub st_mode: mode_t,
    pub st_nlink: nlink_t,
    pub st_uid: __uint16_t,
    pub st_gid: __uint16_t,
    pub st_rdev: __uint16_t,
    pub st_size: __int32_t,
    pub st_atimespec: timespec,
    pub st_mtimespec: timespec,
    pub st_ctimespec: timespec,
    pub st_blksize: __int32_t,
    pub st_blocks: __int32_t,
    pub st_flags: __uint32_t,
    pub st_gen: __uint32_t,
}
#[test]
fn bindgen_test_layout_ostat() {
    assert_eq!(
        ::std::mem::size_of::<ostat>(),
        96usize,
        concat!("Size of: ", stringify!(ostat))
    );
    assert_eq!(
        ::std::mem::align_of::<ostat>(),
        8usize,
        concat!("Alignment of ", stringify!(ostat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ostat>())).st_dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ostat>())).st_ino as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ostat>())).st_mode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ostat>())).st_nlink as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ostat>())).st_uid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ostat>())).st_gid as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ostat>())).st_rdev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ostat>())).st_size as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ostat>())).st_atimespec as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_atimespec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ostat>())).st_mtimespec as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_mtimespec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ostat>())).st_ctimespec as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_ctimespec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ostat>())).st_blksize as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ostat>())).st_blocks as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ostat>())).st_flags as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ostat>())).st_gen as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(ostat),
            "::",
            stringify!(st_gen)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_dev: dev_t,
    pub st_mode: mode_t,
    pub st_nlink: nlink_t,
    pub st_ino: __darwin_ino64_t,
    pub st_uid: uid_t,
    pub st_gid: gid_t,
    pub st_rdev: dev_t,
    pub st_atimespec: timespec,
    pub st_mtimespec: timespec,
    pub st_ctimespec: timespec,
    pub st_birthtimespec: timespec,
    pub st_size: off_t,
    pub st_blocks: blkcnt_t,
    pub st_blksize: blksize_t,
    pub st_flags: __uint32_t,
    pub st_gen: __uint32_t,
    pub st_lspare: __int32_t,
    pub st_qspare: [__int64_t; 2usize],
}
#[test]
fn bindgen_test_layout_stat() {
    assert_eq!(
        ::std::mem::size_of::<stat>(),
        144usize,
        concat!("Size of: ", stringify!(stat))
    );
    assert_eq!(
        ::std::mem::align_of::<stat>(),
        8usize,
        concat!("Alignment of ", stringify!(stat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_mode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_nlink as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_ino as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_uid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_gid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_rdev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_atimespec as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_atimespec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_mtimespec as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mtimespec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_ctimespec as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ctimespec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_birthtimespec as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_birthtimespec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_size as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_blocks as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_blksize as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_flags as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_gen as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_gen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_lspare as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_lspare)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_qspare as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_qspare)
        )
    );
}
extern "C" {
    pub fn chmod(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchmod(arg1: ::std::os::raw::c_int, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstat(arg1: ::std::os::raw::c_int, arg2: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lstat(arg1: *const ::std::os::raw::c_char, arg2: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdir(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifo(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stat(arg1: *const ::std::os::raw::c_char, arg2: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mknod(
        arg1: *const ::std::os::raw::c_char,
        arg2: mode_t,
        arg3: dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn umask(arg1: mode_t) -> mode_t;
}
extern "C" {
    pub fn fchmodat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: mode_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstatat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut stat,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdirat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimens(__fd: ::std::os::raw::c_int, __times: *const timespec)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimensat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __times: *const timespec,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _filesec {
    _unused: [u8; 0],
}
pub type filesec_t = *mut _filesec;
extern "C" {
    pub fn chflags(arg1: *const ::std::os::raw::c_char, arg2: __uint32_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chmodx_np(arg1: *const ::std::os::raw::c_char, arg2: filesec_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchflags(arg1: ::std::os::raw::c_int, arg2: __uint32_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchmodx_np(arg1: ::std::os::raw::c_int, arg2: filesec_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *mut stat,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchflags(arg1: *const ::std::os::raw::c_char, arg2: __uint32_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchmod(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lstatx_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut stat,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdirx_np(arg1: *const ::std::os::raw::c_char, arg2: filesec_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifox_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn statx_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut stat,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn umaskx_np(arg1: filesec_t) -> ::std::os::raw::c_int;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[doc = " The basic plist abstract data type."]
pub type plist_t = *mut ::std::os::raw::c_void;
#[doc = " The plist dictionary iterator."]
pub type plist_dict_iter = *mut ::std::os::raw::c_void;
#[doc = " The plist array iterator."]
pub type plist_array_iter = *mut ::std::os::raw::c_void;
#[doc = "< Boolean, scalar type"]
pub const plist_type_PLIST_BOOLEAN: plist_type = 0;
#[doc = "< Unsigned integer, scalar type"]
pub const plist_type_PLIST_UINT: plist_type = 1;
#[doc = "< Real, scalar type"]
pub const plist_type_PLIST_REAL: plist_type = 2;
#[doc = "< ASCII string, scalar type"]
pub const plist_type_PLIST_STRING: plist_type = 3;
#[doc = "< Ordered array, structured type"]
pub const plist_type_PLIST_ARRAY: plist_type = 4;
#[doc = "< Unordered dictionary (key/value pair), structured type"]
pub const plist_type_PLIST_DICT: plist_type = 5;
#[doc = "< Date, scalar type"]
pub const plist_type_PLIST_DATE: plist_type = 6;
#[doc = "< Binary data, scalar type"]
pub const plist_type_PLIST_DATA: plist_type = 7;
#[doc = "< Key in dictionaries (ASCII String), scalar type"]
pub const plist_type_PLIST_KEY: plist_type = 8;
#[doc = "< Special type used for 'keyed encoding'"]
pub const plist_type_PLIST_UID: plist_type = 9;
#[doc = "< No type"]
pub const plist_type_PLIST_NONE: plist_type = 10;
#[doc = " The enumeration of plist node types."]
pub type plist_type = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Create a new root plist_t type #PLIST_DICT"]
    #[doc = ""]
    #[doc = " @return the created plist"]
    #[doc = " @sa #plist_type"]
    pub fn plist_new_dict() -> plist_t;
}
extern "C" {
    #[doc = " Create a new root plist_t type #PLIST_ARRAY"]
    #[doc = ""]
    #[doc = " @return the created plist"]
    #[doc = " @sa #plist_type"]
    pub fn plist_new_array() -> plist_t;
}
extern "C" {
    #[doc = " Create a new plist_t type #PLIST_STRING"]
    #[doc = ""]
    #[doc = " @param val the sting value, encoded in UTF8."]
    #[doc = " @return the created item"]
    #[doc = " @sa #plist_type"]
    pub fn plist_new_string(val: *const ::std::os::raw::c_char) -> plist_t;
}
extern "C" {
    #[doc = " Create a new plist_t type #PLIST_BOOLEAN"]
    #[doc = ""]
    #[doc = " @param val the boolean value, 0 is false, other values are true."]
    #[doc = " @return the created item"]
    #[doc = " @sa #plist_type"]
    pub fn plist_new_bool(val: u8) -> plist_t;
}
extern "C" {
    #[doc = " Create a new plist_t type #PLIST_UINT"]
    #[doc = ""]
    #[doc = " @param val the unsigned integer value"]
    #[doc = " @return the created item"]
    #[doc = " @sa #plist_type"]
    pub fn plist_new_uint(val: u64) -> plist_t;
}
extern "C" {
    #[doc = " Create a new plist_t type #PLIST_REAL"]
    #[doc = ""]
    #[doc = " @param val the real value"]
    #[doc = " @return the created item"]
    #[doc = " @sa #plist_type"]
    pub fn plist_new_real(val: f64) -> plist_t;
}
extern "C" {
    #[doc = " Create a new plist_t type #PLIST_DATA"]
    #[doc = ""]
    #[doc = " @param val the binary buffer"]
    #[doc = " @param length the length of the buffer"]
    #[doc = " @return the created item"]
    #[doc = " @sa #plist_type"]
    pub fn plist_new_data(val: *const ::std::os::raw::c_char, length: u64) -> plist_t;
}
extern "C" {
    #[doc = " Create a new plist_t type #PLIST_DATE"]
    #[doc = ""]
    #[doc = " @param sec the number of seconds since 01/01/2001"]
    #[doc = " @param usec the number of microseconds"]
    #[doc = " @return the created item"]
    #[doc = " @sa #plist_type"]
    pub fn plist_new_date(sec: i32, usec: i32) -> plist_t;
}
extern "C" {
    #[doc = " Create a new plist_t type #PLIST_UID"]
    #[doc = ""]
    #[doc = " @param val the unsigned integer value"]
    #[doc = " @return the created item"]
    #[doc = " @sa #plist_type"]
    pub fn plist_new_uid(val: u64) -> plist_t;
}
extern "C" {
    #[doc = " Destruct a plist_t node and all its children recursively"]
    #[doc = ""]
    #[doc = " @param plist the plist to free"]
    pub fn plist_free(plist: plist_t);
}
extern "C" {
    #[doc = " Return a copy of passed node and it's children"]
    #[doc = ""]
    #[doc = " @param node the plist to copy"]
    #[doc = " @return copied plist"]
    pub fn plist_copy(node: plist_t) -> plist_t;
}
extern "C" {
    #[doc = " Get size of a #PLIST_ARRAY node."]
    #[doc = ""]
    #[doc = " @param node the node of type #PLIST_ARRAY"]
    #[doc = " @return size of the #PLIST_ARRAY node"]
    pub fn plist_array_get_size(node: plist_t) -> u32;
}
extern "C" {
    #[doc = " Get the nth item in a #PLIST_ARRAY node."]
    #[doc = ""]
    #[doc = " @param node the node of type #PLIST_ARRAY"]
    #[doc = " @param n the index of the item to get. Range is [0, array_size["]
    #[doc = " @return the nth item or NULL if node is not of type #PLIST_ARRAY"]
    pub fn plist_array_get_item(node: plist_t, n: u32) -> plist_t;
}
extern "C" {
    #[doc = " Get the index of an item. item must be a member of a #PLIST_ARRAY node."]
    #[doc = ""]
    #[doc = " @param node the node"]
    #[doc = " @return the node index or UINT_MAX if node index can't be determined"]
    pub fn plist_array_get_item_index(node: plist_t) -> u32;
}
extern "C" {
    #[doc = " Set the nth item in a #PLIST_ARRAY node."]
    #[doc = " The previous item at index n will be freed using #plist_free"]
    #[doc = ""]
    #[doc = " @param node the node of type #PLIST_ARRAY"]
    #[doc = " @param item the new item at index n. The array is responsible for freeing item when it is no longer needed."]
    #[doc = " @param n the index of the item to get. Range is [0, array_size[. Assert if n is not in range."]
    pub fn plist_array_set_item(node: plist_t, item: plist_t, n: u32);
}
extern "C" {
    #[doc = " Append a new item at the end of a #PLIST_ARRAY node."]
    #[doc = ""]
    #[doc = " @param node the node of type #PLIST_ARRAY"]
    #[doc = " @param item the new item. The array is responsible for freeing item when it is no longer needed."]
    pub fn plist_array_append_item(node: plist_t, item: plist_t);
}
extern "C" {
    #[doc = " Insert a new item at position n in a #PLIST_ARRAY node."]
    #[doc = ""]
    #[doc = " @param node the node of type #PLIST_ARRAY"]
    #[doc = " @param item the new item to insert. The array is responsible for freeing item when it is no longer needed."]
    #[doc = " @param n The position at which the node will be stored. Range is [0, array_size[. Assert if n is not in range."]
    pub fn plist_array_insert_item(node: plist_t, item: plist_t, n: u32);
}
extern "C" {
    #[doc = " Remove an existing position in a #PLIST_ARRAY node."]
    #[doc = " Removed position will be freed using #plist_free."]
    #[doc = ""]
    #[doc = " @param node the node of type #PLIST_ARRAY"]
    #[doc = " @param n The position to remove. Range is [0, array_size[. Assert if n is not in range."]
    pub fn plist_array_remove_item(node: plist_t, n: u32);
}
extern "C" {
    #[doc = " Remove a node that is a child node of a #PLIST_ARRAY node."]
    #[doc = " node will be freed using #plist_free."]
    #[doc = ""]
    #[doc = " @param node The node to be removed from its #PLIST_ARRAY parent."]
    pub fn plist_array_item_remove(node: plist_t);
}
extern "C" {
    #[doc = " Create an iterator of a #PLIST_ARRAY node."]
    #[doc = " The allocated iterator should be freed with the standard free function."]
    #[doc = ""]
    #[doc = " @param node The node of type #PLIST_ARRAY"]
    #[doc = " @param iter Location to store the iterator for the array."]
    pub fn plist_array_new_iter(node: plist_t, iter: *mut plist_array_iter);
}
extern "C" {
    #[doc = " Increment iterator of a #PLIST_ARRAY node."]
    #[doc = ""]
    #[doc = " @param node The node of type #PLIST_ARRAY."]
    #[doc = " @param iter Iterator of the array"]
    #[doc = " @param item Location to store the item. The caller must *not* free the"]
    #[doc = "          returned item. Will be set to NULL when no more items are left"]
    #[doc = "          to iterate."]
    pub fn plist_array_next_item(node: plist_t, iter: plist_array_iter, item: *mut plist_t);
}
extern "C" {
    #[doc = " Get size of a #PLIST_DICT node."]
    #[doc = ""]
    #[doc = " @param node the node of type #PLIST_DICT"]
    #[doc = " @return size of the #PLIST_DICT node"]
    pub fn plist_dict_get_size(node: plist_t) -> u32;
}
extern "C" {
    #[doc = " Create an iterator of a #PLIST_DICT node."]
    #[doc = " The allocated iterator should be freed with the standard free function."]
    #[doc = ""]
    #[doc = " @param node The node of type #PLIST_DICT."]
    #[doc = " @param iter Location to store the iterator for the dictionary."]
    pub fn plist_dict_new_iter(node: plist_t, iter: *mut plist_dict_iter);
}
extern "C" {
    #[doc = " Increment iterator of a #PLIST_DICT node."]
    #[doc = ""]
    #[doc = " @param node The node of type #PLIST_DICT"]
    #[doc = " @param iter Iterator of the dictionary"]
    #[doc = " @param key Location to store the key, or NULL. The caller is responsible"]
    #[doc = "\t\tfor freeing the the returned string."]
    #[doc = " @param val Location to store the value, or NULL. The caller must *not*"]
    #[doc = "\t\tfree the returned value. Will be set to NULL when no more"]
    #[doc = "\t\tkey/value pairs are left to iterate."]
    pub fn plist_dict_next_item(
        node: plist_t,
        iter: plist_dict_iter,
        key: *mut *mut ::std::os::raw::c_char,
        val: *mut plist_t,
    );
}
extern "C" {
    #[doc = " Get key associated key to an item. Item must be member of a dictionary."]
    #[doc = ""]
    #[doc = " @param node the item"]
    #[doc = " @param key a location to store the key. The caller is responsible for freeing the returned string."]
    pub fn plist_dict_get_item_key(node: plist_t, key: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Get the nth item in a #PLIST_DICT node."]
    #[doc = ""]
    #[doc = " @param node the node of type #PLIST_DICT"]
    #[doc = " @param key the identifier of the item to get."]
    #[doc = " @return the item or NULL if node is not of type #PLIST_DICT. The caller should not free"]
    #[doc = "\t\tthe returned node."]
    pub fn plist_dict_get_item(node: plist_t, key: *const ::std::os::raw::c_char) -> plist_t;
}
extern "C" {
    #[doc = " Get key node associated to an item. Item must be member of a dictionary."]
    #[doc = ""]
    #[doc = " @param node the item"]
    #[doc = " @return the key node of the given item, or NULL."]
    pub fn plist_dict_item_get_key(node: plist_t) -> plist_t;
}
extern "C" {
    #[doc = " Set item identified by key in a #PLIST_DICT node."]
    #[doc = " The previous item identified by key will be freed using #plist_free."]
    #[doc = " If there is no item for the given key a new item will be inserted."]
    #[doc = ""]
    #[doc = " @param node the node of type #PLIST_DICT"]
    #[doc = " @param item the new item associated to key"]
    #[doc = " @param key the identifier of the item to set."]
    pub fn plist_dict_set_item(node: plist_t, key: *const ::std::os::raw::c_char, item: plist_t);
}
extern "C" {
    #[doc = " Insert a new item into a #PLIST_DICT node."]
    #[doc = ""]
    #[doc = " @deprecated Deprecated. Use plist_dict_set_item instead."]
    #[doc = ""]
    #[doc = " @param node the node of type #PLIST_DICT"]
    #[doc = " @param item the new item to insert"]
    #[doc = " @param key The identifier of the item to insert."]
    pub fn plist_dict_insert_item(node: plist_t, key: *const ::std::os::raw::c_char, item: plist_t);
}
extern "C" {
    #[doc = " Remove an existing position in a #PLIST_DICT node."]
    #[doc = " Removed position will be freed using #plist_free"]
    #[doc = ""]
    #[doc = " @param node the node of type #PLIST_DICT"]
    #[doc = " @param key The identifier of the item to remove. Assert if identifier is not present."]
    pub fn plist_dict_remove_item(node: plist_t, key: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Merge a dictionary into another. This will add all key/value pairs"]
    #[doc = " from the source dictionary to the target dictionary, overwriting"]
    #[doc = " any existing key/value pairs that are already present in target."]
    #[doc = ""]
    #[doc = " @param target pointer to an existing node of type #PLIST_DICT"]
    #[doc = " @param source node of type #PLIST_DICT that should be merged into target"]
    pub fn plist_dict_merge(target: *mut plist_t, source: plist_t);
}
extern "C" {
    #[doc = " Get the parent of a node"]
    #[doc = ""]
    #[doc = " @param node the parent (NULL if node is root)"]
    pub fn plist_get_parent(node: plist_t) -> plist_t;
}
extern "C" {
    #[doc = " Get the #plist_type of a node."]
    #[doc = ""]
    #[doc = " @param node the node"]
    #[doc = " @return the type of the node"]
    pub fn plist_get_node_type(node: plist_t) -> plist_type;
}
extern "C" {
    #[doc = " Get the value of a #PLIST_KEY node."]
    #[doc = " This function does nothing if node is not of type #PLIST_KEY"]
    #[doc = ""]
    #[doc = " @param node the node"]
    #[doc = " @param val a pointer to a C-string. This function allocates the memory,"]
    #[doc = "            caller is responsible for freeing it."]
    #[doc = " @note Use plist_mem_free() to free the allocated memory."]
    pub fn plist_get_key_val(node: plist_t, val: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Get the value of a #PLIST_STRING node."]
    #[doc = " This function does nothing if node is not of type #PLIST_STRING"]
    #[doc = ""]
    #[doc = " @param node the node"]
    #[doc = " @param val a pointer to a C-string. This function allocates the memory,"]
    #[doc = "            caller is responsible for freeing it. Data is UTF-8 encoded."]
    #[doc = " @note Use plist_mem_free() to free the allocated memory."]
    pub fn plist_get_string_val(node: plist_t, val: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Get a pointer to the buffer of a #PLIST_STRING node."]
    #[doc = ""]
    #[doc = " @note DO NOT MODIFY the buffer. Mind that the buffer is only available"]
    #[doc = "   until the plist node gets freed. Make a copy if needed."]
    #[doc = ""]
    #[doc = " @param node The node"]
    #[doc = " @param length If non-NULL, will be set to the length of the string"]
    #[doc = ""]
    #[doc = " @return Pointer to the NULL-terminated buffer."]
    pub fn plist_get_string_ptr(node: plist_t, length: *mut u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the value of a #PLIST_BOOLEAN node."]
    #[doc = " This function does nothing if node is not of type #PLIST_BOOLEAN"]
    #[doc = ""]
    #[doc = " @param node the node"]
    #[doc = " @param val a pointer to a uint8_t variable."]
    pub fn plist_get_bool_val(node: plist_t, val: *mut u8);
}
extern "C" {
    #[doc = " Get the value of a #PLIST_UINT node."]
    #[doc = " This function does nothing if node is not of type #PLIST_UINT"]
    #[doc = ""]
    #[doc = " @param node the node"]
    #[doc = " @param val a pointer to a uint64_t variable."]
    pub fn plist_get_uint_val(node: plist_t, val: *mut u64);
}
extern "C" {
    #[doc = " Get the value of a #PLIST_REAL node."]
    #[doc = " This function does nothing if node is not of type #PLIST_REAL"]
    #[doc = ""]
    #[doc = " @param node the node"]
    #[doc = " @param val a pointer to a double variable."]
    pub fn plist_get_real_val(node: plist_t, val: *mut f64);
}
extern "C" {
    #[doc = " Get the value of a #PLIST_DATA node."]
    #[doc = " This function does nothing if node is not of type #PLIST_DATA"]
    #[doc = ""]
    #[doc = " @param node the node"]
    #[doc = " @param val a pointer to an unallocated char buffer. This function allocates the memory,"]
    #[doc = "            caller is responsible for freeing it."]
    #[doc = " @param length the length of the buffer"]
    #[doc = " @note Use plist_mem_free() to free the allocated memory."]
    pub fn plist_get_data_val(
        node: plist_t,
        val: *mut *mut ::std::os::raw::c_char,
        length: *mut u64,
    );
}
extern "C" {
    #[doc = " Get a pointer to the data buffer of a #PLIST_DATA node."]
    #[doc = ""]
    #[doc = " @note DO NOT MODIFY the buffer. Mind that the buffer is only available"]
    #[doc = "   until the plist node gets freed. Make a copy if needed."]
    #[doc = ""]
    #[doc = " @param node The node"]
    #[doc = " @param length Pointer to a uint64_t that will be set to the length of the buffer"]
    #[doc = ""]
    #[doc = " @return Pointer to the buffer"]
    pub fn plist_get_data_ptr(node: plist_t, length: *mut u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the value of a #PLIST_DATE node."]
    #[doc = " This function does nothing if node is not of type #PLIST_DATE"]
    #[doc = ""]
    #[doc = " @param node the node"]
    #[doc = " @param sec a pointer to an int32_t variable. Represents the number of seconds since 01/01/2001."]
    #[doc = " @param usec a pointer to an int32_t variable. Represents the number of microseconds"]
    pub fn plist_get_date_val(node: plist_t, sec: *mut i32, usec: *mut i32);
}
extern "C" {
    #[doc = " Get the value of a #PLIST_UID node."]
    #[doc = " This function does nothing if node is not of type #PLIST_UID"]
    #[doc = ""]
    #[doc = " @param node the node"]
    #[doc = " @param val a pointer to a uint64_t variable."]
    pub fn plist_get_uid_val(node: plist_t, val: *mut u64);
}
extern "C" {
    #[doc = " Set the value of a node."]
    #[doc = " Forces type of node to #PLIST_KEY"]
    #[doc = ""]
    #[doc = " @param node the node"]
    #[doc = " @param val the key value"]
    pub fn plist_set_key_val(node: plist_t, val: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Set the value of a node."]
    #[doc = " Forces type of node to #PLIST_STRING"]
    #[doc = ""]
    #[doc = " @param node the node"]
    #[doc = " @param val the string value. The string is copied when set and will be"]
    #[doc = "\t\tfreed by the node."]
    pub fn plist_set_string_val(node: plist_t, val: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Set the value of a node."]
    #[doc = " Forces type of node to #PLIST_BOOLEAN"]
    #[doc = ""]
    #[doc = " @param node the node"]
    #[doc = " @param val the boolean value"]
    pub fn plist_set_bool_val(node: plist_t, val: u8);
}
extern "C" {
    #[doc = " Set the value of a node."]
    #[doc = " Forces type of node to #PLIST_UINT"]
    #[doc = ""]
    #[doc = " @param node the node"]
    #[doc = " @param val the unsigned integer value"]
    pub fn plist_set_uint_val(node: plist_t, val: u64);
}
extern "C" {
    #[doc = " Set the value of a node."]
    #[doc = " Forces type of node to #PLIST_REAL"]
    #[doc = ""]
    #[doc = " @param node the node"]
    #[doc = " @param val the real value"]
    pub fn plist_set_real_val(node: plist_t, val: f64);
}
extern "C" {
    #[doc = " Set the value of a node."]
    #[doc = " Forces type of node to #PLIST_DATA"]
    #[doc = ""]
    #[doc = " @param node the node"]
    #[doc = " @param val the binary buffer. The buffer is copied when set and will"]
    #[doc = "\t\tbe freed by the node."]
    #[doc = " @param length the length of the buffer"]
    pub fn plist_set_data_val(node: plist_t, val: *const ::std::os::raw::c_char, length: u64);
}
extern "C" {
    #[doc = " Set the value of a node."]
    #[doc = " Forces type of node to #PLIST_DATE"]
    #[doc = ""]
    #[doc = " @param node the node"]
    #[doc = " @param sec the number of seconds since 01/01/2001"]
    #[doc = " @param usec the number of microseconds"]
    pub fn plist_set_date_val(node: plist_t, sec: i32, usec: i32);
}
extern "C" {
    #[doc = " Set the value of a node."]
    #[doc = " Forces type of node to #PLIST_UID"]
    #[doc = ""]
    #[doc = " @param node the node"]
    #[doc = " @param val the unsigned integer value"]
    pub fn plist_set_uid_val(node: plist_t, val: u64);
}
extern "C" {
    #[doc = " Export the #plist_t structure to XML format."]
    #[doc = ""]
    #[doc = " @param plist the root node to export"]
    #[doc = " @param plist_xml a pointer to a C-string. This function allocates the memory,"]
    #[doc = "            caller is responsible for freeing it. Data is UTF-8 encoded."]
    #[doc = " @param length a pointer to an uint32_t variable. Represents the length of the allocated buffer."]
    #[doc = " @note Use plist_mem_free() to free the allocated memory."]
    pub fn plist_to_xml(
        plist: plist_t,
        plist_xml: *mut *mut ::std::os::raw::c_char,
        length: *mut u32,
    );
}
extern "C" {
    #[doc = " Export the #plist_t structure to binary format."]
    #[doc = ""]
    #[doc = " @param plist the root node to export"]
    #[doc = " @param plist_bin a pointer to a char* buffer. This function allocates the memory,"]
    #[doc = "            caller is responsible for freeing it."]
    #[doc = " @param length a pointer to an uint32_t variable. Represents the length of the allocated buffer."]
    #[doc = " @note Use plist_mem_free() to free the allocated memory."]
    pub fn plist_to_bin(
        plist: plist_t,
        plist_bin: *mut *mut ::std::os::raw::c_char,
        length: *mut u32,
    );
}
extern "C" {
    #[doc = " Import the #plist_t structure from XML format."]
    #[doc = ""]
    #[doc = " @param plist_xml a pointer to the xml buffer."]
    #[doc = " @param length length of the buffer to read."]
    #[doc = " @param plist a pointer to the imported plist."]
    pub fn plist_from_xml(
        plist_xml: *const ::std::os::raw::c_char,
        length: u32,
        plist: *mut plist_t,
    );
}
extern "C" {
    #[doc = " Import the #plist_t structure from binary format."]
    #[doc = ""]
    #[doc = " @param plist_bin a pointer to the xml buffer."]
    #[doc = " @param length length of the buffer to read."]
    #[doc = " @param plist a pointer to the imported plist."]
    pub fn plist_from_bin(
        plist_bin: *const ::std::os::raw::c_char,
        length: u32,
        plist: *mut plist_t,
    );
}
extern "C" {
    #[doc = " Import the #plist_t structure from memory data."]
    #[doc = " This method will look at the first bytes of plist_data"]
    #[doc = " to determine if plist_data contains a binary or XML plist."]
    #[doc = ""]
    #[doc = " @param plist_data a pointer to the memory buffer containing plist data."]
    #[doc = " @param length length of the buffer to read."]
    #[doc = " @param plist a pointer to the imported plist."]
    pub fn plist_from_memory(
        plist_data: *const ::std::os::raw::c_char,
        length: u32,
        plist: *mut plist_t,
    );
}
extern "C" {
    #[doc = " Test if in-memory plist data is binary or XML"]
    #[doc = " This method will look at the first bytes of plist_data"]
    #[doc = " to determine if plist_data contains a binary or XML plist."]
    #[doc = " This method is not validating the whole memory buffer to check if the"]
    #[doc = " content is truly a plist, it's only using some heuristic on the first few"]
    #[doc = " bytes of plist_data."]
    #[doc = ""]
    #[doc = " @param plist_data a pointer to the memory buffer containing plist data."]
    #[doc = " @param length length of the buffer to read."]
    #[doc = " @return 1 if the buffer is a binary plist, 0 otherwise."]
    pub fn plist_is_binary(
        plist_data: *const ::std::os::raw::c_char,
        length: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a node from its path. Each path element depends on the associated father node type."]
    #[doc = " For Dictionaries, var args are casted to const char*, for arrays, var args are caster to uint32_t"]
    #[doc = " Search is breath first order."]
    #[doc = ""]
    #[doc = " @param plist the node to access result from."]
    #[doc = " @param length length of the path to access"]
    #[doc = " @return the value to access."]
    pub fn plist_access_path(plist: plist_t, length: u32, ...) -> plist_t;
}
extern "C" {
    #[doc = " Variadic version of #plist_access_path."]
    #[doc = ""]
    #[doc = " @param plist the node to access result from."]
    #[doc = " @param length length of the path to access"]
    #[doc = " @param v list of array's index and dic'st key"]
    #[doc = " @return the value to access."]
    pub fn plist_access_pathv(plist: plist_t, length: u32, v: va_list) -> plist_t;
}
extern "C" {
    #[doc = " Compare two node values"]
    #[doc = ""]
    #[doc = " @param node_l left node to compare"]
    #[doc = " @param node_r rigth node to compare"]
    #[doc = " @return TRUE is type and value match, FALSE otherwise."]
    pub fn plist_compare_node_value(node_l: plist_t, node_r: plist_t) -> ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Helper function to check the value of a PLIST_BOOL node."]
    #[doc = ""]
    #[doc = " @param boolnode node of type PLIST_BOOL"]
    #[doc = " @return 1 if the boolean node has a value of TRUE, 0 if FALSE,"]
    #[doc = "   or -1 if the node is not of type PLIST_BOOL"]
    pub fn plist_bool_val_is_true(boolnode: plist_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to compare the value of a PLIST_UINT node against"]
    #[doc = " a given value."]
    #[doc = ""]
    #[doc = " @param uintnode node of type PLIST_UINT"]
    #[doc = " @param cmpval value to compare against"]
    #[doc = " @return 0 if the node's value and cmpval are equal,"]
    #[doc = "         1 if the node's value is greater than cmpval,"]
    #[doc = "         or -1 if the node's value is less than cmpval."]
    pub fn plist_uint_val_compare(uintnode: plist_t, cmpval: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to compare the value of a PLIST_UID node against"]
    #[doc = " a given value."]
    #[doc = ""]
    #[doc = " @param uidnode node of type PLIST_UID"]
    #[doc = " @param cmpval value to compare against"]
    #[doc = " @return 0 if the node's value and cmpval are equal,"]
    #[doc = "         1 if the node's value is greater than cmpval,"]
    #[doc = "         or -1 if the node's value is less than cmpval."]
    pub fn plist_uid_val_compare(uidnode: plist_t, cmpval: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to compare the value of a PLIST_REAL node against"]
    #[doc = " a given value."]
    #[doc = ""]
    #[doc = " @note WARNING: Comparing floating point values can give inaccurate"]
    #[doc = "     results because of the nature of floating point values on computer"]
    #[doc = "     systems. While this function is designed to be as accurate as"]
    #[doc = "     possible, please don't rely on it too much."]
    #[doc = ""]
    #[doc = " @param realnode node of type PLIST_REAL"]
    #[doc = " @param cmpval value to compare against"]
    #[doc = " @return 0 if the node's value and cmpval are (almost) equal,"]
    #[doc = "         1 if the node's value is greater than cmpval,"]
    #[doc = "         or -1 if the node's value is less than cmpval."]
    pub fn plist_real_val_compare(realnode: plist_t, cmpval: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to compare the value of a PLIST_DATE node against"]
    #[doc = " a given set of seconds and fraction of a second since epoch."]
    #[doc = ""]
    #[doc = " @param datenode node of type PLIST_DATE"]
    #[doc = " @param cmpsec number of seconds since epoch to compare against"]
    #[doc = " @param cmpusec fraction of a second in microseconds to compare against"]
    #[doc = " @return 0 if the node's date is equal to the supplied values,"]
    #[doc = "         1 if the node's date is greater than the supplied values,"]
    #[doc = "         or -1 if the node's date is less than the supplied values."]
    pub fn plist_date_val_compare(
        datenode: plist_t,
        cmpsec: i32,
        cmpusec: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to compare the value of a PLIST_STRING node against"]
    #[doc = " a given value."]
    #[doc = " This function basically behaves like strcmp."]
    #[doc = ""]
    #[doc = " @param strnode node of type PLIST_STRING"]
    #[doc = " @param cmpval value to compare against"]
    #[doc = " @return 0 if the node's value and cmpval are equal,"]
    #[doc = "     > 0 if the node's value is lexicographically greater than cmpval,"]
    #[doc = "     or < 0 if the node's value is lexicographically less than cmpval."]
    pub fn plist_string_val_compare(
        strnode: plist_t,
        cmpval: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to compare the value of a PLIST_STRING node against"]
    #[doc = " a given value, while not comparing more than n characters."]
    #[doc = " This function basically behaves like strncmp."]
    #[doc = ""]
    #[doc = " @param strnode node of type PLIST_STRING"]
    #[doc = " @param cmpval value to compare against"]
    #[doc = " @param n maximum number of characters to compare"]
    #[doc = " @return 0 if the node's value and cmpval are equal,"]
    #[doc = "     > 0 if the node's value is lexicographically greater than cmpval,"]
    #[doc = "     or < 0 if the node's value is lexicographically less than cmpval."]
    pub fn plist_string_val_compare_with_size(
        strnode: plist_t,
        cmpval: *const ::std::os::raw::c_char,
        n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to match a given substring in the value of a"]
    #[doc = " PLIST_STRING node."]
    #[doc = ""]
    #[doc = " @param strnode node of type PLIST_STRING"]
    #[doc = " @param substr value to match"]
    #[doc = " @return 1 if the node's value contains the given substring,"]
    #[doc = "     or 0 if not."]
    pub fn plist_string_val_contains(
        strnode: plist_t,
        substr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to compare the value of a PLIST_KEY node against"]
    #[doc = " a given value."]
    #[doc = " This function basically behaves like strcmp."]
    #[doc = ""]
    #[doc = " @param keynode node of type PLIST_KEY"]
    #[doc = " @param cmpval value to compare against"]
    #[doc = " @return 0 if the node's value and cmpval are equal,"]
    #[doc = "     > 0 if the node's value is lexicographically greater than cmpval,"]
    #[doc = "     or < 0 if the node's value is lexicographically less than cmpval."]
    pub fn plist_key_val_compare(
        keynode: plist_t,
        cmpval: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to compare the value of a PLIST_KEY node against"]
    #[doc = " a given value, while not comparing more than n characters."]
    #[doc = " This function basically behaves like strncmp."]
    #[doc = ""]
    #[doc = " @param keynode node of type PLIST_KEY"]
    #[doc = " @param cmpval value to compare against"]
    #[doc = " @param n maximum number of characters to compare"]
    #[doc = " @return 0 if the node's value and cmpval are equal,"]
    #[doc = "     > 0 if the node's value is lexicographically greater than cmpval,"]
    #[doc = "     or < 0 if the node's value is lexicographically less than cmpval."]
    pub fn plist_key_val_compare_with_size(
        keynode: plist_t,
        cmpval: *const ::std::os::raw::c_char,
        n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to match a given substring in the value of a"]
    #[doc = " PLIST_KEY node."]
    #[doc = ""]
    #[doc = " @param keynode node of type PLIST_KEY"]
    #[doc = " @param substr value to match"]
    #[doc = " @return 1 if the node's value contains the given substring,"]
    #[doc = "     or 0 if not."]
    pub fn plist_key_val_contains(
        keynode: plist_t,
        substr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to compare the data of a PLIST_DATA node against"]
    #[doc = " a given blob and size."]
    #[doc = " This function basically behaves like memcmp after making sure the"]
    #[doc = " size of the node's data value is equal to the size of cmpval (n),"]
    #[doc = " making this a \"full match\" comparison."]
    #[doc = ""]
    #[doc = " @param datanode node of type PLIST_DATA"]
    #[doc = " @param cmpval data blob to compare against"]
    #[doc = " @param n size of data blob passed in cmpval"]
    #[doc = " @return 0 if the node's data blob and cmpval are equal,"]
    #[doc = "     > 0 if the node's value is lexicographically greater than cmpval,"]
    #[doc = "     or < 0 if the node's value is lexicographically less than cmpval."]
    pub fn plist_data_val_compare(
        datanode: plist_t,
        cmpval: *const u8,
        n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to compare the data of a PLIST_DATA node against"]
    #[doc = " a given blob and size, while no more than n bytes are compared."]
    #[doc = " This function basically behaves like memcmp after making sure the"]
    #[doc = " size of the node's data value is at least n, making this a"]
    #[doc = " \"starts with\" comparison."]
    #[doc = ""]
    #[doc = " @param datanode node of type PLIST_DATA"]
    #[doc = " @param cmpval data blob to compare against"]
    #[doc = " @param n size of data blob passed in cmpval"]
    #[doc = " @return 0 if the node's value and cmpval are equal,"]
    #[doc = "     > 0 if the node's value is lexicographically greater than cmpval,"]
    #[doc = "     or < 0 if the node's value is lexicographically less than cmpval."]
    pub fn plist_data_val_compare_with_size(
        datanode: plist_t,
        cmpval: *const u8,
        n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to match a given data blob within the value of a"]
    #[doc = " PLIST_DATA node."]
    #[doc = ""]
    #[doc = " @param datanode node of type PLIST_KEY"]
    #[doc = " @param cmpval data blob to match"]
    #[doc = " @param n size of data blob passed in cmpval"]
    #[doc = " @return 1 if the node's value contains the given data blob"]
    #[doc = "     or 0 if not."]
    pub fn plist_data_val_contains(
        datanode: plist_t,
        cmpval: *const u8,
        n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free memory allocated by relevant libplist API calls:"]
    #[doc = " - plist_to_xml()"]
    #[doc = " - plist_to_bin()"]
    #[doc = " - plist_get_key_val()"]
    #[doc = " - plist_get_string_val()"]
    #[doc = " - plist_get_data_val()"]
    #[doc = ""]
    #[doc = " @param ptr pointer to the memory to free"]
    #[doc = ""]
    #[doc = " @note Do not use this function to free plist_t nodes, use plist_free()"]
    #[doc = "     instead."]
    pub fn plist_mem_free(ptr: *mut ::std::os::raw::c_void);
}
pub const idevice_error_t_IDEVICE_E_SUCCESS: idevice_error_t = 0;
pub const idevice_error_t_IDEVICE_E_INVALID_ARG: idevice_error_t = -1;
pub const idevice_error_t_IDEVICE_E_UNKNOWN_ERROR: idevice_error_t = -2;
pub const idevice_error_t_IDEVICE_E_NO_DEVICE: idevice_error_t = -3;
pub const idevice_error_t_IDEVICE_E_NOT_ENOUGH_DATA: idevice_error_t = -4;
pub const idevice_error_t_IDEVICE_E_CONNREFUSED: idevice_error_t = -5;
pub const idevice_error_t_IDEVICE_E_SSL_ERROR: idevice_error_t = -6;
pub const idevice_error_t_IDEVICE_E_TIMEOUT: idevice_error_t = -7;
#[doc = " Error Codes"]
pub type idevice_error_t = ::std::os::raw::c_int;
pub type idevice_t = *mut idevice_private;
pub type idevice_connection_t = *mut idevice_connection_private;
#[doc = "< include USBMUX devices during lookup"]
pub const idevice_options_IDEVICE_LOOKUP_USBMUX: idevice_options = 2;
#[doc = "< include network devices during lookup"]
pub const idevice_options_IDEVICE_LOOKUP_NETWORK: idevice_options = 4;
#[doc = "< prefer network connection if device is available via USBMUX *and* network"]
pub const idevice_options_IDEVICE_LOOKUP_PREFER_NETWORK: idevice_options = 8;
#[doc = " Options for idevice_new_with_options()"]
pub type idevice_options = ::std::os::raw::c_uint;
pub const idevice_connection_type_CONNECTION_USBMUXD: idevice_connection_type = 1;
pub const idevice_connection_type_CONNECTION_NETWORK: idevice_connection_type = 2;
#[doc = " Type of connection a device is available on"]
pub type idevice_connection_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct idevice_info {
    pub udid: *mut ::std::os::raw::c_char,
    pub conn_type: idevice_connection_type,
    pub conn_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_idevice_info() {
    assert_eq!(
        ::std::mem::size_of::<idevice_info>(),
        24usize,
        concat!("Size of: ", stringify!(idevice_info))
    );
    assert_eq!(
        ::std::mem::align_of::<idevice_info>(),
        8usize,
        concat!("Alignment of ", stringify!(idevice_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idevice_info>())).udid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_info),
            "::",
            stringify!(udid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idevice_info>())).conn_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_info),
            "::",
            stringify!(conn_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idevice_info>())).conn_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_info),
            "::",
            stringify!(conn_data)
        )
    );
}
pub type idevice_info_t = *mut idevice_info;
pub const idevice_event_type_IDEVICE_DEVICE_ADD: idevice_event_type = 1;
pub const idevice_event_type_IDEVICE_DEVICE_REMOVE: idevice_event_type = 2;
pub const idevice_event_type_IDEVICE_DEVICE_PAIRED: idevice_event_type = 3;
#[doc = " The event type for device add or removal"]
pub type idevice_event_type = ::std::os::raw::c_uint;
#[doc = " Provides information about the occurred event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct idevice_event_t {
    #[doc = "< The event type."]
    pub event: idevice_event_type,
    #[doc = "< The device unique id."]
    pub udid: *const ::std::os::raw::c_char,
    #[doc = "< The connection type."]
    pub conn_type: idevice_connection_type,
}
#[test]
fn bindgen_test_layout_idevice_event_t() {
    assert_eq!(
        ::std::mem::size_of::<idevice_event_t>(),
        24usize,
        concat!("Size of: ", stringify!(idevice_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<idevice_event_t>(),
        8usize,
        concat!("Alignment of ", stringify!(idevice_event_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idevice_event_t>())).event as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idevice_event_t>())).udid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_event_t),
            "::",
            stringify!(udid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idevice_event_t>())).conn_type as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_event_t),
            "::",
            stringify!(conn_type)
        )
    );
}
#[doc = " Callback to notifiy if a device was added or removed."]
pub type idevice_event_cb_t = ::std::option::Option<
    unsafe extern "C" fn(event: *const idevice_event_t, user_data: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " Set the level of debugging."]
    #[doc = ""]
    #[doc = " @param level Set to 0 for no debug output or 1 to enable debug output."]
    pub fn idevice_set_debug_level(level: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Register a callback function that will be called when device add/remove"]
    #[doc = " events occur."]
    #[doc = ""]
    #[doc = " @param callback Callback function to call."]
    #[doc = " @param user_data Application-specific data passed as parameter"]
    #[doc = "   to the registered callback function."]
    #[doc = ""]
    #[doc = " @return IDEVICE_E_SUCCESS on success or an error value when an error occurred."]
    pub fn idevice_event_subscribe(
        callback: idevice_event_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> idevice_error_t;
}
extern "C" {
    #[doc = " Release the event callback function that has been registered with"]
    #[doc = "  idevice_event_subscribe()."]
    #[doc = ""]
    #[doc = " @return IDEVICE_E_SUCCESS on success or an error value when an error occurred."]
    pub fn idevice_event_unsubscribe() -> idevice_error_t;
}
extern "C" {
    #[doc = " Get a list of UDIDs of currently available devices (USBMUX devices only)."]
    #[doc = ""]
    #[doc = " @param devices List of UDIDs of devices that are currently available."]
    #[doc = "   This list is terminated by a NULL pointer."]
    #[doc = " @param count Number of devices found."]
    #[doc = ""]
    #[doc = " @return IDEVICE_E_SUCCESS on success or an error value when an error occurred."]
    #[doc = ""]
    #[doc = " @note This function only returns the UDIDs of USBMUX devices. To also include"]
    #[doc = "   network devices in the list, use idevice_get_device_list_extended()."]
    #[doc = " @see idevice_get_device_list_extended"]
    pub fn idevice_get_device_list(
        devices: *mut *mut *mut ::std::os::raw::c_char,
        count: *mut ::std::os::raw::c_int,
    ) -> idevice_error_t;
}
extern "C" {
    #[doc = " Free a list of device UDIDs."]
    #[doc = ""]
    #[doc = " @param devices List of UDIDs to free."]
    #[doc = ""]
    #[doc = " @return Always returnes IDEVICE_E_SUCCESS."]
    pub fn idevice_device_list_free(devices: *mut *mut ::std::os::raw::c_char) -> idevice_error_t;
}
extern "C" {
    #[doc = " Get a list of currently available devices"]
    #[doc = ""]
    #[doc = " @param devices List of idevice_info_t records with device information."]
    #[doc = "   This list is terminated by a NULL pointer."]
    #[doc = " @param count Number of devices included in the list."]
    #[doc = ""]
    #[doc = " @return IDEVICE_E_SUCCESS on success or an error value when an error occurred."]
    pub fn idevice_get_device_list_extended(
        devices: *mut *mut idevice_info_t,
        count: *mut ::std::os::raw::c_int,
    ) -> idevice_error_t;
}
extern "C" {
    #[doc = " Free an extended device list retrieved through idevice_get_device_list_extended()."]
    #[doc = ""]
    #[doc = " @param devices Device list to free."]
    #[doc = ""]
    #[doc = " @return IDEVICE_E_SUCCESS on success or an error value when an error occurred."]
    pub fn idevice_device_list_extended_free(devices: *mut idevice_info_t) -> idevice_error_t;
}
extern "C" {
    #[doc = " Creates an idevice_t structure for the device specified by UDID,"]
    #[doc = "  if the device is available (USBMUX devices only)."]
    #[doc = ""]
    #[doc = " @note The resulting idevice_t structure has to be freed with"]
    #[doc = " idevice_free() if it is no longer used."]
    #[doc = " If you need to connect to a device available via network, use"]
    #[doc = " idevice_new_with_options() and include IDEVICE_LOOKUP_NETWORK in options."]
    #[doc = ""]
    #[doc = " @see idevice_new_with_options"]
    #[doc = ""]
    #[doc = " @param device Upon calling this function, a pointer to a location of type"]
    #[doc = "  idevice_t. On successful return, this location will be populated."]
    #[doc = " @param udid The UDID to match."]
    #[doc = ""]
    #[doc = " @return IDEVICE_E_SUCCESS if ok, otherwise an error code."]
    pub fn idevice_new(
        device: *mut idevice_t,
        udid: *const ::std::os::raw::c_char,
    ) -> idevice_error_t;
}
extern "C" {
    #[doc = " Creates an idevice_t structure for the device specified by UDID,"]
    #[doc = "  if the device is available, with the given lookup options."]
    #[doc = ""]
    #[doc = " @note The resulting idevice_t structure has to be freed with"]
    #[doc = " idevice_free() if it is no longer used."]
    #[doc = ""]
    #[doc = " @param device Upon calling this function, a pointer to a location of type"]
    #[doc = "   idevice_t. On successful return, this location will be populated."]
    #[doc = " @param udid The UDID to match."]
    #[doc = " @param options Specifies what connection types should be considered"]
    #[doc = "   when looking up devices. Accepts bitwise or'ed values of idevice_options."]
    #[doc = "   If 0 (no option) is specified it will default to IDEVICE_LOOKUP_USBMUX."]
    #[doc = "   To lookup both USB and network-connected devices, pass"]
    #[doc = "   IDEVICE_LOOKUP_USBMUX | IDEVICE_LOOKUP_NETWORK. If a device is available"]
    #[doc = "   both via USBMUX *and* network, it will select the USB connection."]
    #[doc = "   This behavior can be changed by adding IDEVICE_LOOKUP_PREFER_NETWORK"]
    #[doc = "   to the options in which case it will select the network connection."]
    #[doc = ""]
    #[doc = " @return IDEVICE_E_SUCCESS if ok, otherwise an error code."]
    pub fn idevice_new_with_options(
        device: *mut idevice_t,
        udid: *const ::std::os::raw::c_char,
        options: idevice_options,
    ) -> idevice_error_t;
}
extern "C" {
    #[doc = " Cleans up an idevice structure, then frees the structure itself."]
    #[doc = ""]
    #[doc = " @param device idevice_t to free."]
    pub fn idevice_free(device: idevice_t) -> idevice_error_t;
}
extern "C" {
    #[doc = " Set up a connection to the given device."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param port The destination port to connect to."]
    #[doc = " @param connection Pointer to an idevice_connection_t that will be filled"]
    #[doc = "   with the necessary data of the connection."]
    #[doc = ""]
    #[doc = " @return IDEVICE_E_SUCCESS if ok, otherwise an error code."]
    pub fn idevice_connect(
        device: idevice_t,
        port: u16,
        connection: *mut idevice_connection_t,
    ) -> idevice_error_t;
}
extern "C" {
    #[doc = " Disconnect from the device and clean up the connection structure."]
    #[doc = ""]
    #[doc = " @param connection The connection to close."]
    #[doc = ""]
    #[doc = " @return IDEVICE_E_SUCCESS if ok, otherwise an error code."]
    pub fn idevice_disconnect(connection: idevice_connection_t) -> idevice_error_t;
}
extern "C" {
    #[doc = " Send data to a device via the given connection."]
    #[doc = ""]
    #[doc = " @param connection The connection to send data over."]
    #[doc = " @param data Buffer with data to send."]
    #[doc = " @param len Size of the buffer to send."]
    #[doc = " @param sent_bytes Pointer to an uint32_t that will be filled"]
    #[doc = "   with the number of bytes actually sent."]
    #[doc = ""]
    #[doc = " @return IDEVICE_E_SUCCESS if ok, otherwise an error code."]
    pub fn idevice_connection_send(
        connection: idevice_connection_t,
        data: *const ::std::os::raw::c_char,
        len: u32,
        sent_bytes: *mut u32,
    ) -> idevice_error_t;
}
extern "C" {
    #[doc = " Receive data from a device via the given connection."]
    #[doc = " This function will return after the given timeout even if no data has been"]
    #[doc = " received."]
    #[doc = ""]
    #[doc = " @param connection The connection to receive data from."]
    #[doc = " @param data Buffer that will be filled with the received data."]
    #[doc = "   This buffer has to be large enough to hold len bytes."]
    #[doc = " @param len Buffer size or number of bytes to receive."]
    #[doc = " @param recv_bytes Number of bytes actually received."]
    #[doc = " @param timeout Timeout in milliseconds after which this function should"]
    #[doc = "   return even if no data has been received."]
    #[doc = ""]
    #[doc = " @return IDEVICE_E_SUCCESS if ok, otherwise an error code."]
    pub fn idevice_connection_receive_timeout(
        connection: idevice_connection_t,
        data: *mut ::std::os::raw::c_char,
        len: u32,
        recv_bytes: *mut u32,
        timeout: ::std::os::raw::c_uint,
    ) -> idevice_error_t;
}
extern "C" {
    #[doc = " Receive data from a device via the given connection."]
    #[doc = " This function is like idevice_connection_receive_timeout, but with a"]
    #[doc = " predefined reasonable timeout."]
    #[doc = ""]
    #[doc = " @param connection The connection to receive data from."]
    #[doc = " @param data Buffer that will be filled with the received data."]
    #[doc = "   This buffer has to be large enough to hold len bytes."]
    #[doc = " @param len Buffer size or number of bytes to receive."]
    #[doc = " @param recv_bytes Number of bytes actually received."]
    #[doc = ""]
    #[doc = " @return IDEVICE_E_SUCCESS if ok, otherwise an error code."]
    pub fn idevice_connection_receive(
        connection: idevice_connection_t,
        data: *mut ::std::os::raw::c_char,
        len: u32,
        recv_bytes: *mut u32,
    ) -> idevice_error_t;
}
extern "C" {
    #[doc = " Enables SSL for the given connection."]
    #[doc = ""]
    #[doc = " @param connection The connection to enable SSL for."]
    #[doc = ""]
    #[doc = " @return IDEVICE_E_SUCCESS on success, IDEVICE_E_INVALID_ARG when connection"]
    #[doc = "     is NULL or connection->ssl_data is non-NULL, or IDEVICE_E_SSL_ERROR when"]
    #[doc = "     SSL initialization, setup, or handshake fails."]
    pub fn idevice_connection_enable_ssl(connection: idevice_connection_t) -> idevice_error_t;
}
extern "C" {
    #[doc = " Disable SSL for the given connection."]
    #[doc = ""]
    #[doc = " @param connection The connection to disable SSL for."]
    #[doc = ""]
    #[doc = " @return IDEVICE_E_SUCCESS on success, IDEVICE_E_INVALID_ARG when connection"]
    #[doc = "     is NULL. This function also returns IDEVICE_E_SUCCESS when SSL is not"]
    #[doc = "     enabled and does no further error checking on cleanup."]
    pub fn idevice_connection_disable_ssl(connection: idevice_connection_t) -> idevice_error_t;
}
extern "C" {
    #[doc = " Disable bypass SSL for the given connection without sending out terminate messages."]
    #[doc = ""]
    #[doc = " @param connection The connection to disable SSL for."]
    #[doc = " @param sslBypass  if true ssl connection will not be terminated but just cleaned up, allowing"]
    #[doc = "                   plain text data going on underlying connection"]
    #[doc = ""]
    #[doc = " @return IDEVICE_E_SUCCESS on success, IDEVICE_E_INVALID_ARG when connection"]
    #[doc = "     is NULL. This function also returns IDEVICE_E_SUCCESS when SSL is not"]
    #[doc = "     enabled and does no further error checking on cleanup."]
    pub fn idevice_connection_disable_bypass_ssl(
        connection: idevice_connection_t,
        sslBypass: u8,
    ) -> idevice_error_t;
}
extern "C" {
    #[doc = " Get the underlying file descriptor for a connection"]
    #[doc = ""]
    #[doc = " @param connection The connection to get fd of"]
    #[doc = " @param fd Pointer to an int where the fd is stored"]
    #[doc = ""]
    #[doc = " @return IDEVICE_E_SUCCESS if ok, otherwise an error code."]
    pub fn idevice_connection_get_fd(
        connection: idevice_connection_t,
        fd: *mut ::std::os::raw::c_int,
    ) -> idevice_error_t;
}
extern "C" {
    #[doc = " Gets the handle or (usbmux device id) of the device."]
    pub fn idevice_get_handle(device: idevice_t, handle: *mut u32) -> idevice_error_t;
}
extern "C" {
    #[doc = " Gets the unique id for the device."]
    pub fn idevice_get_udid(
        device: idevice_t,
        udid: *mut *mut ::std::os::raw::c_char,
    ) -> idevice_error_t;
}
pub const lockdownd_error_t_LOCKDOWN_E_SUCCESS: lockdownd_error_t = 0;
pub const lockdownd_error_t_LOCKDOWN_E_INVALID_ARG: lockdownd_error_t = -1;
pub const lockdownd_error_t_LOCKDOWN_E_INVALID_CONF: lockdownd_error_t = -2;
pub const lockdownd_error_t_LOCKDOWN_E_PLIST_ERROR: lockdownd_error_t = -3;
pub const lockdownd_error_t_LOCKDOWN_E_PAIRING_FAILED: lockdownd_error_t = -4;
pub const lockdownd_error_t_LOCKDOWN_E_SSL_ERROR: lockdownd_error_t = -5;
pub const lockdownd_error_t_LOCKDOWN_E_DICT_ERROR: lockdownd_error_t = -6;
pub const lockdownd_error_t_LOCKDOWN_E_RECEIVE_TIMEOUT: lockdownd_error_t = -7;
pub const lockdownd_error_t_LOCKDOWN_E_MUX_ERROR: lockdownd_error_t = -8;
pub const lockdownd_error_t_LOCKDOWN_E_NO_RUNNING_SESSION: lockdownd_error_t = -9;
pub const lockdownd_error_t_LOCKDOWN_E_INVALID_RESPONSE: lockdownd_error_t = -10;
pub const lockdownd_error_t_LOCKDOWN_E_MISSING_KEY: lockdownd_error_t = -11;
pub const lockdownd_error_t_LOCKDOWN_E_MISSING_VALUE: lockdownd_error_t = -12;
pub const lockdownd_error_t_LOCKDOWN_E_GET_PROHIBITED: lockdownd_error_t = -13;
pub const lockdownd_error_t_LOCKDOWN_E_SET_PROHIBITED: lockdownd_error_t = -14;
pub const lockdownd_error_t_LOCKDOWN_E_REMOVE_PROHIBITED: lockdownd_error_t = -15;
pub const lockdownd_error_t_LOCKDOWN_E_IMMUTABLE_VALUE: lockdownd_error_t = -16;
pub const lockdownd_error_t_LOCKDOWN_E_PASSWORD_PROTECTED: lockdownd_error_t = -17;
pub const lockdownd_error_t_LOCKDOWN_E_USER_DENIED_PAIRING: lockdownd_error_t = -18;
pub const lockdownd_error_t_LOCKDOWN_E_PAIRING_DIALOG_RESPONSE_PENDING: lockdownd_error_t = -19;
pub const lockdownd_error_t_LOCKDOWN_E_MISSING_HOST_ID: lockdownd_error_t = -20;
pub const lockdownd_error_t_LOCKDOWN_E_INVALID_HOST_ID: lockdownd_error_t = -21;
pub const lockdownd_error_t_LOCKDOWN_E_SESSION_ACTIVE: lockdownd_error_t = -22;
pub const lockdownd_error_t_LOCKDOWN_E_SESSION_INACTIVE: lockdownd_error_t = -23;
pub const lockdownd_error_t_LOCKDOWN_E_MISSING_SESSION_ID: lockdownd_error_t = -24;
pub const lockdownd_error_t_LOCKDOWN_E_INVALID_SESSION_ID: lockdownd_error_t = -25;
pub const lockdownd_error_t_LOCKDOWN_E_MISSING_SERVICE: lockdownd_error_t = -26;
pub const lockdownd_error_t_LOCKDOWN_E_INVALID_SERVICE: lockdownd_error_t = -27;
pub const lockdownd_error_t_LOCKDOWN_E_SERVICE_LIMIT: lockdownd_error_t = -28;
pub const lockdownd_error_t_LOCKDOWN_E_MISSING_PAIR_RECORD: lockdownd_error_t = -29;
pub const lockdownd_error_t_LOCKDOWN_E_SAVE_PAIR_RECORD_FAILED: lockdownd_error_t = -30;
pub const lockdownd_error_t_LOCKDOWN_E_INVALID_PAIR_RECORD: lockdownd_error_t = -31;
pub const lockdownd_error_t_LOCKDOWN_E_INVALID_ACTIVATION_RECORD: lockdownd_error_t = -32;
pub const lockdownd_error_t_LOCKDOWN_E_MISSING_ACTIVATION_RECORD: lockdownd_error_t = -33;
pub const lockdownd_error_t_LOCKDOWN_E_SERVICE_PROHIBITED: lockdownd_error_t = -34;
pub const lockdownd_error_t_LOCKDOWN_E_ESCROW_LOCKED: lockdownd_error_t = -35;
pub const lockdownd_error_t_LOCKDOWN_E_PAIRING_PROHIBITED_OVER_THIS_CONNECTION: lockdownd_error_t =
    -36;
pub const lockdownd_error_t_LOCKDOWN_E_FMIP_PROTECTED: lockdownd_error_t = -37;
pub const lockdownd_error_t_LOCKDOWN_E_MC_PROTECTED: lockdownd_error_t = -38;
pub const lockdownd_error_t_LOCKDOWN_E_MC_CHALLENGE_REQUIRED: lockdownd_error_t = -39;
pub const lockdownd_error_t_LOCKDOWN_E_UNKNOWN_ERROR: lockdownd_error_t = -256;
#[doc = " Error Codes"]
pub type lockdownd_error_t = ::std::os::raw::c_int;
pub type lockdownd_client_t = *mut lockdownd_client_private;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lockdownd_pair_record {
    #[doc = "< The device certificate"]
    pub device_certificate: *mut ::std::os::raw::c_char,
    #[doc = "< The host certificate"]
    pub host_certificate: *mut ::std::os::raw::c_char,
    #[doc = "< The root certificate"]
    pub root_certificate: *mut ::std::os::raw::c_char,
    #[doc = "< A unique HostID for the host computer"]
    pub host_id: *mut ::std::os::raw::c_char,
    #[doc = "< A unique system id"]
    pub system_buid: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_lockdownd_pair_record() {
    assert_eq!(
        ::std::mem::size_of::<lockdownd_pair_record>(),
        40usize,
        concat!("Size of: ", stringify!(lockdownd_pair_record))
    );
    assert_eq!(
        ::std::mem::align_of::<lockdownd_pair_record>(),
        8usize,
        concat!("Alignment of ", stringify!(lockdownd_pair_record))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lockdownd_pair_record>())).device_certificate as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_pair_record),
            "::",
            stringify!(device_certificate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lockdownd_pair_record>())).host_certificate as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_pair_record),
            "::",
            stringify!(host_certificate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lockdownd_pair_record>())).root_certificate as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_pair_record),
            "::",
            stringify!(root_certificate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lockdownd_pair_record>())).host_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_pair_record),
            "::",
            stringify!(host_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lockdownd_pair_record>())).system_buid as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_pair_record),
            "::",
            stringify!(system_buid)
        )
    );
}
#[doc = " A pair record holding device, host and root certificates along the host_id"]
pub type lockdownd_pair_record_t = *mut lockdownd_pair_record;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lockdownd_service_descriptor {
    pub port: u16,
    pub ssl_enabled: u8,
    pub identifier: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_lockdownd_service_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<lockdownd_service_descriptor>(),
        16usize,
        concat!("Size of: ", stringify!(lockdownd_service_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<lockdownd_service_descriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(lockdownd_service_descriptor))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lockdownd_service_descriptor>())).port as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_service_descriptor),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lockdownd_service_descriptor>())).ssl_enabled as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_service_descriptor),
            "::",
            stringify!(ssl_enabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lockdownd_service_descriptor>())).identifier as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_service_descriptor),
            "::",
            stringify!(identifier)
        )
    );
}
pub type lockdownd_service_descriptor_t = *mut lockdownd_service_descriptor;
extern "C" {
    #[doc = " Creates a new lockdownd client for the device."]
    #[doc = ""]
    #[doc = " @note This function does not pair with the device or start a session. This"]
    #[doc = "  has to be done manually by the caller after the client is created."]
    #[doc = "  The device disconnects automatically if the lockdown connection idles"]
    #[doc = "  for more than 10 seconds. Make sure to call lockdownd_client_free() as soon"]
    #[doc = "  as the connection is no longer needed."]
    #[doc = ""]
    #[doc = " @param device The device to create a lockdownd client for"]
    #[doc = " @param client The pointer to the location of the new lockdownd_client"]
    #[doc = " @param label The label to use for communication. Usually the program name."]
    #[doc = ""]
    #[doc = " @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client is NULL"]
    pub fn lockdownd_client_new(
        device: idevice_t,
        client: *mut lockdownd_client_t,
        label: *const ::std::os::raw::c_char,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Creates a new lockdownd client for the device and starts initial handshake."]
    #[doc = " The handshake consists out of query_type, validate_pair, pair and"]
    #[doc = " start_session calls. It uses the internal pairing record management."]
    #[doc = ""]
    #[doc = " @note The device disconnects automatically if the lockdown connection idles"]
    #[doc = "  for more than 10 seconds. Make sure to call lockdownd_client_free() as soon"]
    #[doc = "  as the connection is no longer needed."]
    #[doc = ""]
    #[doc = " @param device The device to create a lockdownd client for"]
    #[doc = " @param client The pointer to the location of the new lockdownd_client"]
    #[doc = " @param label The label to use for communication. Usually the program name."]
    #[doc = "  Pass NULL to disable sending the label in requests to lockdownd."]
    #[doc = ""]
    #[doc = " @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client is NULL,"]
    #[doc = "  LOCKDOWN_E_INVALID_CONF if configuration data is wrong"]
    pub fn lockdownd_client_new_with_handshake(
        device: idevice_t,
        client: *mut lockdownd_client_t,
        label: *const ::std::os::raw::c_char,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Closes the lockdownd client session if one is running and frees up the"]
    #[doc = " lockdownd_client struct."]
    #[doc = ""]
    #[doc = " @param client The lockdown client"]
    #[doc = ""]
    #[doc = " @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client is NULL"]
    pub fn lockdownd_client_free(client: lockdownd_client_t) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Query the type of the service daemon. Depending on whether the device is"]
    #[doc = " queried in normal mode or restore mode, different types will be returned."]
    #[doc = ""]
    #[doc = " @param client The lockdownd client"]
    #[doc = " @param type The type returned by the service daemon. Pass NULL to ignore."]
    #[doc = ""]
    #[doc = " @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client is NULL"]
    pub fn lockdownd_query_type(
        client: lockdownd_client_t,
        type_: *mut *mut ::std::os::raw::c_char,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Retrieves a preferences plist using an optional domain and/or key name."]
    #[doc = ""]
    #[doc = " @param client An initialized lockdownd client."]
    #[doc = " @param domain The domain to query on or NULL for global domain"]
    #[doc = " @param key The key name to request or NULL to query for all keys"]
    #[doc = " @param value A plist node representing the result value node"]
    #[doc = ""]
    #[doc = " @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client is NULL"]
    pub fn lockdownd_get_value(
        client: lockdownd_client_t,
        domain: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
        value: *mut plist_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Sets a preferences value using a plist and optional by domain and/or key name."]
    #[doc = ""]
    #[doc = " @param client an initialized lockdownd client."]
    #[doc = " @param domain the domain to query on or NULL for global domain"]
    #[doc = " @param key the key name to set the value or NULL to set a value dict plist"]
    #[doc = " @param value a plist node of any node type representing the value to set"]
    #[doc = ""]
    #[doc = " @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client or"]
    #[doc = "  value is NULL"]
    pub fn lockdownd_set_value(
        client: lockdownd_client_t,
        domain: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
        value: plist_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Removes a preference node by domain and/or key name."]
    #[doc = ""]
    #[doc = " @note: Use with caution as this could remove vital information on the device"]
    #[doc = ""]
    #[doc = " @param client An initialized lockdownd client."]
    #[doc = " @param domain The domain to query on or NULL for global domain"]
    #[doc = " @param key The key name to remove or NULL remove all keys for the current domain"]
    #[doc = ""]
    #[doc = " @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client is NULL"]
    pub fn lockdownd_remove_value(
        client: lockdownd_client_t,
        domain: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Requests to start a service and retrieve it's port on success."]
    #[doc = ""]
    #[doc = " @param client The lockdownd client"]
    #[doc = " @param identifier The identifier of the service to start"]
    #[doc = " @param service The service descriptor on success or NULL on failure"]
    #[doc = ""]
    #[doc = " @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG if a parameter"]
    #[doc = "  is NULL, LOCKDOWN_E_INVALID_SERVICE if the requested service is not known"]
    #[doc = "  by the device, LOCKDOWN_E_START_SERVICE_FAILED if the service could not be"]
    #[doc = "  started by the device"]
    pub fn lockdownd_start_service(
        client: lockdownd_client_t,
        identifier: *const ::std::os::raw::c_char,
        service: *mut lockdownd_service_descriptor_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Requests to start a service and retrieve it's port on success."]
    #[doc = " Sends the escrow bag from the device's pair record."]
    #[doc = ""]
    #[doc = " @param client The lockdownd client"]
    #[doc = " @param identifier The identifier of the service to start"]
    #[doc = " @param service The service descriptor on success or NULL on failure"]
    #[doc = ""]
    #[doc = " @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG if a parameter"]
    #[doc = "  is NULL, LOCKDOWN_E_INVALID_SERVICE if the requested service is not known"]
    #[doc = "  by the device, LOCKDOWN_E_START_SERVICE_FAILED if the service could not because"]
    #[doc = "  started by the device, LOCKDOWN_E_INVALID_CONF if the host id or escrow bag are"]
    #[doc = "  missing from the device record."]
    pub fn lockdownd_start_service_with_escrow_bag(
        client: lockdownd_client_t,
        identifier: *const ::std::os::raw::c_char,
        service: *mut lockdownd_service_descriptor_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Opens a session with lockdownd and switches to SSL mode if device wants it."]
    #[doc = ""]
    #[doc = " @param client The lockdownd client"]
    #[doc = " @param host_id The HostID of the computer"]
    #[doc = " @param session_id The new session_id of the created session"]
    #[doc = " @param ssl_enabled Whether SSL communication is used in the session"]
    #[doc = ""]
    #[doc = " @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when a client"]
    #[doc = "  or host_id is NULL, LOCKDOWN_E_PLIST_ERROR if the response plist had errors,"]
    #[doc = "  LOCKDOWN_E_INVALID_HOST_ID if the device does not know the supplied HostID,"]
    #[doc = "  LOCKDOWN_E_SSL_ERROR if enabling SSL communication failed"]
    pub fn lockdownd_start_session(
        client: lockdownd_client_t,
        host_id: *const ::std::os::raw::c_char,
        session_id: *mut *mut ::std::os::raw::c_char,
        ssl_enabled: *mut ::std::os::raw::c_int,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Closes the lockdownd session by sending the StopSession request."]
    #[doc = ""]
    #[doc = " @see lockdownd_start_session"]
    #[doc = ""]
    #[doc = " @param client The lockdown client"]
    #[doc = " @param session_id The id of a running session"]
    #[doc = ""]
    #[doc = " @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client is NULL"]
    pub fn lockdownd_stop_session(
        client: lockdownd_client_t,
        session_id: *const ::std::os::raw::c_char,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Sends a plist to lockdownd."]
    #[doc = ""]
    #[doc = " @note This function is low-level and should only be used if you need to send"]
    #[doc = "        a new type of message."]
    #[doc = ""]
    #[doc = " @param client The lockdownd client"]
    #[doc = " @param plist The plist to send"]
    #[doc = ""]
    #[doc = " @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client or"]
    #[doc = "  plist is NULL"]
    pub fn lockdownd_send(client: lockdownd_client_t, plist: plist_t) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Receives a plist from lockdownd."]
    #[doc = ""]
    #[doc = " @param client The lockdownd client"]
    #[doc = " @param plist The plist to store the received data"]
    #[doc = ""]
    #[doc = " @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client or"]
    #[doc = "  plist is NULL"]
    pub fn lockdownd_receive(client: lockdownd_client_t, plist: *mut plist_t) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Pairs the device using the supplied pair record."]
    #[doc = ""]
    #[doc = " @param client The lockdown client"]
    #[doc = " @param pair_record The pair record to use for pairing. If NULL is passed, then"]
    #[doc = "    the pair records from the current machine are used. New records will be"]
    #[doc = "    generated automatically when pairing is done for the first time."]
    #[doc = ""]
    #[doc = " @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client is NULL,"]
    #[doc = "  LOCKDOWN_E_PLIST_ERROR if the pair_record certificates are wrong,"]
    #[doc = "  LOCKDOWN_E_PAIRING_FAILED if the pairing failed,"]
    #[doc = "  LOCKDOWN_E_PASSWORD_PROTECTED if the device is password protected,"]
    #[doc = "  LOCKDOWN_E_INVALID_HOST_ID if the device does not know the caller's host id"]
    pub fn lockdownd_pair(
        client: lockdownd_client_t,
        pair_record: lockdownd_pair_record_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Pairs the device using the supplied pair record and passing the given options."]
    #[doc = ""]
    #[doc = " @param client The lockdown client"]
    #[doc = " @param pair_record The pair record to use for pairing. If NULL is passed, then"]
    #[doc = "    the pair records from the current machine are used. New records will be"]
    #[doc = "    generated automatically when pairing is done for the first time."]
    #[doc = " @param options The pairing options to pass. Can be NULL for no options."]
    #[doc = " @param response If non-NULL a pointer to lockdownd's response dictionary is returned."]
    #[doc = "    The caller is responsible to free the response dictionary with plist_free()."]
    #[doc = ""]
    #[doc = " @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client is NULL,"]
    #[doc = "  LOCKDOWN_E_PLIST_ERROR if the pair_record certificates are wrong,"]
    #[doc = "  LOCKDOWN_E_PAIRING_FAILED if the pairing failed,"]
    #[doc = "  LOCKDOWN_E_PASSWORD_PROTECTED if the device is password protected,"]
    #[doc = "  LOCKDOWN_E_INVALID_HOST_ID if the device does not know the caller's host id"]
    pub fn lockdownd_pair_with_options(
        client: lockdownd_client_t,
        pair_record: lockdownd_pair_record_t,
        options: plist_t,
        response: *mut plist_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Validates if the device is paired with the given HostID. If successful the"]
    #[doc = " specified host will become trusted host of the device indicated by the"]
    #[doc = " lockdownd preference named TrustedHostAttached. Otherwise the host must be"]
    #[doc = " paired using lockdownd_pair() first."]
    #[doc = ""]
    #[doc = " @param client The lockdown client"]
    #[doc = " @param pair_record The pair record to validate pairing with. If NULL is"]
    #[doc = "    passed, then the pair record is read from the internal pairing record"]
    #[doc = "    management."]
    #[doc = ""]
    #[doc = " @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client is NULL,"]
    #[doc = "  LOCKDOWN_E_PLIST_ERROR if the pair_record certificates are wrong,"]
    #[doc = "  LOCKDOWN_E_PAIRING_FAILED if the pairing failed,"]
    #[doc = "  LOCKDOWN_E_PASSWORD_PROTECTED if the device is password protected,"]
    #[doc = "  LOCKDOWN_E_INVALID_HOST_ID if the device does not know the caller's host id"]
    pub fn lockdownd_validate_pair(
        client: lockdownd_client_t,
        pair_record: lockdownd_pair_record_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Unpairs the device with the given HostID and removes the pairing records"]
    #[doc = " from the device and host if the internal pairing record management is used."]
    #[doc = ""]
    #[doc = " @param client The lockdown client"]
    #[doc = " @param pair_record The pair record to use for unpair. If NULL is passed, then"]
    #[doc = "    the pair records from the current machine are used."]
    #[doc = ""]
    #[doc = " @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client is NULL,"]
    #[doc = "  LOCKDOWN_E_PLIST_ERROR if the pair_record certificates are wrong,"]
    #[doc = "  LOCKDOWN_E_PAIRING_FAILED if the pairing failed,"]
    #[doc = "  LOCKDOWN_E_PASSWORD_PROTECTED if the device is password protected,"]
    #[doc = "  LOCKDOWN_E_INVALID_HOST_ID if the device does not know the caller's host id"]
    pub fn lockdownd_unpair(
        client: lockdownd_client_t,
        pair_record: lockdownd_pair_record_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Activates the device. Only works within an open session."]
    #[doc = " The ActivationRecord plist dictionary must be obtained using the"]
    #[doc = " activation protocol requesting from Apple's https webservice."]
    #[doc = ""]
    #[doc = " @param client The lockdown client"]
    #[doc = " @param activation_record The activation record plist dictionary"]
    #[doc = ""]
    #[doc = " @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client or"]
    #[doc = "  activation_record is NULL, LOCKDOWN_E_NO_RUNNING_SESSION if no session is"]
    #[doc = "  open, LOCKDOWN_E_PLIST_ERROR if the received plist is broken,"]
    #[doc = "  LOCKDOWN_E_ACTIVATION_FAILED if the activation failed,"]
    #[doc = "  LOCKDOWN_E_INVALID_ACTIVATION_RECORD if the device reports that the"]
    #[doc = "  activation_record is invalid"]
    pub fn lockdownd_activate(
        client: lockdownd_client_t,
        activation_record: plist_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Deactivates the device, returning it to the locked Activate with iTunes"]
    #[doc = " screen."]
    #[doc = ""]
    #[doc = " @param client The lockdown client"]
    #[doc = ""]
    #[doc = " @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client is NULL,"]
    #[doc = "  LOCKDOWN_E_NO_RUNNING_SESSION if no session is open,"]
    #[doc = "  LOCKDOWN_E_PLIST_ERROR if the received plist is broken"]
    pub fn lockdownd_deactivate(client: lockdownd_client_t) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Tells the device to immediately enter recovery mode."]
    #[doc = ""]
    #[doc = " @param client The lockdown client"]
    #[doc = ""]
    #[doc = " @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client is NULL"]
    pub fn lockdownd_enter_recovery(client: lockdownd_client_t) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Sends the Goodbye request to lockdownd signaling the end of communication."]
    #[doc = ""]
    #[doc = " @param client The lockdown client"]
    #[doc = ""]
    #[doc = " @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client"]
    #[doc = "  is NULL, LOCKDOWN_E_PLIST_ERROR if the device did not acknowledge the"]
    #[doc = "  request"]
    pub fn lockdownd_goodbye(client: lockdownd_client_t) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Sets the label to send for requests to lockdownd."]
    #[doc = ""]
    #[doc = " @param client The lockdown client"]
    #[doc = " @param label The label to set or NULL to disable sending a label"]
    #[doc = ""]
    pub fn lockdownd_client_set_label(
        client: lockdownd_client_t,
        label: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Returns the unique id of the device from lockdownd."]
    #[doc = ""]
    #[doc = " @param client An initialized lockdownd client."]
    #[doc = " @param udid Holds the unique id of the device. The caller is responsible"]
    #[doc = "  for freeing the memory."]
    #[doc = ""]
    #[doc = " @return LOCKDOWN_E_SUCCESS on success"]
    pub fn lockdownd_get_device_udid(
        client: lockdownd_client_t,
        udid: *mut *mut ::std::os::raw::c_char,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Retrieves the name of the device from lockdownd set by the user."]
    #[doc = ""]
    #[doc = " @param client An initialized lockdownd client."]
    #[doc = " @param device_name Holds the name of the device. The caller is"]
    #[doc = "  responsible for freeing the memory."]
    #[doc = ""]
    #[doc = " @return LOCKDOWN_E_SUCCESS on success"]
    pub fn lockdownd_get_device_name(
        client: lockdownd_client_t,
        device_name: *mut *mut ::std::os::raw::c_char,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Calculates and returns the data classes the device supports from lockdownd."]
    #[doc = ""]
    #[doc = " @param client An initialized lockdownd client."]
    #[doc = " @param classes A pointer to store an array of class names. The caller is responsible"]
    #[doc = "  for freeing the memory which can be done using mobilesync_data_classes_free()."]
    #[doc = " @param count The number of items in the classes array."]
    #[doc = ""]
    #[doc = " @return LOCKDOWN_E_SUCCESS on success,"]
    #[doc = "  LOCKDOWN_E_INVALID_ARG when client is NULL,"]
    #[doc = "  LOCKDOWN_E_NO_RUNNING_SESSION if no session is open,"]
    #[doc = "  LOCKDOWN_E_PLIST_ERROR if the received plist is broken"]
    pub fn lockdownd_get_sync_data_classes(
        client: lockdownd_client_t,
        classes: *mut *mut *mut ::std::os::raw::c_char,
        count: *mut ::std::os::raw::c_int,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Frees memory of an allocated array of data classes as returned by lockdownd_get_sync_data_classes()"]
    #[doc = ""]
    #[doc = " @param classes An array of class names to free."]
    #[doc = ""]
    #[doc = " @return LOCKDOWN_E_SUCCESS on success"]
    pub fn lockdownd_data_classes_free(
        classes: *mut *mut ::std::os::raw::c_char,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Frees memory of a service descriptor as returned by lockdownd_start_service()"]
    #[doc = ""]
    #[doc = " @param service A service descriptor instance to free."]
    #[doc = ""]
    #[doc = " @return LOCKDOWN_E_SUCCESS on success"]
    pub fn lockdownd_service_descriptor_free(
        service: lockdownd_service_descriptor_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Gets a readable error string for a given lockdown error code."]
    #[doc = ""]
    #[doc = " @params err A lockdownd error code"]
    #[doc = ""]
    #[doc = " @returns A readable error string"]
    pub fn lockdownd_strerror(err: lockdownd_error_t) -> *const ::std::os::raw::c_char;
}
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut getdate_err: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub fn asctime(arg1: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn ctime(arg1: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
extern "C" {
    pub fn getdate(arg1: *const ::std::os::raw::c_char) -> *mut tm;
}
extern "C" {
    pub fn gmtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn mktime(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn strptime(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn time(arg1: *mut time_t) -> time_t;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn asctime_r(
        arg1: *const tm,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        arg1: *const time_t,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn posix2time(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn tzsetwall();
}
extern "C" {
    pub fn time2posix(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn timelocal(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn timegm(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn nanosleep(__rqtp: *const timespec, __rmtp: *mut timespec) -> ::std::os::raw::c_int;
}
pub const clockid_t__CLOCK_REALTIME: clockid_t = 0;
pub const clockid_t__CLOCK_MONOTONIC: clockid_t = 6;
pub const clockid_t__CLOCK_MONOTONIC_RAW: clockid_t = 4;
pub const clockid_t__CLOCK_MONOTONIC_RAW_APPROX: clockid_t = 5;
pub const clockid_t__CLOCK_UPTIME_RAW: clockid_t = 8;
pub const clockid_t__CLOCK_UPTIME_RAW_APPROX: clockid_t = 9;
pub const clockid_t__CLOCK_PROCESS_CPUTIME_ID: clockid_t = 12;
pub const clockid_t__CLOCK_THREAD_CPUTIME_ID: clockid_t = 16;
pub type clockid_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime_nsec_np(__clock_id: clockid_t) -> __uint64_t;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(ts: *mut timespec, base: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_UNKNOWN: gnutls_cipher_algorithm = 0;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_NULL: gnutls_cipher_algorithm = 1;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_ARCFOUR_128: gnutls_cipher_algorithm = 2;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_3DES_CBC: gnutls_cipher_algorithm = 3;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_128_CBC: gnutls_cipher_algorithm = 4;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_256_CBC: gnutls_cipher_algorithm = 5;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_ARCFOUR_40: gnutls_cipher_algorithm = 6;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_CAMELLIA_128_CBC: gnutls_cipher_algorithm = 7;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_CAMELLIA_256_CBC: gnutls_cipher_algorithm = 8;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_192_CBC: gnutls_cipher_algorithm = 9;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_128_GCM: gnutls_cipher_algorithm = 10;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_256_GCM: gnutls_cipher_algorithm = 11;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_CAMELLIA_192_CBC: gnutls_cipher_algorithm = 12;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_SALSA20_256: gnutls_cipher_algorithm = 13;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_ESTREAM_SALSA20_256: gnutls_cipher_algorithm = 14;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_CAMELLIA_128_GCM: gnutls_cipher_algorithm = 15;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_CAMELLIA_256_GCM: gnutls_cipher_algorithm = 16;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_RC2_40_CBC: gnutls_cipher_algorithm = 17;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_DES_CBC: gnutls_cipher_algorithm = 18;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_128_CCM: gnutls_cipher_algorithm = 19;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_256_CCM: gnutls_cipher_algorithm = 20;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_128_CCM_8: gnutls_cipher_algorithm = 21;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_256_CCM_8: gnutls_cipher_algorithm = 22;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_CHACHA20_POLY1305: gnutls_cipher_algorithm = 23;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_GOST28147_TC26Z_CFB: gnutls_cipher_algorithm = 24;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_GOST28147_CPA_CFB: gnutls_cipher_algorithm = 25;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_GOST28147_CPB_CFB: gnutls_cipher_algorithm = 26;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_GOST28147_CPC_CFB: gnutls_cipher_algorithm = 27;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_GOST28147_CPD_CFB: gnutls_cipher_algorithm = 28;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_128_CFB8: gnutls_cipher_algorithm = 29;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_192_CFB8: gnutls_cipher_algorithm = 30;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_256_CFB8: gnutls_cipher_algorithm = 31;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_128_XTS: gnutls_cipher_algorithm = 32;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_256_XTS: gnutls_cipher_algorithm = 33;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_GOST28147_TC26Z_CNT: gnutls_cipher_algorithm = 34;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_CHACHA20_64: gnutls_cipher_algorithm = 35;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_CHACHA20_32: gnutls_cipher_algorithm = 36;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_128_SIV: gnutls_cipher_algorithm = 37;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_256_SIV: gnutls_cipher_algorithm = 38;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_192_GCM: gnutls_cipher_algorithm = 39;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_IDEA_PGP_CFB: gnutls_cipher_algorithm = 200;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_3DES_PGP_CFB: gnutls_cipher_algorithm = 201;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_CAST5_PGP_CFB: gnutls_cipher_algorithm = 202;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_BLOWFISH_PGP_CFB: gnutls_cipher_algorithm = 203;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_SAFER_SK128_PGP_CFB: gnutls_cipher_algorithm = 204;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES128_PGP_CFB: gnutls_cipher_algorithm = 205;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES192_PGP_CFB: gnutls_cipher_algorithm = 206;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES256_PGP_CFB: gnutls_cipher_algorithm = 207;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_TWOFISH_PGP_CFB: gnutls_cipher_algorithm = 208;
#[doc = " gnutls_cipher_algorithm_t:"]
#[doc = " @GNUTLS_CIPHER_UNKNOWN: Value to identify an unknown/unsupported algorithm."]
#[doc = " @GNUTLS_CIPHER_NULL: The NULL (identity) encryption algorithm."]
#[doc = " @GNUTLS_CIPHER_ARCFOUR_128: ARCFOUR stream cipher with 128-bit keys."]
#[doc = " @GNUTLS_CIPHER_3DES_CBC: 3DES in CBC mode."]
#[doc = " @GNUTLS_CIPHER_AES_128_CBC: AES in CBC mode with 128-bit keys."]
#[doc = " @GNUTLS_CIPHER_AES_192_CBC: AES in CBC mode with 192-bit keys."]
#[doc = " @GNUTLS_CIPHER_AES_256_CBC: AES in CBC mode with 256-bit keys."]
#[doc = " @GNUTLS_CIPHER_AES_128_CFB8: AES in CFB8 mode with 128-bit keys."]
#[doc = " @GNUTLS_CIPHER_AES_192_CFB8: AES in CFB8 mode with 192-bit keys."]
#[doc = " @GNUTLS_CIPHER_AES_256_CFB8: AES in CFB8 mode with 256-bit keys."]
#[doc = " @GNUTLS_CIPHER_ARCFOUR_40: ARCFOUR stream cipher with 40-bit keys."]
#[doc = " @GNUTLS_CIPHER_CAMELLIA_128_CBC: Camellia in CBC mode with 128-bit keys."]
#[doc = " @GNUTLS_CIPHER_CAMELLIA_192_CBC: Camellia in CBC mode with 192-bit keys."]
#[doc = " @GNUTLS_CIPHER_CAMELLIA_256_CBC: Camellia in CBC mode with 256-bit keys."]
#[doc = " @GNUTLS_CIPHER_RC2_40_CBC: RC2 in CBC mode with 40-bit keys."]
#[doc = " @GNUTLS_CIPHER_DES_CBC: DES in CBC mode (56-bit keys)."]
#[doc = " @GNUTLS_CIPHER_AES_128_GCM: AES in GCM mode with 128-bit keys (AEAD)."]
#[doc = " @GNUTLS_CIPHER_AES_256_GCM: AES in GCM mode with 256-bit keys (AEAD)."]
#[doc = " @GNUTLS_CIPHER_AES_128_CCM: AES in CCM mode with 128-bit keys (AEAD)."]
#[doc = " @GNUTLS_CIPHER_AES_256_CCM: AES in CCM mode with 256-bit keys (AEAD)."]
#[doc = " @GNUTLS_CIPHER_AES_128_CCM_8: AES in CCM mode with 64-bit tag and 128-bit keys (AEAD)."]
#[doc = " @GNUTLS_CIPHER_AES_256_CCM_8: AES in CCM mode with 64-bit tag and 256-bit keys (AEAD)."]
#[doc = " @GNUTLS_CIPHER_CAMELLIA_128_GCM: CAMELLIA in GCM mode with 128-bit keys (AEAD)."]
#[doc = " @GNUTLS_CIPHER_CAMELLIA_256_GCM: CAMELLIA in GCM mode with 256-bit keys (AEAD)."]
#[doc = " @GNUTLS_CIPHER_SALSA20_256: Salsa20 with 256-bit keys."]
#[doc = " @GNUTLS_CIPHER_ESTREAM_SALSA20_256: Estream's Salsa20 variant with 256-bit keys."]
#[doc = " @GNUTLS_CIPHER_CHACHA20_32: Chacha20 cipher with 96-bit nonces and 32-bit block counters."]
#[doc = " @GNUTLS_CIPHER_CHACHA20_64: Chacha20 cipher with 64-bit nonces and 64-bit block counters."]
#[doc = " @GNUTLS_CIPHER_CHACHA20_POLY1305: The Chacha20 cipher with the Poly1305 authenticator (AEAD)."]
#[doc = " @GNUTLS_CIPHER_GOST28147_TC26Z_CFB: GOST 28147-89 (Magma) cipher in CFB mode with TC26 Z S-box."]
#[doc = " @GNUTLS_CIPHER_GOST28147_CPA_CFB: GOST 28147-89 (Magma) cipher in CFB mode with CryptoPro A S-box."]
#[doc = " @GNUTLS_CIPHER_GOST28147_CPB_CFB: GOST 28147-89 (Magma) cipher in CFB mode with CryptoPro B S-box."]
#[doc = " @GNUTLS_CIPHER_GOST28147_CPC_CFB: GOST 28147-89 (Magma) cipher in CFB mode with CryptoPro C S-box."]
#[doc = " @GNUTLS_CIPHER_GOST28147_CPD_CFB: GOST 28147-89 (Magma) cipher in CFB mode with CryptoPro D S-box."]
#[doc = " @GNUTLS_CIPHER_AES_128_XTS: AES in XTS mode with 128-bit key + 128bit tweak key."]
#[doc = " @GNUTLS_CIPHER_AES_256_XTS: AES in XTS mode with 256-bit key + 256bit tweak key."]
#[doc = "                             Note that the XTS ciphers are message oriented."]
#[doc = "                             The whole message needs to be provided with a single call, because"]
#[doc = "                             cipher-stealing requires to know where the message actually terminates"]
#[doc = "                             in order to be able to compute where the stealing occurs."]
#[doc = " @GNUTLS_CIPHER_GOST28147_TC26Z_CNT: GOST 28147-89 (Magma) cipher in CNT mode with TC26 Z S-box."]
#[doc = " @GNUTLS_CIPHER_IDEA_PGP_CFB: IDEA in CFB mode (placeholder - unsupported)."]
#[doc = " @GNUTLS_CIPHER_3DES_PGP_CFB: 3DES in CFB mode (placeholder - unsupported)."]
#[doc = " @GNUTLS_CIPHER_CAST5_PGP_CFB: CAST5 in CFB mode (placeholder - unsupported)."]
#[doc = " @GNUTLS_CIPHER_BLOWFISH_PGP_CFB: Blowfish in CFB mode (placeholder - unsupported)."]
#[doc = " @GNUTLS_CIPHER_SAFER_SK128_PGP_CFB: Safer-SK in CFB mode with 128-bit keys (placeholder - unsupported)."]
#[doc = " @GNUTLS_CIPHER_AES128_PGP_CFB: AES in CFB mode with 128-bit keys (placeholder - unsupported)."]
#[doc = " @GNUTLS_CIPHER_AES192_PGP_CFB: AES in CFB mode with 192-bit keys (placeholder - unsupported)."]
#[doc = " @GNUTLS_CIPHER_AES256_PGP_CFB: AES in CFB mode with 256-bit keys (placeholder - unsupported)."]
#[doc = " @GNUTLS_CIPHER_TWOFISH_PGP_CFB: Twofish in CFB mode (placeholder - unsupported)."]
#[doc = " @GNUTLS_CIPHER_AES_128_SIV: AES in SIV mode with 128-bit key."]
#[doc = " @GNUTLS_CIPHER_AES_256_SIV: AES in SIV mode with 256-bit key."]
#[doc = "                             Note that the SIV ciphers can only be used with"]
#[doc = "                             the AEAD interface, and the IV plays a role as"]
#[doc = "                             the authentication tag while it is prepended to"]
#[doc = "                             the cipher text."]
#[doc = " @GNUTLS_CIPHER_AES_192_GCM: AES in GCM mode with 192-bit keys (AEAD)."]
#[doc = ""]
#[doc = " Enumeration of different symmetric encryption algorithms."]
pub type gnutls_cipher_algorithm = ::std::os::raw::c_uint;
#[doc = " gnutls_cipher_algorithm_t:"]
#[doc = " @GNUTLS_CIPHER_UNKNOWN: Value to identify an unknown/unsupported algorithm."]
#[doc = " @GNUTLS_CIPHER_NULL: The NULL (identity) encryption algorithm."]
#[doc = " @GNUTLS_CIPHER_ARCFOUR_128: ARCFOUR stream cipher with 128-bit keys."]
#[doc = " @GNUTLS_CIPHER_3DES_CBC: 3DES in CBC mode."]
#[doc = " @GNUTLS_CIPHER_AES_128_CBC: AES in CBC mode with 128-bit keys."]
#[doc = " @GNUTLS_CIPHER_AES_192_CBC: AES in CBC mode with 192-bit keys."]
#[doc = " @GNUTLS_CIPHER_AES_256_CBC: AES in CBC mode with 256-bit keys."]
#[doc = " @GNUTLS_CIPHER_AES_128_CFB8: AES in CFB8 mode with 128-bit keys."]
#[doc = " @GNUTLS_CIPHER_AES_192_CFB8: AES in CFB8 mode with 192-bit keys."]
#[doc = " @GNUTLS_CIPHER_AES_256_CFB8: AES in CFB8 mode with 256-bit keys."]
#[doc = " @GNUTLS_CIPHER_ARCFOUR_40: ARCFOUR stream cipher with 40-bit keys."]
#[doc = " @GNUTLS_CIPHER_CAMELLIA_128_CBC: Camellia in CBC mode with 128-bit keys."]
#[doc = " @GNUTLS_CIPHER_CAMELLIA_192_CBC: Camellia in CBC mode with 192-bit keys."]
#[doc = " @GNUTLS_CIPHER_CAMELLIA_256_CBC: Camellia in CBC mode with 256-bit keys."]
#[doc = " @GNUTLS_CIPHER_RC2_40_CBC: RC2 in CBC mode with 40-bit keys."]
#[doc = " @GNUTLS_CIPHER_DES_CBC: DES in CBC mode (56-bit keys)."]
#[doc = " @GNUTLS_CIPHER_AES_128_GCM: AES in GCM mode with 128-bit keys (AEAD)."]
#[doc = " @GNUTLS_CIPHER_AES_256_GCM: AES in GCM mode with 256-bit keys (AEAD)."]
#[doc = " @GNUTLS_CIPHER_AES_128_CCM: AES in CCM mode with 128-bit keys (AEAD)."]
#[doc = " @GNUTLS_CIPHER_AES_256_CCM: AES in CCM mode with 256-bit keys (AEAD)."]
#[doc = " @GNUTLS_CIPHER_AES_128_CCM_8: AES in CCM mode with 64-bit tag and 128-bit keys (AEAD)."]
#[doc = " @GNUTLS_CIPHER_AES_256_CCM_8: AES in CCM mode with 64-bit tag and 256-bit keys (AEAD)."]
#[doc = " @GNUTLS_CIPHER_CAMELLIA_128_GCM: CAMELLIA in GCM mode with 128-bit keys (AEAD)."]
#[doc = " @GNUTLS_CIPHER_CAMELLIA_256_GCM: CAMELLIA in GCM mode with 256-bit keys (AEAD)."]
#[doc = " @GNUTLS_CIPHER_SALSA20_256: Salsa20 with 256-bit keys."]
#[doc = " @GNUTLS_CIPHER_ESTREAM_SALSA20_256: Estream's Salsa20 variant with 256-bit keys."]
#[doc = " @GNUTLS_CIPHER_CHACHA20_32: Chacha20 cipher with 96-bit nonces and 32-bit block counters."]
#[doc = " @GNUTLS_CIPHER_CHACHA20_64: Chacha20 cipher with 64-bit nonces and 64-bit block counters."]
#[doc = " @GNUTLS_CIPHER_CHACHA20_POLY1305: The Chacha20 cipher with the Poly1305 authenticator (AEAD)."]
#[doc = " @GNUTLS_CIPHER_GOST28147_TC26Z_CFB: GOST 28147-89 (Magma) cipher in CFB mode with TC26 Z S-box."]
#[doc = " @GNUTLS_CIPHER_GOST28147_CPA_CFB: GOST 28147-89 (Magma) cipher in CFB mode with CryptoPro A S-box."]
#[doc = " @GNUTLS_CIPHER_GOST28147_CPB_CFB: GOST 28147-89 (Magma) cipher in CFB mode with CryptoPro B S-box."]
#[doc = " @GNUTLS_CIPHER_GOST28147_CPC_CFB: GOST 28147-89 (Magma) cipher in CFB mode with CryptoPro C S-box."]
#[doc = " @GNUTLS_CIPHER_GOST28147_CPD_CFB: GOST 28147-89 (Magma) cipher in CFB mode with CryptoPro D S-box."]
#[doc = " @GNUTLS_CIPHER_AES_128_XTS: AES in XTS mode with 128-bit key + 128bit tweak key."]
#[doc = " @GNUTLS_CIPHER_AES_256_XTS: AES in XTS mode with 256-bit key + 256bit tweak key."]
#[doc = "                             Note that the XTS ciphers are message oriented."]
#[doc = "                             The whole message needs to be provided with a single call, because"]
#[doc = "                             cipher-stealing requires to know where the message actually terminates"]
#[doc = "                             in order to be able to compute where the stealing occurs."]
#[doc = " @GNUTLS_CIPHER_GOST28147_TC26Z_CNT: GOST 28147-89 (Magma) cipher in CNT mode with TC26 Z S-box."]
#[doc = " @GNUTLS_CIPHER_IDEA_PGP_CFB: IDEA in CFB mode (placeholder - unsupported)."]
#[doc = " @GNUTLS_CIPHER_3DES_PGP_CFB: 3DES in CFB mode (placeholder - unsupported)."]
#[doc = " @GNUTLS_CIPHER_CAST5_PGP_CFB: CAST5 in CFB mode (placeholder - unsupported)."]
#[doc = " @GNUTLS_CIPHER_BLOWFISH_PGP_CFB: Blowfish in CFB mode (placeholder - unsupported)."]
#[doc = " @GNUTLS_CIPHER_SAFER_SK128_PGP_CFB: Safer-SK in CFB mode with 128-bit keys (placeholder - unsupported)."]
#[doc = " @GNUTLS_CIPHER_AES128_PGP_CFB: AES in CFB mode with 128-bit keys (placeholder - unsupported)."]
#[doc = " @GNUTLS_CIPHER_AES192_PGP_CFB: AES in CFB mode with 192-bit keys (placeholder - unsupported)."]
#[doc = " @GNUTLS_CIPHER_AES256_PGP_CFB: AES in CFB mode with 256-bit keys (placeholder - unsupported)."]
#[doc = " @GNUTLS_CIPHER_TWOFISH_PGP_CFB: Twofish in CFB mode (placeholder - unsupported)."]
#[doc = " @GNUTLS_CIPHER_AES_128_SIV: AES in SIV mode with 128-bit key."]
#[doc = " @GNUTLS_CIPHER_AES_256_SIV: AES in SIV mode with 256-bit key."]
#[doc = "                             Note that the SIV ciphers can only be used with"]
#[doc = "                             the AEAD interface, and the IV plays a role as"]
#[doc = "                             the authentication tag while it is prepended to"]
#[doc = "                             the cipher text."]
#[doc = " @GNUTLS_CIPHER_AES_192_GCM: AES in GCM mode with 192-bit keys (AEAD)."]
#[doc = ""]
#[doc = " Enumeration of different symmetric encryption algorithms."]
pub use self::gnutls_cipher_algorithm as gnutls_cipher_algorithm_t;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_UNKNOWN: gnutls_kx_algorithm_t = 0;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_RSA: gnutls_kx_algorithm_t = 1;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_DHE_DSS: gnutls_kx_algorithm_t = 2;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_DHE_RSA: gnutls_kx_algorithm_t = 3;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_ANON_DH: gnutls_kx_algorithm_t = 4;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_SRP: gnutls_kx_algorithm_t = 5;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_RSA_EXPORT: gnutls_kx_algorithm_t = 6;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_SRP_RSA: gnutls_kx_algorithm_t = 7;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_SRP_DSS: gnutls_kx_algorithm_t = 8;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_PSK: gnutls_kx_algorithm_t = 9;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_DHE_PSK: gnutls_kx_algorithm_t = 10;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_ANON_ECDH: gnutls_kx_algorithm_t = 11;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_ECDHE_RSA: gnutls_kx_algorithm_t = 12;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_ECDHE_ECDSA: gnutls_kx_algorithm_t = 13;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_ECDHE_PSK: gnutls_kx_algorithm_t = 14;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_RSA_PSK: gnutls_kx_algorithm_t = 15;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_VKO_GOST_12: gnutls_kx_algorithm_t = 16;
#[doc = " gnutls_kx_algorithm_t:"]
#[doc = " @GNUTLS_KX_UNKNOWN: Unknown key-exchange algorithm."]
#[doc = " @GNUTLS_KX_RSA: RSA key-exchange algorithm."]
#[doc = " @GNUTLS_KX_DHE_DSS: DHE-DSS key-exchange algorithm."]
#[doc = " @GNUTLS_KX_DHE_RSA: DHE-RSA key-exchange algorithm."]
#[doc = " @GNUTLS_KX_ECDHE_RSA: ECDHE-RSA key-exchange algorithm."]
#[doc = " @GNUTLS_KX_ECDHE_ECDSA: ECDHE-ECDSA key-exchange algorithm."]
#[doc = " @GNUTLS_KX_ANON_DH: Anon-DH key-exchange algorithm."]
#[doc = " @GNUTLS_KX_ANON_ECDH: Anon-ECDH key-exchange algorithm."]
#[doc = " @GNUTLS_KX_SRP: SRP key-exchange algorithm."]
#[doc = " @GNUTLS_KX_RSA_EXPORT: RSA-EXPORT key-exchange algorithm (defunc)."]
#[doc = " @GNUTLS_KX_SRP_RSA: SRP-RSA key-exchange algorithm."]
#[doc = " @GNUTLS_KX_SRP_DSS: SRP-DSS key-exchange algorithm."]
#[doc = " @GNUTLS_KX_PSK: PSK key-exchange algorithm."]
#[doc = " @GNUTLS_KX_DHE_PSK: DHE-PSK key-exchange algorithm."]
#[doc = " @GNUTLS_KX_ECDHE_PSK: ECDHE-PSK key-exchange algorithm."]
#[doc = " @GNUTLS_KX_RSA_PSK: RSA-PSK key-exchange algorithm."]
#[doc = " @GNUTLS_KX_VKO_GOST_12: VKO GOST R 34.10-2012 key-exchange algorithm."]
#[doc = ""]
#[doc = " Enumeration of different key exchange algorithms."]
pub type gnutls_kx_algorithm_t = ::std::os::raw::c_uint;
pub const gnutls_params_type_t_GNUTLS_PARAMS_RSA_EXPORT: gnutls_params_type_t = 1;
pub const gnutls_params_type_t_GNUTLS_PARAMS_DH: gnutls_params_type_t = 2;
pub const gnutls_params_type_t_GNUTLS_PARAMS_ECDH: gnutls_params_type_t = 3;
#[doc = " gnutls_params_type_t:"]
#[doc = " @GNUTLS_PARAMS_RSA_EXPORT: Session RSA-EXPORT parameters (defunc)."]
#[doc = " @GNUTLS_PARAMS_DH: Session Diffie-Hellman parameters."]
#[doc = " @GNUTLS_PARAMS_ECDH: Session Elliptic-Curve Diffie-Hellman parameters."]
#[doc = ""]
#[doc = " Enumeration of different TLS session parameter types."]
pub type gnutls_params_type_t = ::std::os::raw::c_uint;
pub const gnutls_credentials_type_t_GNUTLS_CRD_CERTIFICATE: gnutls_credentials_type_t = 1;
pub const gnutls_credentials_type_t_GNUTLS_CRD_ANON: gnutls_credentials_type_t = 2;
pub const gnutls_credentials_type_t_GNUTLS_CRD_SRP: gnutls_credentials_type_t = 3;
pub const gnutls_credentials_type_t_GNUTLS_CRD_PSK: gnutls_credentials_type_t = 4;
pub const gnutls_credentials_type_t_GNUTLS_CRD_IA: gnutls_credentials_type_t = 5;
#[doc = " gnutls_credentials_type_t:"]
#[doc = " @GNUTLS_CRD_CERTIFICATE: Certificate credential."]
#[doc = " @GNUTLS_CRD_ANON: Anonymous credential."]
#[doc = " @GNUTLS_CRD_SRP: SRP credential."]
#[doc = " @GNUTLS_CRD_PSK: PSK credential."]
#[doc = " @GNUTLS_CRD_IA: IA credential."]
#[doc = ""]
#[doc = " Enumeration of different credential types."]
pub type gnutls_credentials_type_t = ::std::os::raw::c_uint;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_UNKNOWN: gnutls_mac_algorithm_t = 0;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_NULL: gnutls_mac_algorithm_t = 1;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_MD5: gnutls_mac_algorithm_t = 2;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_SHA1: gnutls_mac_algorithm_t = 3;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_RMD160: gnutls_mac_algorithm_t = 4;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_MD2: gnutls_mac_algorithm_t = 5;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_SHA256: gnutls_mac_algorithm_t = 6;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_SHA384: gnutls_mac_algorithm_t = 7;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_SHA512: gnutls_mac_algorithm_t = 8;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_SHA224: gnutls_mac_algorithm_t = 9;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_SHA3_224: gnutls_mac_algorithm_t = 10;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_SHA3_256: gnutls_mac_algorithm_t = 11;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_SHA3_384: gnutls_mac_algorithm_t = 12;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_SHA3_512: gnutls_mac_algorithm_t = 13;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_MD5_SHA1: gnutls_mac_algorithm_t = 14;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_GOSTR_94: gnutls_mac_algorithm_t = 15;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_STREEBOG_256: gnutls_mac_algorithm_t = 16;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_STREEBOG_512: gnutls_mac_algorithm_t = 17;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_AEAD: gnutls_mac_algorithm_t = 200;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_UMAC_96: gnutls_mac_algorithm_t = 201;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_UMAC_128: gnutls_mac_algorithm_t = 202;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_AES_CMAC_128: gnutls_mac_algorithm_t = 203;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_AES_CMAC_256: gnutls_mac_algorithm_t = 204;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_AES_GMAC_128: gnutls_mac_algorithm_t = 205;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_AES_GMAC_192: gnutls_mac_algorithm_t = 206;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_AES_GMAC_256: gnutls_mac_algorithm_t = 207;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_GOST28147_TC26Z_IMIT: gnutls_mac_algorithm_t = 208;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_SHAKE_128: gnutls_mac_algorithm_t = 209;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_SHAKE_256: gnutls_mac_algorithm_t = 210;
#[doc = " gnutls_mac_algorithm_t:"]
#[doc = " @GNUTLS_MAC_UNKNOWN: Unknown MAC algorithm."]
#[doc = " @GNUTLS_MAC_NULL: NULL MAC algorithm (empty output)."]
#[doc = " @GNUTLS_MAC_MD5: HMAC-MD5 algorithm."]
#[doc = " @GNUTLS_MAC_SHA1: HMAC-SHA-1 algorithm."]
#[doc = " @GNUTLS_MAC_RMD160: HMAC-RMD160 algorithm."]
#[doc = " @GNUTLS_MAC_MD2: HMAC-MD2 algorithm."]
#[doc = " @GNUTLS_MAC_SHA256: HMAC-SHA-256 algorithm."]
#[doc = " @GNUTLS_MAC_SHA384: HMAC-SHA-384 algorithm."]
#[doc = " @GNUTLS_MAC_SHA512: HMAC-SHA-512 algorithm."]
#[doc = " @GNUTLS_MAC_SHA224: HMAC-SHA-224 algorithm."]
#[doc = " @GNUTLS_MAC_MD5_SHA1: Combined MD5+SHA1 MAC placeholder."]
#[doc = " @GNUTLS_MAC_GOSTR_94: HMAC GOST R 34.11-94 algorithm."]
#[doc = " @GNUTLS_MAC_STREEBOG_256: HMAC GOST R 34.11-2001 (Streebog) algorithm, 256 bit."]
#[doc = " @GNUTLS_MAC_STREEBOG_512: HMAC GOST R 34.11-2001 (Streebog) algorithm, 512 bit."]
#[doc = " @GNUTLS_MAC_AEAD: MAC implicit through AEAD cipher."]
#[doc = " @GNUTLS_MAC_UMAC_96: The UMAC-96 MAC algorithm (requires nonce)."]
#[doc = " @GNUTLS_MAC_UMAC_128: The UMAC-128 MAC algorithm (requires nonce)."]
#[doc = " @GNUTLS_MAC_AES_CMAC_128: The AES-CMAC-128 MAC algorithm."]
#[doc = " @GNUTLS_MAC_AES_CMAC_256: The AES-CMAC-256 MAC algorithm."]
#[doc = " @GNUTLS_MAC_AES_GMAC_128: The AES-GMAC-128 MAC algorithm (requires nonce)."]
#[doc = " @GNUTLS_MAC_AES_GMAC_192: The AES-GMAC-192 MAC algorithm (requires nonce)."]
#[doc = " @GNUTLS_MAC_AES_GMAC_256: The AES-GMAC-256 MAC algorithm (requires nonce)."]
#[doc = " @GNUTLS_MAC_SHA3_224: Reserved; unimplemented."]
#[doc = " @GNUTLS_MAC_SHA3_256: Reserved; unimplemented."]
#[doc = " @GNUTLS_MAC_SHA3_384: Reserved; unimplemented."]
#[doc = " @GNUTLS_MAC_SHA3_512: Reserved; unimplemented."]
#[doc = " @GNUTLS_MAC_GOST28147_TC26Z_IMIT: The GOST 28147-89 working in IMIT mode with TC26 Z S-box."]
#[doc = " @GNUTLS_MAC_SHAKE_128: Reserved; unimplemented."]
#[doc = " @GNUTLS_MAC_SHAKE_256: Reserved; unimplemented."]
#[doc = ""]
#[doc = " Enumeration of different Message Authentication Code (MAC)"]
#[doc = " algorithms."]
pub type gnutls_mac_algorithm_t = ::std::os::raw::c_uint;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_UNKNOWN: gnutls_digest_algorithm_t = 0;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_NULL: gnutls_digest_algorithm_t = 1;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_MD5: gnutls_digest_algorithm_t = 2;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_SHA1: gnutls_digest_algorithm_t = 3;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_RMD160: gnutls_digest_algorithm_t = 4;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_MD2: gnutls_digest_algorithm_t = 5;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_SHA256: gnutls_digest_algorithm_t = 6;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_SHA384: gnutls_digest_algorithm_t = 7;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_SHA512: gnutls_digest_algorithm_t = 8;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_SHA224: gnutls_digest_algorithm_t = 9;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_SHA3_224: gnutls_digest_algorithm_t = 10;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_SHA3_256: gnutls_digest_algorithm_t = 11;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_SHA3_384: gnutls_digest_algorithm_t = 12;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_SHA3_512: gnutls_digest_algorithm_t = 13;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_MD5_SHA1: gnutls_digest_algorithm_t = 14;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_GOSTR_94: gnutls_digest_algorithm_t = 15;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_STREEBOG_256: gnutls_digest_algorithm_t = 16;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_STREEBOG_512: gnutls_digest_algorithm_t = 17;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_SHAKE_128: gnutls_digest_algorithm_t = 209;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_SHAKE_256: gnutls_digest_algorithm_t = 210;
#[doc = " gnutls_digest_algorithm_t:"]
#[doc = " @GNUTLS_DIG_UNKNOWN: Unknown hash algorithm."]
#[doc = " @GNUTLS_DIG_NULL: NULL hash algorithm (empty output)."]
#[doc = " @GNUTLS_DIG_MD5: MD5 algorithm."]
#[doc = " @GNUTLS_DIG_SHA1: SHA-1 algorithm."]
#[doc = " @GNUTLS_DIG_RMD160: RMD160 algorithm."]
#[doc = " @GNUTLS_DIG_MD2: MD2 algorithm."]
#[doc = " @GNUTLS_DIG_SHA256: SHA-256 algorithm."]
#[doc = " @GNUTLS_DIG_SHA384: SHA-384 algorithm."]
#[doc = " @GNUTLS_DIG_SHA512: SHA-512 algorithm."]
#[doc = " @GNUTLS_DIG_SHA224: SHA-224 algorithm."]
#[doc = " @GNUTLS_DIG_SHA3_224: SHA3-224 algorithm."]
#[doc = " @GNUTLS_DIG_SHA3_256: SHA3-256 algorithm."]
#[doc = " @GNUTLS_DIG_SHA3_384: SHA3-384 algorithm."]
#[doc = " @GNUTLS_DIG_SHA3_512: SHA3-512 algorithm."]
#[doc = " @GNUTLS_DIG_MD5_SHA1: Combined MD5+SHA1 algorithm."]
#[doc = " @GNUTLS_DIG_GOSTR_94: GOST R 34.11-94 algorithm."]
#[doc = " @GNUTLS_DIG_STREEBOG_256: GOST R 34.11-2001 (Streebog) algorithm, 256 bit."]
#[doc = " @GNUTLS_DIG_STREEBOG_512: GOST R 34.11-2001 (Streebog) algorithm, 512 bit."]
#[doc = " @GNUTLS_DIG_SHAKE_128: Reserved; unimplemented."]
#[doc = " @GNUTLS_DIG_SHAKE_256: Reserved; unimplemented."]
#[doc = ""]
#[doc = " Enumeration of different digest (hash) algorithms."]
pub type gnutls_digest_algorithm_t = ::std::os::raw::c_uint;
pub const gnutls_compression_method_t_GNUTLS_COMP_UNKNOWN: gnutls_compression_method_t = 0;
pub const gnutls_compression_method_t_GNUTLS_COMP_NULL: gnutls_compression_method_t = 1;
pub const gnutls_compression_method_t_GNUTLS_COMP_DEFLATE: gnutls_compression_method_t = 2;
pub const gnutls_compression_method_t_GNUTLS_COMP_ZLIB: gnutls_compression_method_t = 2;
#[doc = " gnutls_compression_method_t:"]
#[doc = " @GNUTLS_COMP_UNKNOWN: Unknown compression method."]
#[doc = " @GNUTLS_COMP_NULL: The NULL compression method (no compression)."]
#[doc = " @GNUTLS_COMP_DEFLATE: The DEFLATE compression method from zlib."]
#[doc = " @GNUTLS_COMP_ZLIB: Same as %GNUTLS_COMP_DEFLATE."]
#[doc = ""]
#[doc = " Enumeration of different TLS compression methods."]
pub type gnutls_compression_method_t = ::std::os::raw::c_uint;
pub const gnutls_init_flags_t_GNUTLS_SERVER: gnutls_init_flags_t = 1;
pub const gnutls_init_flags_t_GNUTLS_CLIENT: gnutls_init_flags_t = 2;
pub const gnutls_init_flags_t_GNUTLS_DATAGRAM: gnutls_init_flags_t = 4;
pub const gnutls_init_flags_t_GNUTLS_NONBLOCK: gnutls_init_flags_t = 8;
pub const gnutls_init_flags_t_GNUTLS_NO_EXTENSIONS: gnutls_init_flags_t = 16;
pub const gnutls_init_flags_t_GNUTLS_NO_REPLAY_PROTECTION: gnutls_init_flags_t = 32;
pub const gnutls_init_flags_t_GNUTLS_NO_SIGNAL: gnutls_init_flags_t = 64;
pub const gnutls_init_flags_t_GNUTLS_ALLOW_ID_CHANGE: gnutls_init_flags_t = 128;
pub const gnutls_init_flags_t_GNUTLS_ENABLE_FALSE_START: gnutls_init_flags_t = 256;
pub const gnutls_init_flags_t_GNUTLS_FORCE_CLIENT_CERT: gnutls_init_flags_t = 512;
pub const gnutls_init_flags_t_GNUTLS_NO_TICKETS: gnutls_init_flags_t = 1024;
pub const gnutls_init_flags_t_GNUTLS_KEY_SHARE_TOP: gnutls_init_flags_t = 2048;
pub const gnutls_init_flags_t_GNUTLS_KEY_SHARE_TOP2: gnutls_init_flags_t = 4096;
pub const gnutls_init_flags_t_GNUTLS_KEY_SHARE_TOP3: gnutls_init_flags_t = 8192;
pub const gnutls_init_flags_t_GNUTLS_POST_HANDSHAKE_AUTH: gnutls_init_flags_t = 16384;
pub const gnutls_init_flags_t_GNUTLS_NO_AUTO_REKEY: gnutls_init_flags_t = 32768;
pub const gnutls_init_flags_t_GNUTLS_SAFE_PADDING_CHECK: gnutls_init_flags_t = 65536;
pub const gnutls_init_flags_t_GNUTLS_ENABLE_EARLY_START: gnutls_init_flags_t = 131072;
pub const gnutls_init_flags_t_GNUTLS_ENABLE_RAWPK: gnutls_init_flags_t = 262144;
pub const gnutls_init_flags_t_GNUTLS_AUTO_REAUTH: gnutls_init_flags_t = 524288;
pub const gnutls_init_flags_t_GNUTLS_ENABLE_EARLY_DATA: gnutls_init_flags_t = 1048576;
pub const gnutls_init_flags_t_GNUTLS_NO_AUTO_SEND_TICKET: gnutls_init_flags_t = 2097152;
#[doc = " gnutls_init_flags_t:"]
#[doc = ""]
#[doc = " @GNUTLS_SERVER: Connection end is a server."]
#[doc = " @GNUTLS_CLIENT: Connection end is a client."]
#[doc = " @GNUTLS_DATAGRAM: Connection is datagram oriented (DTLS). Since 3.0.0."]
#[doc = " @GNUTLS_NONBLOCK: Connection should not block. Since 3.0.0."]
#[doc = " @GNUTLS_NO_SIGNAL: In systems where SIGPIPE is delivered on send, it will be disabled. That flag has effect in systems which support the MSG_NOSIGNAL sockets flag (since 3.4.2)."]
#[doc = " @GNUTLS_NO_EXTENSIONS: Do not enable any TLS extensions by default (since 3.1.2). As TLS 1.2 and later require extensions this option is considered obsolete and should not be used."]
#[doc = " @GNUTLS_NO_REPLAY_PROTECTION: Disable any replay protection in DTLS. This must only be used if  replay protection is achieved using other means. Since 3.2.2."]
#[doc = " @GNUTLS_ALLOW_ID_CHANGE: Allow the peer to replace its certificate, or change its ID during a rehandshake. This change is often used in attacks and thus prohibited by default. Since 3.5.0."]
#[doc = " @GNUTLS_ENABLE_FALSE_START: Enable the TLS false start on client side if the negotiated ciphersuites allow it. This will enable sending data prior to the handshake being complete, and may introduce a risk of crypto failure when combined with certain key exchanged; for that GnuTLS may not enable that option in ciphersuites that are known to be not safe for false start. Since 3.5.0."]
#[doc = " @GNUTLS_ENABLE_EARLY_START: Under TLS1.3 allow the server to return earlier than the full handshake"]
#[doc = "   finish; similarly to false start the handshake will be completed once data are received by the"]
#[doc = "   client, while the server is able to transmit sooner. This is not enabled by default as it could"]
#[doc = "   break certain existing server assumptions and use-cases. Since 3.6.4."]
#[doc = " @GNUTLS_ENABLE_EARLY_DATA: Under TLS1.3 allow the server to receive early data sent as part of the initial ClientHello (0-RTT). This is not enabled by default as early data has weaker security properties than other data. Since 3.6.5."]
#[doc = " @GNUTLS_FORCE_CLIENT_CERT: When in client side and only a single cert is specified, send that certificate irrespective of the issuers expected by the server. Since 3.5.0."]
#[doc = " @GNUTLS_NO_TICKETS: Flag to indicate that the session should not use resumption with session tickets."]
#[doc = " @GNUTLS_KEY_SHARE_TOP3: Generate key shares for the top-3 different groups which are enabled."]
#[doc = "   That is, as each group is associated with a key type (EC, finite field, x25519), generate"]
#[doc = "   three keys using %GNUTLS_PK_DH, %GNUTLS_PK_EC, %GNUTLS_PK_ECDH_X25519 if all of them are enabled."]
#[doc = " @GNUTLS_KEY_SHARE_TOP2: Generate key shares for the top-2 different groups which are enabled."]
#[doc = "   For example (ECDH + x25519). This is the default."]
#[doc = " @GNUTLS_KEY_SHARE_TOP: Generate key share for the first group which is enabled."]
#[doc = "   For example x25519. This option is the most performant for client (less CPU spent"]
#[doc = "   generating keys), but if the server doesn't support the advertized option it may"]
#[doc = "   result to more roundtrips needed to discover the server's choice."]
#[doc = " @GNUTLS_NO_AUTO_REKEY: Disable auto-rekeying under TLS1.3. If this option is not specified"]
#[doc = "   gnutls will force a rekey after 2^24 records have been sent."]
#[doc = " @GNUTLS_POST_HANDSHAKE_AUTH: Enable post handshake authentication for server and client. When set and"]
#[doc = "   a server requests authentication after handshake %GNUTLS_E_REAUTH_REQUEST will be returned"]
#[doc = "   by gnutls_record_recv(). A client should then call gnutls_reauth() to re-authenticate."]
#[doc = " @GNUTLS_SAFE_PADDING_CHECK: Flag to indicate that the TLS 1.3 padding check will be done in a"]
#[doc = "   safe way which doesn't leak the pad size based on GnuTLS processing time. This is of use to"]
#[doc = "   applications which hide the length of transferred data via the TLS1.3 padding mechanism and"]
#[doc = "   are already taking steps to hide the data processing time. This comes at a performance"]
#[doc = "   penalty."]
#[doc = " @GNUTLS_AUTO_REAUTH: Enable transparent re-authentication in client side when the server"]
#[doc = "    requests to. That is, reauthentication is handled within gnutls_record_recv(), and"]
#[doc = "    the %GNUTLS_E_REHANDSHAKE or %GNUTLS_E_REAUTH_REQUEST are not returned. This must be"]
#[doc = "    enabled with %GNUTLS_POST_HANDSHAKE_AUTH for TLS1.3. Enabling this flag requires to restore"]
#[doc = "    interrupted calls to gnutls_record_recv() based on the output of gnutls_record_get_direction(),"]
#[doc = "    since gnutls_record_recv() could be interrupted when sending when this flag is enabled."]
#[doc = "    Note this flag may not be used if you are using the same session for sending and receiving"]
#[doc = "    in different threads."]
#[doc = " @GNUTLS_ENABLE_EARLY_DATA: Under TLS1.3 allow the server to receive early data sent as part of the initial ClientHello (0-RTT)."]
#[doc = "    This is not enabled by default as early data has weaker security properties than other data. Since 3.6.5."]
#[doc = " @GNUTLS_ENABLE_RAWPK: Allows raw public-keys to be negotiated during the handshake. Since 3.6.6."]
#[doc = " @GNUTLS_NO_AUTO_SEND_TICKET: Under TLS1.3 disable auto-sending of"]
#[doc = "    session tickets during the handshake."]
#[doc = ""]
#[doc = " Enumeration of different flags for gnutls_init() function. All the flags"]
#[doc = " can be combined except @GNUTLS_SERVER and @GNUTLS_CLIENT which are mutually"]
#[doc = " exclusive."]
#[doc = ""]
#[doc = " The key share options relate to the TLS 1.3 key share extension"]
#[doc = " which is a speculative key generation expecting that the server"]
#[doc = " would support the generated key."]
pub type gnutls_init_flags_t = ::std::os::raw::c_uint;
pub const gnutls_alert_level_t_GNUTLS_AL_WARNING: gnutls_alert_level_t = 1;
pub const gnutls_alert_level_t_GNUTLS_AL_FATAL: gnutls_alert_level_t = 2;
#[doc = " gnutls_alert_level_t:"]
#[doc = " @GNUTLS_AL_WARNING: Alert of warning severity."]
#[doc = " @GNUTLS_AL_FATAL: Alert of fatal severity."]
#[doc = ""]
#[doc = " Enumeration of different TLS alert severities."]
pub type gnutls_alert_level_t = ::std::os::raw::c_uint;
pub const gnutls_alert_description_t_GNUTLS_A_CLOSE_NOTIFY: gnutls_alert_description_t = 0;
pub const gnutls_alert_description_t_GNUTLS_A_UNEXPECTED_MESSAGE: gnutls_alert_description_t = 10;
pub const gnutls_alert_description_t_GNUTLS_A_BAD_RECORD_MAC: gnutls_alert_description_t = 20;
pub const gnutls_alert_description_t_GNUTLS_A_DECRYPTION_FAILED: gnutls_alert_description_t = 21;
pub const gnutls_alert_description_t_GNUTLS_A_RECORD_OVERFLOW: gnutls_alert_description_t = 22;
pub const gnutls_alert_description_t_GNUTLS_A_DECOMPRESSION_FAILURE: gnutls_alert_description_t =
    30;
pub const gnutls_alert_description_t_GNUTLS_A_HANDSHAKE_FAILURE: gnutls_alert_description_t = 40;
pub const gnutls_alert_description_t_GNUTLS_A_SSL3_NO_CERTIFICATE: gnutls_alert_description_t = 41;
pub const gnutls_alert_description_t_GNUTLS_A_BAD_CERTIFICATE: gnutls_alert_description_t = 42;
pub const gnutls_alert_description_t_GNUTLS_A_UNSUPPORTED_CERTIFICATE: gnutls_alert_description_t =
    43;
pub const gnutls_alert_description_t_GNUTLS_A_CERTIFICATE_REVOKED: gnutls_alert_description_t = 44;
pub const gnutls_alert_description_t_GNUTLS_A_CERTIFICATE_EXPIRED: gnutls_alert_description_t = 45;
pub const gnutls_alert_description_t_GNUTLS_A_CERTIFICATE_UNKNOWN: gnutls_alert_description_t = 46;
pub const gnutls_alert_description_t_GNUTLS_A_ILLEGAL_PARAMETER: gnutls_alert_description_t = 47;
pub const gnutls_alert_description_t_GNUTLS_A_UNKNOWN_CA: gnutls_alert_description_t = 48;
pub const gnutls_alert_description_t_GNUTLS_A_ACCESS_DENIED: gnutls_alert_description_t = 49;
pub const gnutls_alert_description_t_GNUTLS_A_DECODE_ERROR: gnutls_alert_description_t = 50;
pub const gnutls_alert_description_t_GNUTLS_A_DECRYPT_ERROR: gnutls_alert_description_t = 51;
pub const gnutls_alert_description_t_GNUTLS_A_EXPORT_RESTRICTION: gnutls_alert_description_t = 60;
pub const gnutls_alert_description_t_GNUTLS_A_PROTOCOL_VERSION: gnutls_alert_description_t = 70;
pub const gnutls_alert_description_t_GNUTLS_A_INSUFFICIENT_SECURITY: gnutls_alert_description_t =
    71;
pub const gnutls_alert_description_t_GNUTLS_A_INTERNAL_ERROR: gnutls_alert_description_t = 80;
pub const gnutls_alert_description_t_GNUTLS_A_INAPPROPRIATE_FALLBACK: gnutls_alert_description_t =
    86;
pub const gnutls_alert_description_t_GNUTLS_A_USER_CANCELED: gnutls_alert_description_t = 90;
pub const gnutls_alert_description_t_GNUTLS_A_NO_RENEGOTIATION: gnutls_alert_description_t = 100;
pub const gnutls_alert_description_t_GNUTLS_A_MISSING_EXTENSION: gnutls_alert_description_t = 109;
pub const gnutls_alert_description_t_GNUTLS_A_UNSUPPORTED_EXTENSION: gnutls_alert_description_t =
    110;
pub const gnutls_alert_description_t_GNUTLS_A_CERTIFICATE_UNOBTAINABLE: gnutls_alert_description_t =
    111;
pub const gnutls_alert_description_t_GNUTLS_A_UNRECOGNIZED_NAME: gnutls_alert_description_t = 112;
pub const gnutls_alert_description_t_GNUTLS_A_UNKNOWN_PSK_IDENTITY: gnutls_alert_description_t =
    115;
pub const gnutls_alert_description_t_GNUTLS_A_CERTIFICATE_REQUIRED: gnutls_alert_description_t =
    116;
pub const gnutls_alert_description_t_GNUTLS_A_NO_APPLICATION_PROTOCOL: gnutls_alert_description_t =
    120;
pub const gnutls_alert_description_t_GNUTLS_A_MAX: gnutls_alert_description_t = 120;
#[doc = " gnutls_alert_description_t:"]
#[doc = " @GNUTLS_A_CLOSE_NOTIFY: Close notify."]
#[doc = " @GNUTLS_A_UNEXPECTED_MESSAGE: Unexpected message."]
#[doc = " @GNUTLS_A_BAD_RECORD_MAC: Bad record MAC."]
#[doc = " @GNUTLS_A_DECRYPTION_FAILED: Decryption failed."]
#[doc = " @GNUTLS_A_RECORD_OVERFLOW: Record overflow."]
#[doc = " @GNUTLS_A_DECOMPRESSION_FAILURE: Decompression failed."]
#[doc = " @GNUTLS_A_HANDSHAKE_FAILURE: Handshake failed."]
#[doc = " @GNUTLS_A_SSL3_NO_CERTIFICATE: No certificate."]
#[doc = " @GNUTLS_A_BAD_CERTIFICATE: Certificate is bad."]
#[doc = " @GNUTLS_A_UNSUPPORTED_CERTIFICATE: Certificate is not supported."]
#[doc = " @GNUTLS_A_CERTIFICATE_REVOKED: Certificate was revoked."]
#[doc = " @GNUTLS_A_CERTIFICATE_EXPIRED: Certificate is expired."]
#[doc = " @GNUTLS_A_CERTIFICATE_UNKNOWN: Unknown certificate."]
#[doc = " @GNUTLS_A_ILLEGAL_PARAMETER: Illegal parameter."]
#[doc = " @GNUTLS_A_UNKNOWN_CA: CA is unknown."]
#[doc = " @GNUTLS_A_ACCESS_DENIED: Access was denied."]
#[doc = " @GNUTLS_A_DECODE_ERROR: Decode error."]
#[doc = " @GNUTLS_A_DECRYPT_ERROR: Decrypt error."]
#[doc = " @GNUTLS_A_EXPORT_RESTRICTION: Export restriction."]
#[doc = " @GNUTLS_A_PROTOCOL_VERSION: Error in protocol version."]
#[doc = " @GNUTLS_A_INSUFFICIENT_SECURITY: Insufficient security."]
#[doc = " @GNUTLS_A_INTERNAL_ERROR: Internal error."]
#[doc = " @GNUTLS_A_INAPPROPRIATE_FALLBACK: Inappropriate fallback,"]
#[doc = " @GNUTLS_A_USER_CANCELED: User canceled."]
#[doc = " @GNUTLS_A_NO_RENEGOTIATION: No renegotiation is allowed."]
#[doc = " @GNUTLS_A_MISSING_EXTENSION: An extension was expected but was not seen"]
#[doc = " @GNUTLS_A_UNSUPPORTED_EXTENSION: An unsupported extension was"]
#[doc = "   sent."]
#[doc = " @GNUTLS_A_CERTIFICATE_UNOBTAINABLE: Could not retrieve the"]
#[doc = "   specified certificate."]
#[doc = " @GNUTLS_A_UNRECOGNIZED_NAME: The server name sent was not"]
#[doc = "   recognized."]
#[doc = " @GNUTLS_A_UNKNOWN_PSK_IDENTITY: The SRP/PSK username is missing"]
#[doc = "   or not known."]
#[doc = " @GNUTLS_A_CERTIFICATE_REQUIRED: Certificate is required."]
#[doc = " @GNUTLS_A_NO_APPLICATION_PROTOCOL: The ALPN protocol requested is"]
#[doc = "   not supported by the peer."]
#[doc = ""]
#[doc = " Enumeration of different TLS alerts."]
pub type gnutls_alert_description_t = ::std::os::raw::c_uint;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_HELLO_REQUEST:
    gnutls_handshake_description_t = 0;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_CLIENT_HELLO:
    gnutls_handshake_description_t = 1;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_SERVER_HELLO:
    gnutls_handshake_description_t = 2;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_HELLO_VERIFY_REQUEST:
    gnutls_handshake_description_t = 3;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_NEW_SESSION_TICKET:
    gnutls_handshake_description_t = 4;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_END_OF_EARLY_DATA:
    gnutls_handshake_description_t = 5;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_ENCRYPTED_EXTENSIONS:
    gnutls_handshake_description_t = 8;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_CERTIFICATE_PKT:
    gnutls_handshake_description_t = 11;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_SERVER_KEY_EXCHANGE:
    gnutls_handshake_description_t = 12;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_CERTIFICATE_REQUEST:
    gnutls_handshake_description_t = 13;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_SERVER_HELLO_DONE:
    gnutls_handshake_description_t = 14;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_CERTIFICATE_VERIFY:
    gnutls_handshake_description_t = 15;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_CLIENT_KEY_EXCHANGE:
    gnutls_handshake_description_t = 16;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_FINISHED: gnutls_handshake_description_t =
    20;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_CERTIFICATE_STATUS:
    gnutls_handshake_description_t = 22;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_SUPPLEMENTAL:
    gnutls_handshake_description_t = 23;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_KEY_UPDATE:
    gnutls_handshake_description_t = 24;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_CHANGE_CIPHER_SPEC:
    gnutls_handshake_description_t = 254;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_CLIENT_HELLO_V2:
    gnutls_handshake_description_t = 1024;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_HELLO_RETRY_REQUEST:
    gnutls_handshake_description_t = 1025;
#[doc = " gnutls_handshake_description_t:"]
#[doc = " @GNUTLS_HANDSHAKE_HELLO_REQUEST: Hello request."]
#[doc = " @GNUTLS_HANDSHAKE_HELLO_VERIFY_REQUEST: DTLS Hello verify request."]
#[doc = " @GNUTLS_HANDSHAKE_CLIENT_HELLO: Client hello."]
#[doc = " @GNUTLS_HANDSHAKE_SERVER_HELLO: Server hello."]
#[doc = " @GNUTLS_HANDSHAKE_END_OF_EARLY_DATA: End of early data."]
#[doc = " @GNUTLS_HANDSHAKE_HELLO_RETRY_REQUEST: Hello retry request."]
#[doc = " @GNUTLS_HANDSHAKE_NEW_SESSION_TICKET: New session ticket."]
#[doc = " @GNUTLS_HANDSHAKE_CERTIFICATE_PKT: Certificate packet."]
#[doc = " @GNUTLS_HANDSHAKE_SERVER_KEY_EXCHANGE: Server key exchange."]
#[doc = " @GNUTLS_HANDSHAKE_CERTIFICATE_REQUEST: Certificate request."]
#[doc = " @GNUTLS_HANDSHAKE_SERVER_HELLO_DONE: Server hello done."]
#[doc = " @GNUTLS_HANDSHAKE_CERTIFICATE_VERIFY: Certificate verify."]
#[doc = " @GNUTLS_HANDSHAKE_CLIENT_KEY_EXCHANGE: Client key exchange."]
#[doc = " @GNUTLS_HANDSHAKE_FINISHED: Finished."]
#[doc = " @GNUTLS_HANDSHAKE_CERTIFICATE_STATUS: Certificate status (OCSP)."]
#[doc = " @GNUTLS_HANDSHAKE_KEY_UPDATE: TLS1.3 key update message."]
#[doc = " @GNUTLS_HANDSHAKE_SUPPLEMENTAL: Supplemental."]
#[doc = " @GNUTLS_HANDSHAKE_CHANGE_CIPHER_SPEC: Change Cipher Spec."]
#[doc = " @GNUTLS_HANDSHAKE_CLIENT_HELLO_V2: SSLv2 Client Hello."]
#[doc = " @GNUTLS_HANDSHAKE_ENCRYPTED_EXTENSIONS: Encrypted extensions message."]
#[doc = ""]
#[doc = " Enumeration of different TLS handshake packets."]
pub type gnutls_handshake_description_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn gnutls_handshake_description_get_name(
        type_: gnutls_handshake_description_t,
    ) -> *const ::std::os::raw::c_char;
}
pub const gnutls_certificate_status_t_GNUTLS_CERT_INVALID: gnutls_certificate_status_t = 2;
pub const gnutls_certificate_status_t_GNUTLS_CERT_REVOKED: gnutls_certificate_status_t = 32;
pub const gnutls_certificate_status_t_GNUTLS_CERT_SIGNER_NOT_FOUND: gnutls_certificate_status_t =
    64;
pub const gnutls_certificate_status_t_GNUTLS_CERT_SIGNER_NOT_CA: gnutls_certificate_status_t = 128;
pub const gnutls_certificate_status_t_GNUTLS_CERT_INSECURE_ALGORITHM: gnutls_certificate_status_t =
    256;
pub const gnutls_certificate_status_t_GNUTLS_CERT_NOT_ACTIVATED: gnutls_certificate_status_t = 512;
pub const gnutls_certificate_status_t_GNUTLS_CERT_EXPIRED: gnutls_certificate_status_t = 1024;
pub const gnutls_certificate_status_t_GNUTLS_CERT_SIGNATURE_FAILURE: gnutls_certificate_status_t =
    2048;
pub const gnutls_certificate_status_t_GNUTLS_CERT_REVOCATION_DATA_SUPERSEDED:
    gnutls_certificate_status_t = 4096;
pub const gnutls_certificate_status_t_GNUTLS_CERT_UNEXPECTED_OWNER: gnutls_certificate_status_t =
    16384;
pub const gnutls_certificate_status_t_GNUTLS_CERT_REVOCATION_DATA_ISSUED_IN_FUTURE:
    gnutls_certificate_status_t = 32768;
pub const gnutls_certificate_status_t_GNUTLS_CERT_SIGNER_CONSTRAINTS_FAILURE:
    gnutls_certificate_status_t = 65536;
pub const gnutls_certificate_status_t_GNUTLS_CERT_MISMATCH: gnutls_certificate_status_t = 131072;
pub const gnutls_certificate_status_t_GNUTLS_CERT_PURPOSE_MISMATCH: gnutls_certificate_status_t =
    262144;
pub const gnutls_certificate_status_t_GNUTLS_CERT_MISSING_OCSP_STATUS: gnutls_certificate_status_t =
    524288;
pub const gnutls_certificate_status_t_GNUTLS_CERT_INVALID_OCSP_STATUS: gnutls_certificate_status_t =
    1048576;
pub const gnutls_certificate_status_t_GNUTLS_CERT_UNKNOWN_CRIT_EXTENSIONS:
    gnutls_certificate_status_t = 2097152;
#[doc = " gnutls_certificate_status_t:"]
#[doc = " @GNUTLS_CERT_INVALID: The certificate is not signed by one of the"]
#[doc = "   known authorities or the signature is invalid (deprecated by the flags"]
#[doc = "   %GNUTLS_CERT_SIGNATURE_FAILURE and %GNUTLS_CERT_SIGNER_NOT_FOUND)."]
#[doc = " @GNUTLS_CERT_SIGNATURE_FAILURE: The signature verification failed."]
#[doc = " @GNUTLS_CERT_REVOKED: Certificate is revoked by its authority.  In X.509 this will be"]
#[doc = "   set only if CRLs are checked."]
#[doc = " @GNUTLS_CERT_SIGNER_NOT_FOUND: The certificate's issuer is not known."]
#[doc = "   This is the case if the issuer is not included in the trusted certificate list."]
#[doc = " @GNUTLS_CERT_SIGNER_NOT_CA: The certificate's signer was not a CA. This"]
#[doc = "   may happen if this was a version 1 certificate, which is common with"]
#[doc = "   some CAs, or a version 3 certificate without the basic constrains extension."]
#[doc = " @GNUTLS_CERT_SIGNER_CONSTRAINTS_FAILURE: The certificate's signer constraints were"]
#[doc = "   violated."]
#[doc = " @GNUTLS_CERT_INSECURE_ALGORITHM:  The certificate was signed using an insecure"]
#[doc = "   algorithm such as MD2 or MD5. These algorithms have been broken and"]
#[doc = "   should not be trusted."]
#[doc = " @GNUTLS_CERT_NOT_ACTIVATED: The certificate is not yet activated."]
#[doc = " @GNUTLS_CERT_EXPIRED: The certificate has expired."]
#[doc = " @GNUTLS_CERT_REVOCATION_DATA_SUPERSEDED: The revocation data are old and have been superseded."]
#[doc = " @GNUTLS_CERT_REVOCATION_DATA_ISSUED_IN_FUTURE: The revocation data have a future issue date."]
#[doc = " @GNUTLS_CERT_UNEXPECTED_OWNER: The owner is not the expected one."]
#[doc = " @GNUTLS_CERT_MISMATCH: The certificate presented isn't the expected one (TOFU)"]
#[doc = " @GNUTLS_CERT_PURPOSE_MISMATCH: The certificate or an intermediate does not match the intended purpose (extended key usage)."]
#[doc = " @GNUTLS_CERT_MISSING_OCSP_STATUS: The certificate requires the server to send the certifiate status, but no status was received."]
#[doc = " @GNUTLS_CERT_INVALID_OCSP_STATUS: The received OCSP status response is invalid."]
#[doc = " @GNUTLS_CERT_UNKNOWN_CRIT_EXTENSIONS: The certificate has extensions marked as critical which are not supported."]
#[doc = ""]
#[doc = " Enumeration of certificate status codes.  Note that the status"]
#[doc = " bits may have different meanings in OpenPGP keys and X.509"]
#[doc = " certificate verification."]
pub type gnutls_certificate_status_t = ::std::os::raw::c_uint;
pub const gnutls_certificate_request_t_GNUTLS_CERT_IGNORE: gnutls_certificate_request_t = 0;
pub const gnutls_certificate_request_t_GNUTLS_CERT_REQUEST: gnutls_certificate_request_t = 1;
pub const gnutls_certificate_request_t_GNUTLS_CERT_REQUIRE: gnutls_certificate_request_t = 2;
#[doc = " gnutls_certificate_request_t:"]
#[doc = " @GNUTLS_CERT_IGNORE: Ignore certificate."]
#[doc = " @GNUTLS_CERT_REQUEST: Request certificate."]
#[doc = " @GNUTLS_CERT_REQUIRE: Require certificate."]
#[doc = ""]
#[doc = " Enumeration of certificate request types."]
pub type gnutls_certificate_request_t = ::std::os::raw::c_uint;
pub const gnutls_openpgp_crt_status_t_GNUTLS_OPENPGP_CERT: gnutls_openpgp_crt_status_t = 0;
pub const gnutls_openpgp_crt_status_t_GNUTLS_OPENPGP_CERT_FINGERPRINT: gnutls_openpgp_crt_status_t =
    1;
#[doc = " gnutls_openpgp_crt_status_t:"]
#[doc = " @GNUTLS_OPENPGP_CERT: Send entire certificate."]
#[doc = " @GNUTLS_OPENPGP_CERT_FINGERPRINT: Send only certificate fingerprint."]
#[doc = ""]
#[doc = " Enumeration of ways to send OpenPGP certificate."]
pub type gnutls_openpgp_crt_status_t = ::std::os::raw::c_uint;
pub const gnutls_close_request_t_GNUTLS_SHUT_RDWR: gnutls_close_request_t = 0;
pub const gnutls_close_request_t_GNUTLS_SHUT_WR: gnutls_close_request_t = 1;
#[doc = " gnutls_close_request_t:"]
#[doc = " @GNUTLS_SHUT_RDWR: Disallow further receives/sends."]
#[doc = " @GNUTLS_SHUT_WR: Disallow further sends."]
#[doc = ""]
#[doc = " Enumeration of how TLS session should be terminated.  See gnutls_bye()."]
pub type gnutls_close_request_t = ::std::os::raw::c_uint;
pub const gnutls_protocol_t_GNUTLS_SSL3: gnutls_protocol_t = 1;
pub const gnutls_protocol_t_GNUTLS_TLS1_0: gnutls_protocol_t = 2;
pub const gnutls_protocol_t_GNUTLS_TLS1: gnutls_protocol_t = 2;
pub const gnutls_protocol_t_GNUTLS_TLS1_1: gnutls_protocol_t = 3;
pub const gnutls_protocol_t_GNUTLS_TLS1_2: gnutls_protocol_t = 4;
pub const gnutls_protocol_t_GNUTLS_TLS1_3: gnutls_protocol_t = 5;
pub const gnutls_protocol_t_GNUTLS_DTLS0_9: gnutls_protocol_t = 200;
pub const gnutls_protocol_t_GNUTLS_DTLS1_0: gnutls_protocol_t = 201;
pub const gnutls_protocol_t_GNUTLS_DTLS1_2: gnutls_protocol_t = 202;
pub const gnutls_protocol_t_GNUTLS_DTLS_VERSION_MIN: gnutls_protocol_t = 200;
pub const gnutls_protocol_t_GNUTLS_DTLS_VERSION_MAX: gnutls_protocol_t = 202;
pub const gnutls_protocol_t_GNUTLS_TLS_VERSION_MAX: gnutls_protocol_t = 5;
pub const gnutls_protocol_t_GNUTLS_VERSION_UNKNOWN: gnutls_protocol_t = 255;
#[doc = " gnutls_protocol_t:"]
#[doc = " @GNUTLS_SSL3: SSL version 3.0."]
#[doc = " @GNUTLS_TLS1_0: TLS version 1.0."]
#[doc = " @GNUTLS_TLS1: Same as %GNUTLS_TLS1_0."]
#[doc = " @GNUTLS_TLS1_1: TLS version 1.1."]
#[doc = " @GNUTLS_TLS1_2: TLS version 1.2."]
#[doc = " @GNUTLS_TLS1_3: TLS version 1.3."]
#[doc = " @GNUTLS_DTLS1_0: DTLS version 1.0."]
#[doc = " @GNUTLS_DTLS1_2: DTLS version 1.2."]
#[doc = " @GNUTLS_DTLS0_9: DTLS version 0.9 (Cisco AnyConnect / OpenSSL 0.9.8e)."]
#[doc = " @GNUTLS_TLS_VERSION_MAX: Maps to the highest supported TLS version."]
#[doc = " @GNUTLS_DTLS_VERSION_MAX: Maps to the highest supported DTLS version."]
#[doc = " @GNUTLS_VERSION_UNKNOWN: Unknown SSL/TLS version."]
#[doc = ""]
#[doc = " Enumeration of different SSL/TLS protocol versions."]
pub type gnutls_protocol_t = ::std::os::raw::c_uint;
pub const gnutls_certificate_type_t_GNUTLS_CRT_UNKNOWN: gnutls_certificate_type_t = 0;
pub const gnutls_certificate_type_t_GNUTLS_CRT_X509: gnutls_certificate_type_t = 1;
pub const gnutls_certificate_type_t_GNUTLS_CRT_OPENPGP: gnutls_certificate_type_t = 2;
pub const gnutls_certificate_type_t_GNUTLS_CRT_RAWPK: gnutls_certificate_type_t = 3;
pub const gnutls_certificate_type_t_GNUTLS_CRT_MAX: gnutls_certificate_type_t = 3;
#[doc = " gnutls_certificate_type_t:"]
#[doc = " @GNUTLS_CRT_UNKNOWN: Unknown certificate type."]
#[doc = " @GNUTLS_CRT_X509: X.509 Certificate."]
#[doc = " @GNUTLS_CRT_OPENPGP: OpenPGP certificate."]
#[doc = " @GNUTLS_CRT_RAWPK: Raw public-key (SubjectPublicKeyInfo)"]
#[doc = ""]
#[doc = " Enumeration of different certificate types."]
pub type gnutls_certificate_type_t = ::std::os::raw::c_uint;
pub const gnutls_x509_crt_fmt_t_GNUTLS_X509_FMT_DER: gnutls_x509_crt_fmt_t = 0;
pub const gnutls_x509_crt_fmt_t_GNUTLS_X509_FMT_PEM: gnutls_x509_crt_fmt_t = 1;
#[doc = " gnutls_x509_crt_fmt_t:"]
#[doc = " @GNUTLS_X509_FMT_DER: X.509 certificate in DER format (binary)."]
#[doc = " @GNUTLS_X509_FMT_PEM: X.509 certificate in PEM format (text)."]
#[doc = ""]
#[doc = " Enumeration of different certificate encoding formats."]
pub type gnutls_x509_crt_fmt_t = ::std::os::raw::c_uint;
pub const gnutls_certificate_print_formats_GNUTLS_CRT_PRINT_FULL: gnutls_certificate_print_formats =
    0;
pub const gnutls_certificate_print_formats_GNUTLS_CRT_PRINT_ONELINE:
    gnutls_certificate_print_formats = 1;
pub const gnutls_certificate_print_formats_GNUTLS_CRT_PRINT_UNSIGNED_FULL:
    gnutls_certificate_print_formats = 2;
pub const gnutls_certificate_print_formats_GNUTLS_CRT_PRINT_COMPACT:
    gnutls_certificate_print_formats = 3;
pub const gnutls_certificate_print_formats_GNUTLS_CRT_PRINT_FULL_NUMBERS:
    gnutls_certificate_print_formats = 4;
#[doc = " gnutls_certificate_print_formats_t:"]
#[doc = " @GNUTLS_CRT_PRINT_FULL: Full information about certificate."]
#[doc = " @GNUTLS_CRT_PRINT_FULL_NUMBERS: Full information about certificate and include easy to parse public key parameters."]
#[doc = " @GNUTLS_CRT_PRINT_COMPACT: Information about certificate name in one line, plus identification of the public key."]
#[doc = " @GNUTLS_CRT_PRINT_ONELINE: Information about certificate in one line."]
#[doc = " @GNUTLS_CRT_PRINT_UNSIGNED_FULL: All info for an unsigned certificate."]
#[doc = ""]
#[doc = " Enumeration of different certificate printing variants."]
pub type gnutls_certificate_print_formats = ::std::os::raw::c_uint;
#[doc = " gnutls_certificate_print_formats_t:"]
#[doc = " @GNUTLS_CRT_PRINT_FULL: Full information about certificate."]
#[doc = " @GNUTLS_CRT_PRINT_FULL_NUMBERS: Full information about certificate and include easy to parse public key parameters."]
#[doc = " @GNUTLS_CRT_PRINT_COMPACT: Information about certificate name in one line, plus identification of the public key."]
#[doc = " @GNUTLS_CRT_PRINT_ONELINE: Information about certificate in one line."]
#[doc = " @GNUTLS_CRT_PRINT_UNSIGNED_FULL: All info for an unsigned certificate."]
#[doc = ""]
#[doc = " Enumeration of different certificate printing variants."]
pub use self::gnutls_certificate_print_formats as gnutls_certificate_print_formats_t;
pub const gnutls_pk_algorithm_t_GNUTLS_PK_UNKNOWN: gnutls_pk_algorithm_t = 0;
pub const gnutls_pk_algorithm_t_GNUTLS_PK_RSA: gnutls_pk_algorithm_t = 1;
pub const gnutls_pk_algorithm_t_GNUTLS_PK_DSA: gnutls_pk_algorithm_t = 2;
pub const gnutls_pk_algorithm_t_GNUTLS_PK_DH: gnutls_pk_algorithm_t = 3;
pub const gnutls_pk_algorithm_t_GNUTLS_PK_ECDSA: gnutls_pk_algorithm_t = 4;
pub const gnutls_pk_algorithm_t_GNUTLS_PK_ECDH_X25519: gnutls_pk_algorithm_t = 5;
pub const gnutls_pk_algorithm_t_GNUTLS_PK_RSA_PSS: gnutls_pk_algorithm_t = 6;
pub const gnutls_pk_algorithm_t_GNUTLS_PK_EDDSA_ED25519: gnutls_pk_algorithm_t = 7;
pub const gnutls_pk_algorithm_t_GNUTLS_PK_GOST_01: gnutls_pk_algorithm_t = 8;
pub const gnutls_pk_algorithm_t_GNUTLS_PK_GOST_12_256: gnutls_pk_algorithm_t = 9;
pub const gnutls_pk_algorithm_t_GNUTLS_PK_GOST_12_512: gnutls_pk_algorithm_t = 10;
pub const gnutls_pk_algorithm_t_GNUTLS_PK_ECDH_X448: gnutls_pk_algorithm_t = 11;
pub const gnutls_pk_algorithm_t_GNUTLS_PK_EDDSA_ED448: gnutls_pk_algorithm_t = 12;
pub const gnutls_pk_algorithm_t_GNUTLS_PK_MAX: gnutls_pk_algorithm_t = 12;
#[doc = " gnutls_pk_algorithm_t:"]
#[doc = " @GNUTLS_PK_UNKNOWN: Unknown public-key algorithm."]
#[doc = " @GNUTLS_PK_RSA: RSA public-key algorithm."]
#[doc = " @GNUTLS_PK_RSA_PSS: RSA public-key algorithm, with PSS padding."]
#[doc = " @GNUTLS_PK_DSA: DSA public-key algorithm."]
#[doc = " @GNUTLS_PK_DH: Diffie-Hellman algorithm. Used to generate parameters."]
#[doc = " @GNUTLS_PK_ECDSA: Elliptic curve algorithm. These parameters are compatible with the ECDSA and ECDH algorithm."]
#[doc = " @GNUTLS_PK_ECDH_X25519: Elliptic curve algorithm, restricted to ECDH as per rfc7748."]
#[doc = " @GNUTLS_PK_EDDSA_ED25519: Edwards curve Digital signature algorithm. Used with SHA512 on signatures."]
#[doc = " @GNUTLS_PK_GOST_01: GOST R 34.10-2001 algorithm per rfc5832."]
#[doc = " @GNUTLS_PK_GOST_12_256: GOST R 34.10-2012 algorithm, 256-bit key per rfc7091."]
#[doc = " @GNUTLS_PK_GOST_12_512: GOST R 34.10-2012 algorithm, 512-bit key per rfc7091."]
#[doc = " @GNUTLS_PK_ECDH_X448: Elliptic curve algorithm, restricted to ECDH as per rfc7748."]
#[doc = " @GNUTLS_PK_EDDSA_ED448: Edwards curve Digital signature algorithm. Used with SHAKE256 on signatures."]
#[doc = ""]
#[doc = " Enumeration of different public-key algorithms."]
pub type gnutls_pk_algorithm_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn gnutls_pk_algorithm_get_name(
        algorithm: gnutls_pk_algorithm_t,
    ) -> *const ::std::os::raw::c_char;
}
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_UNKNOWN: gnutls_sign_algorithm_t = 0;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_SHA1: gnutls_sign_algorithm_t = 1;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_SHA: gnutls_sign_algorithm_t = 1;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_DSA_SHA1: gnutls_sign_algorithm_t = 2;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_DSA_SHA: gnutls_sign_algorithm_t = 2;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_MD5: gnutls_sign_algorithm_t = 3;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_MD2: gnutls_sign_algorithm_t = 4;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_RMD160: gnutls_sign_algorithm_t = 5;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_SHA256: gnutls_sign_algorithm_t = 6;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_SHA384: gnutls_sign_algorithm_t = 7;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_SHA512: gnutls_sign_algorithm_t = 8;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_SHA224: gnutls_sign_algorithm_t = 9;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_DSA_SHA224: gnutls_sign_algorithm_t = 10;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_DSA_SHA256: gnutls_sign_algorithm_t = 11;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_ECDSA_SHA1: gnutls_sign_algorithm_t = 12;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_ECDSA_SHA224: gnutls_sign_algorithm_t = 13;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_ECDSA_SHA256: gnutls_sign_algorithm_t = 14;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_ECDSA_SHA384: gnutls_sign_algorithm_t = 15;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_ECDSA_SHA512: gnutls_sign_algorithm_t = 16;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_DSA_SHA384: gnutls_sign_algorithm_t = 17;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_DSA_SHA512: gnutls_sign_algorithm_t = 18;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_ECDSA_SHA3_224: gnutls_sign_algorithm_t = 20;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_ECDSA_SHA3_256: gnutls_sign_algorithm_t = 21;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_ECDSA_SHA3_384: gnutls_sign_algorithm_t = 22;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_ECDSA_SHA3_512: gnutls_sign_algorithm_t = 23;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_DSA_SHA3_224: gnutls_sign_algorithm_t = 24;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_DSA_SHA3_256: gnutls_sign_algorithm_t = 25;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_DSA_SHA3_384: gnutls_sign_algorithm_t = 26;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_DSA_SHA3_512: gnutls_sign_algorithm_t = 27;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_SHA3_224: gnutls_sign_algorithm_t = 28;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_SHA3_256: gnutls_sign_algorithm_t = 29;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_SHA3_384: gnutls_sign_algorithm_t = 30;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_SHA3_512: gnutls_sign_algorithm_t = 31;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_PSS_SHA256: gnutls_sign_algorithm_t = 32;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_PSS_SHA384: gnutls_sign_algorithm_t = 33;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_PSS_SHA512: gnutls_sign_algorithm_t = 34;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_EDDSA_ED25519: gnutls_sign_algorithm_t = 35;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_RAW: gnutls_sign_algorithm_t = 36;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_ECDSA_SECP256R1_SHA256: gnutls_sign_algorithm_t = 37;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_ECDSA_SECP384R1_SHA384: gnutls_sign_algorithm_t = 38;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_ECDSA_SECP521R1_SHA512: gnutls_sign_algorithm_t = 39;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_PSS_RSAE_SHA256: gnutls_sign_algorithm_t = 40;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_PSS_RSAE_SHA384: gnutls_sign_algorithm_t = 41;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_PSS_RSAE_SHA512: gnutls_sign_algorithm_t = 42;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_GOST_94: gnutls_sign_algorithm_t = 43;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_GOST_256: gnutls_sign_algorithm_t = 44;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_GOST_512: gnutls_sign_algorithm_t = 45;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_EDDSA_ED448: gnutls_sign_algorithm_t = 46;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_MAX: gnutls_sign_algorithm_t = 46;
#[doc = " gnutls_sign_algorithm_t:"]
#[doc = " @GNUTLS_SIGN_UNKNOWN: Unknown signature algorithm."]
#[doc = " @GNUTLS_SIGN_RSA_RAW: Digital signature algorithm RSA with DigestInfo formatted data"]
#[doc = " @GNUTLS_SIGN_RSA_SHA1: Digital signature algorithm RSA with SHA-1"]
#[doc = " @GNUTLS_SIGN_RSA_SHA: Same as %GNUTLS_SIGN_RSA_SHA1."]
#[doc = " @GNUTLS_SIGN_DSA_SHA1: Digital signature algorithm DSA with SHA-1"]
#[doc = " @GNUTLS_SIGN_DSA_SHA224: Digital signature algorithm DSA with SHA-224"]
#[doc = " @GNUTLS_SIGN_DSA_SHA256: Digital signature algorithm DSA with SHA-256"]
#[doc = " @GNUTLS_SIGN_DSA_SHA384: Digital signature algorithm DSA with SHA-384"]
#[doc = " @GNUTLS_SIGN_DSA_SHA512: Digital signature algorithm DSA with SHA-512"]
#[doc = " @GNUTLS_SIGN_DSA_SHA: Same as %GNUTLS_SIGN_DSA_SHA1."]
#[doc = " @GNUTLS_SIGN_RSA_MD5: Digital signature algorithm RSA with MD5."]
#[doc = " @GNUTLS_SIGN_RSA_MD2: Digital signature algorithm RSA with MD2."]
#[doc = " @GNUTLS_SIGN_RSA_RMD160: Digital signature algorithm RSA with RMD-160."]
#[doc = " @GNUTLS_SIGN_RSA_SHA256: Digital signature algorithm RSA with SHA-256."]
#[doc = " @GNUTLS_SIGN_RSA_SHA384: Digital signature algorithm RSA with SHA-384."]
#[doc = " @GNUTLS_SIGN_RSA_SHA512: Digital signature algorithm RSA with SHA-512."]
#[doc = " @GNUTLS_SIGN_RSA_SHA224: Digital signature algorithm RSA with SHA-224."]
#[doc = " @GNUTLS_SIGN_ECDSA_SHA1: ECDSA with SHA1."]
#[doc = " @GNUTLS_SIGN_ECDSA_SHA224: Digital signature algorithm ECDSA with SHA-224."]
#[doc = " @GNUTLS_SIGN_ECDSA_SHA256: Digital signature algorithm ECDSA with SHA-256."]
#[doc = " @GNUTLS_SIGN_ECDSA_SHA384: Digital signature algorithm ECDSA with SHA-384."]
#[doc = " @GNUTLS_SIGN_ECDSA_SHA512: Digital signature algorithm ECDSA with SHA-512."]
#[doc = " @GNUTLS_SIGN_ECDSA_SECP256R1_SHA256: Digital signature algorithm ECDSA-SECP256R1 with SHA-256 (used in TLS 1.3 but not PKIX)."]
#[doc = " @GNUTLS_SIGN_ECDSA_SECP384R1_SHA384: Digital signature algorithm ECDSA-SECP384R1 with SHA-384 (used in TLS 1.3 but not PKIX)."]
#[doc = " @GNUTLS_SIGN_ECDSA_SECP521R1_SHA512: Digital signature algorithm ECDSA-SECP521R1 with SHA-512 (used in TLS 1.3 but not PKIX)."]
#[doc = " @GNUTLS_SIGN_ECDSA_SHA3_224: Digital signature algorithm ECDSA with SHA3-224."]
#[doc = " @GNUTLS_SIGN_ECDSA_SHA3_256: Digital signature algorithm ECDSA with SHA3-256."]
#[doc = " @GNUTLS_SIGN_ECDSA_SHA3_384: Digital signature algorithm ECDSA with SHA3-384."]
#[doc = " @GNUTLS_SIGN_ECDSA_SHA3_512: Digital signature algorithm ECDSA with SHA3-512."]
#[doc = " @GNUTLS_SIGN_DSA_SHA3_224: Digital signature algorithm DSA with SHA3-224."]
#[doc = " @GNUTLS_SIGN_DSA_SHA3_256: Digital signature algorithm DSA with SHA3-256."]
#[doc = " @GNUTLS_SIGN_DSA_SHA3_384: Digital signature algorithm DSA with SHA3-384."]
#[doc = " @GNUTLS_SIGN_DSA_SHA3_512: Digital signature algorithm DSA with SHA3-512."]
#[doc = " @GNUTLS_SIGN_RSA_SHA3_224: Digital signature algorithm RSA with SHA3-224."]
#[doc = " @GNUTLS_SIGN_RSA_SHA3_256: Digital signature algorithm RSA with SHA3-256."]
#[doc = " @GNUTLS_SIGN_RSA_SHA3_384: Digital signature algorithm RSA with SHA3-384."]
#[doc = " @GNUTLS_SIGN_RSA_SHA3_512: Digital signature algorithm RSA with SHA3-512."]
#[doc = " @GNUTLS_SIGN_RSA_PSS_RSAE_SHA256: Digital signature algorithm RSA with SHA-256,"]
#[doc = "      with PSS padding (RSA PKCS#1 1.5 certificate). This signature is identical"]
#[doc = "      to #GNUTLS_SIGN_RSA_PSS_SHA256, but they are distinct as the TLS1.3 protocol"]
#[doc = "      treats them differently."]
#[doc = " @GNUTLS_SIGN_RSA_PSS_RSAE_SHA384: Digital signature algorithm RSA with SHA-384,"]
#[doc = "      with PSS padding (RSA PKCS#1 1.5 certificate). This signature is identical"]
#[doc = "      to #GNUTLS_SIGN_RSA_PSS_SHA384, but they are distinct as the TLS1.3 protocol"]
#[doc = "      treats them differently."]
#[doc = " @GNUTLS_SIGN_RSA_PSS_RSAE_SHA512: Digital signature algorithm RSA with SHA-512,"]
#[doc = "      with PSS padding (RSA PKCS#1 1.5 certificate). This signature is identical"]
#[doc = "      to #GNUTLS_SIGN_RSA_PSS_SHA512, but they are distinct as the TLS1.3 protocol"]
#[doc = "      treats them differently."]
#[doc = " @GNUTLS_SIGN_RSA_PSS_SHA256: Digital signature algorithm RSA with SHA-256, with PSS padding (RSA-PSS certificate)."]
#[doc = " @GNUTLS_SIGN_RSA_PSS_SHA384: Digital signature algorithm RSA with SHA-384, with PSS padding (RSA-PSS certificate)."]
#[doc = " @GNUTLS_SIGN_RSA_PSS_SHA512: Digital signature algorithm RSA with SHA-512, with PSS padding (RSA-PSS certificate)."]
#[doc = " @GNUTLS_SIGN_EDDSA_ED25519: Digital signature algorithm EdDSA with Ed25519 curve."]
#[doc = " @GNUTLS_SIGN_GOST_94: Digital signature algorithm GOST R 34.10-2001 with GOST R 34.11-94"]
#[doc = " @GNUTLS_SIGN_GOST_256: Digital signature algorithm GOST R 34.10-2012 with GOST R 34.11-2012 256 bit"]
#[doc = " @GNUTLS_SIGN_GOST_512: Digital signature algorithm GOST R 34.10-2012 with GOST R 34.11-2012 512 bit"]
#[doc = " @GNUTLS_SIGN_EDDSA_ED448: Digital signature algorithm EdDSA with Ed448 curve."]
#[doc = ""]
#[doc = " Enumeration of different digital signature algorithms."]
pub type gnutls_sign_algorithm_t = ::std::os::raw::c_uint;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_INVALID: gnutls_ecc_curve_t = 0;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_SECP224R1: gnutls_ecc_curve_t = 1;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_SECP256R1: gnutls_ecc_curve_t = 2;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_SECP384R1: gnutls_ecc_curve_t = 3;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_SECP521R1: gnutls_ecc_curve_t = 4;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_SECP192R1: gnutls_ecc_curve_t = 5;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_X25519: gnutls_ecc_curve_t = 6;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_ED25519: gnutls_ecc_curve_t = 7;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_GOST256CPA: gnutls_ecc_curve_t = 8;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_GOST256CPB: gnutls_ecc_curve_t = 9;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_GOST256CPC: gnutls_ecc_curve_t = 10;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_GOST256CPXA: gnutls_ecc_curve_t = 11;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_GOST256CPXB: gnutls_ecc_curve_t = 12;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_GOST512A: gnutls_ecc_curve_t = 13;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_GOST512B: gnutls_ecc_curve_t = 14;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_GOST512C: gnutls_ecc_curve_t = 15;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_GOST256A: gnutls_ecc_curve_t = 16;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_GOST256B: gnutls_ecc_curve_t = 17;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_GOST256C: gnutls_ecc_curve_t = 18;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_GOST256D: gnutls_ecc_curve_t = 19;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_X448: gnutls_ecc_curve_t = 20;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_ED448: gnutls_ecc_curve_t = 21;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_MAX: gnutls_ecc_curve_t = 21;
#[doc = " gnutls_ecc_curve_t:"]
#[doc = " @GNUTLS_ECC_CURVE_INVALID: Cannot be known"]
#[doc = " @GNUTLS_ECC_CURVE_SECP192R1: the SECP192R1 curve"]
#[doc = " @GNUTLS_ECC_CURVE_SECP224R1: the SECP224R1 curve"]
#[doc = " @GNUTLS_ECC_CURVE_SECP256R1: the SECP256R1 curve"]
#[doc = " @GNUTLS_ECC_CURVE_SECP384R1: the SECP384R1 curve"]
#[doc = " @GNUTLS_ECC_CURVE_SECP521R1: the SECP521R1 curve"]
#[doc = " @GNUTLS_ECC_CURVE_X25519: the X25519 curve (ECDH only)"]
#[doc = " @GNUTLS_ECC_CURVE_ED25519: the Ed25519 curve"]
#[doc = " @GNUTLS_ECC_CURVE_GOST256CPA: GOST R 34.10 CryptoPro 256 A curve"]
#[doc = " @GNUTLS_ECC_CURVE_GOST256CPB: GOST R 34.10 CryptoPro 256 B curve"]
#[doc = " @GNUTLS_ECC_CURVE_GOST256CPC: GOST R 34.10 CryptoPro 256 C curve"]
#[doc = " @GNUTLS_ECC_CURVE_GOST256CPXA: GOST R 34.10 CryptoPro 256 XchA curve"]
#[doc = " @GNUTLS_ECC_CURVE_GOST256CPXB: GOST R 34.10 CryptoPro 256 XchB curve"]
#[doc = " @GNUTLS_ECC_CURVE_GOST512A: GOST R 34.10 TC26 512 A curve"]
#[doc = " @GNUTLS_ECC_CURVE_GOST512B: GOST R 34.10 TC26 512 B curve"]
#[doc = " @GNUTLS_ECC_CURVE_GOST512C: GOST R 34.10 TC26 512 C curve"]
#[doc = " @GNUTLS_ECC_CURVE_GOST256A: GOST R 34.10 TC26 256 A curve"]
#[doc = " @GNUTLS_ECC_CURVE_GOST256B: GOST R 34.10 TC26 256 B curve"]
#[doc = " @GNUTLS_ECC_CURVE_GOST256C: GOST R 34.10 TC26 256 C curve"]
#[doc = " @GNUTLS_ECC_CURVE_GOST256D: GOST R 34.10 TC26 256 D curve"]
#[doc = " @GNUTLS_ECC_CURVE_X448: the X448 curve (ECDH only)"]
#[doc = " @GNUTLS_ECC_CURVE_ED448: the Ed448 curve"]
#[doc = ""]
#[doc = " Enumeration of ECC curves."]
pub type gnutls_ecc_curve_t = ::std::os::raw::c_uint;
pub const gnutls_group_t_GNUTLS_GROUP_INVALID: gnutls_group_t = 0;
pub const gnutls_group_t_GNUTLS_GROUP_SECP192R1: gnutls_group_t = 5;
pub const gnutls_group_t_GNUTLS_GROUP_SECP224R1: gnutls_group_t = 1;
pub const gnutls_group_t_GNUTLS_GROUP_SECP256R1: gnutls_group_t = 2;
pub const gnutls_group_t_GNUTLS_GROUP_SECP384R1: gnutls_group_t = 3;
pub const gnutls_group_t_GNUTLS_GROUP_SECP521R1: gnutls_group_t = 4;
pub const gnutls_group_t_GNUTLS_GROUP_X25519: gnutls_group_t = 6;
pub const gnutls_group_t_GNUTLS_GROUP_X448: gnutls_group_t = 20;
pub const gnutls_group_t_GNUTLS_GROUP_GC256A: gnutls_group_t = 16;
pub const gnutls_group_t_GNUTLS_GROUP_GC256B: gnutls_group_t = 17;
pub const gnutls_group_t_GNUTLS_GROUP_GC256C: gnutls_group_t = 18;
pub const gnutls_group_t_GNUTLS_GROUP_GC256D: gnutls_group_t = 19;
pub const gnutls_group_t_GNUTLS_GROUP_GC512A: gnutls_group_t = 13;
pub const gnutls_group_t_GNUTLS_GROUP_GC512B: gnutls_group_t = 14;
pub const gnutls_group_t_GNUTLS_GROUP_GC512C: gnutls_group_t = 15;
pub const gnutls_group_t_GNUTLS_GROUP_FFDHE2048: gnutls_group_t = 256;
pub const gnutls_group_t_GNUTLS_GROUP_FFDHE3072: gnutls_group_t = 257;
pub const gnutls_group_t_GNUTLS_GROUP_FFDHE4096: gnutls_group_t = 258;
pub const gnutls_group_t_GNUTLS_GROUP_FFDHE8192: gnutls_group_t = 259;
pub const gnutls_group_t_GNUTLS_GROUP_FFDHE6144: gnutls_group_t = 260;
pub const gnutls_group_t_GNUTLS_GROUP_MAX: gnutls_group_t = 260;
#[doc = " gnutls_group_t:"]
#[doc = " @GNUTLS_GROUP_INVALID: Indicates unknown/invalid group"]
#[doc = " @GNUTLS_GROUP_SECP192R1: the SECP192R1 curve group (legacy, only for TLS 1.2 compatibility)"]
#[doc = " @GNUTLS_GROUP_SECP224R1: the SECP224R1 curve group (legacy, only for TLS 1.2 compatibility)"]
#[doc = " @GNUTLS_GROUP_SECP256R1: the SECP256R1 curve group"]
#[doc = " @GNUTLS_GROUP_SECP384R1: the SECP384R1 curve group"]
#[doc = " @GNUTLS_GROUP_SECP521R1: the SECP521R1 curve group"]
#[doc = " @GNUTLS_GROUP_X25519: the X25519 curve group"]
#[doc = " @GNUTLS_GROUP_GC256A: the GOST R 34.10 TC26 256 A curve group"]
#[doc = " @GNUTLS_GROUP_GC256B: the GOST R 34.10 TC26 256 B curve group"]
#[doc = " @GNUTLS_GROUP_GC256C: the GOST R 34.10 TC26 256 C curve group"]
#[doc = " @GNUTLS_GROUP_GC256D: the GOST R 34.10 TC26 256 D curve group"]
#[doc = " @GNUTLS_GROUP_GC512A: the GOST R 34.10 TC26 512 A curve group"]
#[doc = " @GNUTLS_GROUP_GC512B: the GOST R 34.10 TC26 512 B curve group"]
#[doc = " @GNUTLS_GROUP_GC512C: the GOST R 34.10 TC26 512 C curve group"]
#[doc = " @GNUTLS_GROUP_FFDHE2048: the FFDHE2048 group"]
#[doc = " @GNUTLS_GROUP_FFDHE3072: the FFDHE3072 group"]
#[doc = " @GNUTLS_GROUP_FFDHE4096: the FFDHE4096 group"]
#[doc = " @GNUTLS_GROUP_FFDHE6144: the FFDHE6144 group"]
#[doc = " @GNUTLS_GROUP_FFDHE8192: the FFDHE8192 group"]
#[doc = " @GNUTLS_GROUP_X448: the X448 curve group"]
#[doc = ""]
#[doc = " Enumeration of supported groups. It is intended to be backwards"]
#[doc = " compatible with the enumerations in %gnutls_ecc_curve_t for the groups"]
#[doc = " which are valid elliptic curves."]
pub type gnutls_group_t = ::std::os::raw::c_uint;
pub const gnutls_sec_param_t_GNUTLS_SEC_PARAM_UNKNOWN: gnutls_sec_param_t = 0;
pub const gnutls_sec_param_t_GNUTLS_SEC_PARAM_INSECURE: gnutls_sec_param_t = 5;
pub const gnutls_sec_param_t_GNUTLS_SEC_PARAM_EXPORT: gnutls_sec_param_t = 10;
pub const gnutls_sec_param_t_GNUTLS_SEC_PARAM_VERY_WEAK: gnutls_sec_param_t = 15;
pub const gnutls_sec_param_t_GNUTLS_SEC_PARAM_WEAK: gnutls_sec_param_t = 20;
pub const gnutls_sec_param_t_GNUTLS_SEC_PARAM_LOW: gnutls_sec_param_t = 25;
pub const gnutls_sec_param_t_GNUTLS_SEC_PARAM_LEGACY: gnutls_sec_param_t = 30;
pub const gnutls_sec_param_t_GNUTLS_SEC_PARAM_MEDIUM: gnutls_sec_param_t = 35;
pub const gnutls_sec_param_t_GNUTLS_SEC_PARAM_HIGH: gnutls_sec_param_t = 40;
pub const gnutls_sec_param_t_GNUTLS_SEC_PARAM_ULTRA: gnutls_sec_param_t = 45;
pub const gnutls_sec_param_t_GNUTLS_SEC_PARAM_FUTURE: gnutls_sec_param_t = 50;
pub const gnutls_sec_param_t_GNUTLS_SEC_PARAM_MAX: gnutls_sec_param_t = 50;
#[doc = " gnutls_sec_param_t:"]
#[doc = " @GNUTLS_SEC_PARAM_UNKNOWN: Cannot be known"]
#[doc = " @GNUTLS_SEC_PARAM_INSECURE: Less than 42 bits of security"]
#[doc = " @GNUTLS_SEC_PARAM_EXPORT: 42 bits of security"]
#[doc = " @GNUTLS_SEC_PARAM_VERY_WEAK: 64 bits of security"]
#[doc = " @GNUTLS_SEC_PARAM_WEAK: 72 bits of security"]
#[doc = " @GNUTLS_SEC_PARAM_LOW: 80 bits of security"]
#[doc = " @GNUTLS_SEC_PARAM_LEGACY: 96 bits of security"]
#[doc = " @GNUTLS_SEC_PARAM_MEDIUM: 112 bits of security (used to be %GNUTLS_SEC_PARAM_NORMAL)"]
#[doc = " @GNUTLS_SEC_PARAM_HIGH: 128 bits of security"]
#[doc = " @GNUTLS_SEC_PARAM_ULTRA: 192 bits of security"]
#[doc = " @GNUTLS_SEC_PARAM_FUTURE: 256 bits of security"]
#[doc = ""]
#[doc = " Enumeration of security parameters for passive attacks."]
pub type gnutls_sec_param_t = ::std::os::raw::c_uint;
pub const gnutls_channel_binding_t_GNUTLS_CB_TLS_UNIQUE: gnutls_channel_binding_t = 0;
#[doc = " gnutls_channel_binding_t:"]
#[doc = " @GNUTLS_CB_TLS_UNIQUE: \"tls-unique\" (RFC 5929) channel binding"]
#[doc = ""]
#[doc = " Enumeration of support channel binding types."]
pub type gnutls_channel_binding_t = ::std::os::raw::c_uint;
pub const gnutls_gost_paramset_t_GNUTLS_GOST_PARAMSET_UNKNOWN: gnutls_gost_paramset_t = 0;
pub const gnutls_gost_paramset_t_GNUTLS_GOST_PARAMSET_TC26_Z: gnutls_gost_paramset_t = 1;
pub const gnutls_gost_paramset_t_GNUTLS_GOST_PARAMSET_CP_A: gnutls_gost_paramset_t = 2;
pub const gnutls_gost_paramset_t_GNUTLS_GOST_PARAMSET_CP_B: gnutls_gost_paramset_t = 3;
pub const gnutls_gost_paramset_t_GNUTLS_GOST_PARAMSET_CP_C: gnutls_gost_paramset_t = 4;
pub const gnutls_gost_paramset_t_GNUTLS_GOST_PARAMSET_CP_D: gnutls_gost_paramset_t = 5;
#[doc = " gnutls_gost_paramset_t:"]
#[doc = " @GNUTLS_GOST_PARAMSET_UNKNOWN: Unknown/default parameter set"]
#[doc = " @GNUTLS_GOST_PARAMSET_TC26_Z: Specified by TC26, see rfc7836"]
#[doc = " @GNUTLS_GOST_PARAMSET_CP_A: CryptoPro-A, see rfc4357"]
#[doc = " @GNUTLS_GOST_PARAMSET_CP_B: CryptoPro-B, see rfc4357"]
#[doc = " @GNUTLS_GOST_PARAMSET_CP_C: CryptoPro-C, see rfc4357"]
#[doc = " @GNUTLS_GOST_PARAMSET_CP_D: CryptoPro-D, see rfc4357"]
#[doc = ""]
#[doc = " Enumeration of different GOST 28147 parameter sets."]
pub type gnutls_gost_paramset_t = ::std::os::raw::c_uint;
pub const gnutls_ctype_target_t_GNUTLS_CTYPE_CLIENT: gnutls_ctype_target_t = 0;
pub const gnutls_ctype_target_t_GNUTLS_CTYPE_SERVER: gnutls_ctype_target_t = 1;
pub const gnutls_ctype_target_t_GNUTLS_CTYPE_OURS: gnutls_ctype_target_t = 2;
pub const gnutls_ctype_target_t_GNUTLS_CTYPE_PEERS: gnutls_ctype_target_t = 3;
#[doc = " gnutls_ctype_target_t:"]
#[doc = " @GNUTLS_CTYPE_CLIENT: for requesting client certificate type values."]
#[doc = " @GNUTLS_CTYPE_SERVER: for requesting server certificate type values."]
#[doc = " @GNUTLS_CTYPE_OURS: for requesting our certificate type values."]
#[doc = " @GNUTLS_CTYPE_PEERS: for requesting the peers' certificate type values."]
#[doc = ""]
#[doc = " Enumeration of certificate type targets with respect to asymmetric"]
#[doc = " certificate types as specified in RFC7250 and P2P connection set up"]
#[doc = " as specified in draft-vanrein-tls-symmetry-02."]
pub type gnutls_ctype_target_t = ::std::os::raw::c_uint;
pub type gnutls_transport_ptr_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_session_int {
    _unused: [u8; 0],
}
pub type gnutls_session_t = *mut gnutls_session_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_dh_params_int {
    _unused: [u8; 0],
}
pub type gnutls_dh_params_t = *mut gnutls_dh_params_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_x509_privkey_int {
    _unused: [u8; 0],
}
pub type gnutls_rsa_params_t = *mut gnutls_x509_privkey_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_priority_st {
    _unused: [u8; 0],
}
pub type gnutls_priority_t = *mut gnutls_priority_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_datum_t {
    pub data: *mut ::std::os::raw::c_uchar,
    pub size: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_gnutls_datum_t() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_datum_t>(),
        16usize,
        concat!("Size of: ", stringify!(gnutls_datum_t))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_datum_t>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_datum_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_datum_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_datum_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_datum_t>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_datum_t),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gnutls_params_st {
    pub type_: gnutls_params_type_t,
    pub params: gnutls_params_st_params,
    pub deinit: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gnutls_params_st_params {
    pub dh: gnutls_dh_params_t,
    pub rsa_export: gnutls_rsa_params_t,
}
#[test]
fn bindgen_test_layout_gnutls_params_st_params() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_params_st_params>(),
        8usize,
        concat!("Size of: ", stringify!(gnutls_params_st_params))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_params_st_params>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_params_st_params))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_params_st_params>())).dh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_params_st_params),
            "::",
            stringify!(dh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gnutls_params_st_params>())).rsa_export as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_params_st_params),
            "::",
            stringify!(rsa_export)
        )
    );
}
#[test]
fn bindgen_test_layout_gnutls_params_st() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_params_st>(),
        24usize,
        concat!("Size of: ", stringify!(gnutls_params_st))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_params_st>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_params_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_params_st>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_params_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_params_st>())).params as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_params_st),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_params_st>())).deinit as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_params_st),
            "::",
            stringify!(deinit)
        )
    );
}
pub type gnutls_params_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_session_t,
        arg2: gnutls_params_type_t,
        arg3: *mut gnutls_params_st,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_init(
        session: *mut gnutls_session_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_deinit(session: gnutls_session_t);
}
extern "C" {
    pub fn gnutls_bye(
        session: gnutls_session_t,
        how: gnutls_close_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_handshake(session: gnutls_session_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_reauth(
        session: gnutls_session_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_handshake_set_timeout(session: gnutls_session_t, ms: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn gnutls_rehandshake(session: gnutls_session_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_session_key_update(
        session: gnutls_session_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_alert_get(session: gnutls_session_t) -> gnutls_alert_description_t;
}
extern "C" {
    pub fn gnutls_alert_send(
        session: gnutls_session_t,
        level: gnutls_alert_level_t,
        desc: gnutls_alert_description_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_alert_send_appropriate(
        session: gnutls_session_t,
        err: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_alert_get_name(
        alert: gnutls_alert_description_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_alert_get_strname(
        alert: gnutls_alert_description_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_pk_bits_to_sec_param(
        algo: gnutls_pk_algorithm_t,
        bits: ::std::os::raw::c_uint,
    ) -> gnutls_sec_param_t;
}
extern "C" {
    pub fn gnutls_sec_param_get_name(param: gnutls_sec_param_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_sec_param_to_pk_bits(
        algo: gnutls_pk_algorithm_t,
        param: gnutls_sec_param_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnutls_sec_param_to_symmetric_bits(param: gnutls_sec_param_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnutls_ecc_curve_get_name(curve: gnutls_ecc_curve_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_ecc_curve_get_oid(curve: gnutls_ecc_curve_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_group_get_name(group: gnutls_group_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_ecc_curve_get_size(curve: gnutls_ecc_curve_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_ecc_curve_get(session: gnutls_session_t) -> gnutls_ecc_curve_t;
}
extern "C" {
    pub fn gnutls_group_get(session: gnutls_session_t) -> gnutls_group_t;
}
extern "C" {
    pub fn gnutls_cipher_get(session: gnutls_session_t) -> gnutls_cipher_algorithm_t;
}
extern "C" {
    pub fn gnutls_kx_get(session: gnutls_session_t) -> gnutls_kx_algorithm_t;
}
extern "C" {
    pub fn gnutls_mac_get(session: gnutls_session_t) -> gnutls_mac_algorithm_t;
}
extern "C" {
    pub fn gnutls_prf_hash_get(session: gnutls_session_t) -> gnutls_digest_algorithm_t;
}
extern "C" {
    pub fn gnutls_certificate_type_get(session: gnutls_session_t) -> gnutls_certificate_type_t;
}
extern "C" {
    pub fn gnutls_certificate_type_get2(
        session: gnutls_session_t,
        target: gnutls_ctype_target_t,
    ) -> gnutls_certificate_type_t;
}
extern "C" {
    pub fn gnutls_sign_algorithm_get(session: gnutls_session_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_sign_algorithm_get_client(session: gnutls_session_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_sign_algorithm_get_requested(
        session: gnutls_session_t,
        indx: size_t,
        algo: *mut gnutls_sign_algorithm_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_cipher_get_name(
        algorithm: gnutls_cipher_algorithm_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_mac_get_name(algorithm: gnutls_mac_algorithm_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_digest_get_name(
        algorithm: gnutls_digest_algorithm_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_digest_get_oid(
        algorithm: gnutls_digest_algorithm_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_kx_get_name(algorithm: gnutls_kx_algorithm_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_certificate_type_get_name(
        type_: gnutls_certificate_type_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_pk_get_name(algorithm: gnutls_pk_algorithm_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_pk_get_oid(algorithm: gnutls_pk_algorithm_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_sign_get_name(
        algorithm: gnutls_sign_algorithm_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_sign_get_oid(sign: gnutls_sign_algorithm_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_gost_paramset_get_name(
        param: gnutls_gost_paramset_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_gost_paramset_get_oid(
        param: gnutls_gost_paramset_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_cipher_get_key_size(algorithm: gnutls_cipher_algorithm_t) -> size_t;
}
extern "C" {
    pub fn gnutls_mac_get_key_size(algorithm: gnutls_mac_algorithm_t) -> size_t;
}
extern "C" {
    pub fn gnutls_sign_is_secure(algorithm: gnutls_sign_algorithm_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnutls_sign_is_secure2(
        algorithm: gnutls_sign_algorithm_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnutls_sign_get_hash_algorithm(
        sign: gnutls_sign_algorithm_t,
    ) -> gnutls_digest_algorithm_t;
}
extern "C" {
    pub fn gnutls_sign_get_pk_algorithm(sign: gnutls_sign_algorithm_t) -> gnutls_pk_algorithm_t;
}
extern "C" {
    pub fn gnutls_pk_to_sign(
        pk: gnutls_pk_algorithm_t,
        hash: gnutls_digest_algorithm_t,
    ) -> gnutls_sign_algorithm_t;
}
extern "C" {
    pub fn gnutls_sign_supports_pk_algorithm(
        sign: gnutls_sign_algorithm_t,
        pk: gnutls_pk_algorithm_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnutls_mac_get_id(name: *const ::std::os::raw::c_char) -> gnutls_mac_algorithm_t;
}
extern "C" {
    pub fn gnutls_digest_get_id(name: *const ::std::os::raw::c_char) -> gnutls_digest_algorithm_t;
}
extern "C" {
    pub fn gnutls_cipher_get_id(name: *const ::std::os::raw::c_char) -> gnutls_cipher_algorithm_t;
}
extern "C" {
    pub fn gnutls_kx_get_id(name: *const ::std::os::raw::c_char) -> gnutls_kx_algorithm_t;
}
extern "C" {
    pub fn gnutls_protocol_get_id(name: *const ::std::os::raw::c_char) -> gnutls_protocol_t;
}
extern "C" {
    pub fn gnutls_certificate_type_get_id(
        name: *const ::std::os::raw::c_char,
    ) -> gnutls_certificate_type_t;
}
extern "C" {
    pub fn gnutls_pk_get_id(name: *const ::std::os::raw::c_char) -> gnutls_pk_algorithm_t;
}
extern "C" {
    pub fn gnutls_sign_get_id(name: *const ::std::os::raw::c_char) -> gnutls_sign_algorithm_t;
}
extern "C" {
    pub fn gnutls_ecc_curve_get_id(name: *const ::std::os::raw::c_char) -> gnutls_ecc_curve_t;
}
extern "C" {
    pub fn gnutls_ecc_curve_get_pk(curve: gnutls_ecc_curve_t) -> gnutls_pk_algorithm_t;
}
extern "C" {
    pub fn gnutls_group_get_id(name: *const ::std::os::raw::c_char) -> gnutls_group_t;
}
extern "C" {
    pub fn gnutls_oid_to_digest(oid: *const ::std::os::raw::c_char) -> gnutls_digest_algorithm_t;
}
extern "C" {
    pub fn gnutls_oid_to_mac(oid: *const ::std::os::raw::c_char) -> gnutls_mac_algorithm_t;
}
extern "C" {
    pub fn gnutls_oid_to_pk(oid: *const ::std::os::raw::c_char) -> gnutls_pk_algorithm_t;
}
extern "C" {
    pub fn gnutls_oid_to_sign(oid: *const ::std::os::raw::c_char) -> gnutls_sign_algorithm_t;
}
extern "C" {
    pub fn gnutls_oid_to_ecc_curve(oid: *const ::std::os::raw::c_char) -> gnutls_ecc_curve_t;
}
extern "C" {
    pub fn gnutls_oid_to_gost_paramset(
        oid: *const ::std::os::raw::c_char,
    ) -> gnutls_gost_paramset_t;
}
extern "C" {
    pub fn gnutls_ecc_curve_list() -> *const gnutls_ecc_curve_t;
}
extern "C" {
    pub fn gnutls_group_list() -> *const gnutls_group_t;
}
extern "C" {
    pub fn gnutls_cipher_list() -> *const gnutls_cipher_algorithm_t;
}
extern "C" {
    pub fn gnutls_mac_list() -> *const gnutls_mac_algorithm_t;
}
extern "C" {
    pub fn gnutls_digest_list() -> *const gnutls_digest_algorithm_t;
}
extern "C" {
    pub fn gnutls_protocol_list() -> *const gnutls_protocol_t;
}
extern "C" {
    pub fn gnutls_certificate_type_list() -> *const gnutls_certificate_type_t;
}
extern "C" {
    pub fn gnutls_kx_list() -> *const gnutls_kx_algorithm_t;
}
extern "C" {
    pub fn gnutls_pk_list() -> *const gnutls_pk_algorithm_t;
}
extern "C" {
    pub fn gnutls_sign_list() -> *const gnutls_sign_algorithm_t;
}
extern "C" {
    pub fn gnutls_cipher_suite_info(
        idx: size_t,
        cs_id: *mut ::std::os::raw::c_uchar,
        kx: *mut gnutls_kx_algorithm_t,
        cipher: *mut gnutls_cipher_algorithm_t,
        mac: *mut gnutls_mac_algorithm_t,
        min_version: *mut gnutls_protocol_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_error_is_fatal(error: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_error_to_alert(
        err: ::std::os::raw::c_int,
        level: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_perror(error: ::std::os::raw::c_int);
}
extern "C" {
    pub fn gnutls_strerror(error: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_strerror_name(error: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_handshake_set_private_extensions(
        session: gnutls_session_t,
        allow: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn gnutls_handshake_set_random(
        session: gnutls_session_t,
        random: *const gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_handshake_get_last_out(
        session: gnutls_session_t,
    ) -> gnutls_handshake_description_t;
}
extern "C" {
    pub fn gnutls_handshake_get_last_in(
        session: gnutls_session_t,
    ) -> gnutls_handshake_description_t;
}
extern "C" {
    pub fn gnutls_heartbeat_ping(
        session: gnutls_session_t,
        data_size: size_t,
        max_tries: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_heartbeat_pong(
        session: gnutls_session_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_record_set_timeout(session: gnutls_session_t, ms: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn gnutls_record_disable_padding(session: gnutls_session_t);
}
extern "C" {
    pub fn gnutls_record_cork(session: gnutls_session_t);
}
extern "C" {
    pub fn gnutls_record_uncork(
        session: gnutls_session_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_record_discard_queued(session: gnutls_session_t) -> size_t;
}
extern "C" {
    pub fn gnutls_record_get_state(
        session: gnutls_session_t,
        read: ::std::os::raw::c_uint,
        mac_key: *mut gnutls_datum_t,
        IV: *mut gnutls_datum_t,
        cipher_key: *mut gnutls_datum_t,
        seq_number: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_record_set_state(
        session: gnutls_session_t,
        read: ::std::os::raw::c_uint,
        seq_number: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_range_st {
    pub low: size_t,
    pub high: size_t,
}
#[test]
fn bindgen_test_layout_gnutls_range_st() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_range_st>(),
        16usize,
        concat!("Size of: ", stringify!(gnutls_range_st))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_range_st>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_range_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_range_st>())).low as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_range_st),
            "::",
            stringify!(low)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_range_st>())).high as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_range_st),
            "::",
            stringify!(high)
        )
    );
}
extern "C" {
    pub fn gnutls_range_split(
        session: gnutls_session_t,
        orig: *const gnutls_range_st,
        small_range: *mut gnutls_range_st,
        rem_range: *mut gnutls_range_st,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_record_send(
        session: gnutls_session_t,
        data: *const ::std::os::raw::c_void,
        data_size: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn gnutls_record_send2(
        session: gnutls_session_t,
        data: *const ::std::os::raw::c_void,
        data_size: size_t,
        pad: size_t,
        flags: ::std::os::raw::c_uint,
    ) -> ssize_t;
}
extern "C" {
    pub fn gnutls_record_send_range(
        session: gnutls_session_t,
        data: *const ::std::os::raw::c_void,
        data_size: size_t,
        range: *const gnutls_range_st,
    ) -> ssize_t;
}
extern "C" {
    pub fn gnutls_record_recv(
        session: gnutls_session_t,
        data: *mut ::std::os::raw::c_void,
        data_size: size_t,
    ) -> ssize_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbuffer_st {
    _unused: [u8; 0],
}
pub type gnutls_packet_t = *mut mbuffer_st;
extern "C" {
    pub fn gnutls_record_recv_packet(
        session: gnutls_session_t,
        packet: *mut gnutls_packet_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn gnutls_packet_get(
        packet: gnutls_packet_t,
        data: *mut gnutls_datum_t,
        sequence: *mut ::std::os::raw::c_uchar,
    );
}
extern "C" {
    pub fn gnutls_packet_deinit(packet: gnutls_packet_t);
}
extern "C" {
    pub fn gnutls_record_recv_seq(
        session: gnutls_session_t,
        data: *mut ::std::os::raw::c_void,
        data_size: size_t,
        seq: *mut ::std::os::raw::c_uchar,
    ) -> ssize_t;
}
extern "C" {
    pub fn gnutls_record_overhead_size(session: gnutls_session_t) -> size_t;
}
extern "C" {
    pub fn gnutls_est_record_overhead_size(
        version: gnutls_protocol_t,
        cipher: gnutls_cipher_algorithm_t,
        mac: gnutls_mac_algorithm_t,
        comp: gnutls_compression_method_t,
        flags: ::std::os::raw::c_uint,
    ) -> size_t;
}
extern "C" {
    pub fn gnutls_session_enable_compatibility_mode(session: gnutls_session_t);
}
extern "C" {
    pub fn gnutls_record_can_use_length_hiding(session: gnutls_session_t)
        -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnutls_record_get_direction(session: gnutls_session_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_record_get_max_size(session: gnutls_session_t) -> size_t;
}
extern "C" {
    pub fn gnutls_record_set_max_size(session: gnutls_session_t, size: size_t) -> ssize_t;
}
extern "C" {
    pub fn gnutls_record_set_max_recv_size(session: gnutls_session_t, size: size_t) -> ssize_t;
}
extern "C" {
    pub fn gnutls_record_check_pending(session: gnutls_session_t) -> size_t;
}
extern "C" {
    pub fn gnutls_record_check_corked(session: gnutls_session_t) -> size_t;
}
extern "C" {
    pub fn gnutls_record_get_max_early_data_size(session: gnutls_session_t) -> size_t;
}
extern "C" {
    pub fn gnutls_record_set_max_early_data_size(
        session: gnutls_session_t,
        size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_record_send_early_data(
        session: gnutls_session_t,
        data: *const ::std::os::raw::c_void,
        length: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn gnutls_record_recv_early_data(
        session: gnutls_session_t,
        data: *mut ::std::os::raw::c_void,
        data_size: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn gnutls_session_force_valid(session: gnutls_session_t);
}
extern "C" {
    pub fn gnutls_prf(
        session: gnutls_session_t,
        label_size: size_t,
        label: *const ::std::os::raw::c_char,
        server_random_first: ::std::os::raw::c_int,
        extra_size: size_t,
        extra: *const ::std::os::raw::c_char,
        outsize: size_t,
        out: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_prf_rfc5705(
        session: gnutls_session_t,
        label_size: size_t,
        label: *const ::std::os::raw::c_char,
        context_size: size_t,
        context: *const ::std::os::raw::c_char,
        outsize: size_t,
        out: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_prf_early(
        session: gnutls_session_t,
        label_size: size_t,
        label: *const ::std::os::raw::c_char,
        context_size: size_t,
        context: *const ::std::os::raw::c_char,
        outsize: size_t,
        out: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_prf_raw(
        session: gnutls_session_t,
        label_size: size_t,
        label: *const ::std::os::raw::c_char,
        seed_size: size_t,
        seed: *const ::std::os::raw::c_char,
        outsize: size_t,
        out: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub const gnutls_server_name_type_t_GNUTLS_NAME_DNS: gnutls_server_name_type_t = 1;
#[doc = " gnutls_server_name_type_t:"]
#[doc = " @GNUTLS_NAME_DNS: Domain Name System name type."]
#[doc = ""]
#[doc = " Enumeration of different server name types."]
pub type gnutls_server_name_type_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn gnutls_server_name_set(
        session: gnutls_session_t,
        type_: gnutls_server_name_type_t,
        name: *const ::std::os::raw::c_void,
        name_length: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_server_name_get(
        session: gnutls_session_t,
        data: *mut ::std::os::raw::c_void,
        data_length: *mut size_t,
        type_: *mut ::std::os::raw::c_uint,
        indx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_heartbeat_get_timeout(session: gnutls_session_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnutls_heartbeat_set_timeouts(
        session: gnutls_session_t,
        retrans_timeout: ::std::os::raw::c_uint,
        total_timeout: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn gnutls_heartbeat_enable(session: gnutls_session_t, type_: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn gnutls_heartbeat_allowed(
        session: gnutls_session_t,
        type_: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnutls_safe_renegotiation_status(session: gnutls_session_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnutls_session_ext_master_secret_status(
        session: gnutls_session_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnutls_session_etm_status(session: gnutls_session_t) -> ::std::os::raw::c_uint;
}
pub const gnutls_session_flags_t_GNUTLS_SFLAGS_SAFE_RENEGOTIATION: gnutls_session_flags_t = 1;
pub const gnutls_session_flags_t_GNUTLS_SFLAGS_EXT_MASTER_SECRET: gnutls_session_flags_t = 2;
pub const gnutls_session_flags_t_GNUTLS_SFLAGS_ETM: gnutls_session_flags_t = 4;
pub const gnutls_session_flags_t_GNUTLS_SFLAGS_HB_LOCAL_SEND: gnutls_session_flags_t = 8;
pub const gnutls_session_flags_t_GNUTLS_SFLAGS_HB_PEER_SEND: gnutls_session_flags_t = 16;
pub const gnutls_session_flags_t_GNUTLS_SFLAGS_FALSE_START: gnutls_session_flags_t = 32;
pub const gnutls_session_flags_t_GNUTLS_SFLAGS_RFC7919: gnutls_session_flags_t = 64;
pub const gnutls_session_flags_t_GNUTLS_SFLAGS_SESSION_TICKET: gnutls_session_flags_t = 128;
pub const gnutls_session_flags_t_GNUTLS_SFLAGS_POST_HANDSHAKE_AUTH: gnutls_session_flags_t = 256;
pub const gnutls_session_flags_t_GNUTLS_SFLAGS_EARLY_START: gnutls_session_flags_t = 512;
pub const gnutls_session_flags_t_GNUTLS_SFLAGS_EARLY_DATA: gnutls_session_flags_t = 1024;
pub const gnutls_session_flags_t_GNUTLS_SFLAGS_CLI_REQUESTED_OCSP: gnutls_session_flags_t = 2048;
pub const gnutls_session_flags_t_GNUTLS_SFLAGS_SERV_REQUESTED_OCSP: gnutls_session_flags_t = 4096;
#[doc = " gnutls_session_flags_t:"]
#[doc = " @GNUTLS_SFLAGS_SAFE_RENEGOTIATION: Safe renegotiation (RFC5746) was used"]
#[doc = " @GNUTLS_SFLAGS_EXT_MASTER_SECRET: The extended master secret (RFC7627) extension was used"]
#[doc = " @GNUTLS_SFLAGS_ETM: The encrypt then MAC (RFC7366) extension was used"]
#[doc = " @GNUTLS_SFLAGS_RFC7919: The RFC7919 Diffie-Hellman parameters were negotiated"]
#[doc = " @GNUTLS_SFLAGS_HB_LOCAL_SEND: The heartbeat negotiation allows the local side to send heartbeat messages"]
#[doc = " @GNUTLS_SFLAGS_HB_PEER_SEND: The heartbeat negotiation allows the peer to send heartbeat messages"]
#[doc = " @GNUTLS_SFLAGS_FALSE_START: False start was used in this client session."]
#[doc = " @GNUTLS_SFLAGS_SESSION_TICKET: A session ticket has been received by the server."]
#[doc = " @GNUTLS_SFLAGS_POST_HANDSHAKE_AUTH: Indicates client capability for post-handshake auth; set only on server side."]
#[doc = " @GNUTLS_SFLAGS_EARLY_START: The TLS1.3 server session returned early."]
#[doc = " @GNUTLS_SFLAGS_EARLY_DATA: The TLS1.3 early data has been received by the server."]
#[doc = " @GNUTLS_SFLAGS_CLI_REQUESTED_OCSP: Set when the client has requested OCSP staple during handshake."]
#[doc = " @GNUTLS_SFLAGS_SERV_REQUESTED_OCSP: Set when the server has requested OCSP staple during handshake."]
#[doc = ""]
#[doc = " Enumeration of different session parameters."]
pub type gnutls_session_flags_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn gnutls_session_get_flags(session: gnutls_session_t) -> ::std::os::raw::c_uint;
}
pub const gnutls_supplemental_data_format_type_t_GNUTLS_SUPPLEMENTAL_UNKNOWN:
    gnutls_supplemental_data_format_type_t = 0;
#[doc = " gnutls_supplemental_data_format_type_t:"]
#[doc = " @GNUTLS_SUPPLEMENTAL_UNKNOWN: Unknown data format"]
#[doc = ""]
#[doc = " Enumeration of different supplemental data types (RFC 4680)."]
pub type gnutls_supplemental_data_format_type_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn gnutls_supplemental_get_name(
        type_: gnutls_supplemental_data_format_type_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_session_ticket_key_generate(key: *mut gnutls_datum_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_session_ticket_enable_client(session: gnutls_session_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_session_ticket_enable_server(
        session: gnutls_session_t,
        key: *const gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_session_ticket_send(
        session: gnutls_session_t,
        nr: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub const gnutls_srtp_profile_t_GNUTLS_SRTP_AES128_CM_HMAC_SHA1_80: gnutls_srtp_profile_t = 1;
pub const gnutls_srtp_profile_t_GNUTLS_SRTP_AES128_CM_HMAC_SHA1_32: gnutls_srtp_profile_t = 2;
pub const gnutls_srtp_profile_t_GNUTLS_SRTP_NULL_HMAC_SHA1_80: gnutls_srtp_profile_t = 5;
pub const gnutls_srtp_profile_t_GNUTLS_SRTP_NULL_HMAC_SHA1_32: gnutls_srtp_profile_t = 6;
#[doc = " gnutls_srtp_profile_t:"]
#[doc = " @GNUTLS_SRTP_AES128_CM_HMAC_SHA1_80: 128 bit AES with a 80 bit HMAC-SHA1"]
#[doc = " @GNUTLS_SRTP_AES128_CM_HMAC_SHA1_32: 128 bit AES with a 32 bit HMAC-SHA1"]
#[doc = " @GNUTLS_SRTP_NULL_HMAC_SHA1_80: NULL cipher with a 80 bit HMAC-SHA1"]
#[doc = " @GNUTLS_SRTP_NULL_HMAC_SHA1_32: NULL cipher with a 32 bit HMAC-SHA1"]
#[doc = ""]
#[doc = " Enumeration of different SRTP protection profiles."]
pub type gnutls_srtp_profile_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn gnutls_srtp_set_profile(
        session: gnutls_session_t,
        profile: gnutls_srtp_profile_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_srtp_set_profile_direct(
        session: gnutls_session_t,
        profiles: *const ::std::os::raw::c_char,
        err_pos: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_srtp_get_selected_profile(
        session: gnutls_session_t,
        profile: *mut gnutls_srtp_profile_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_srtp_get_profile_name(
        profile: gnutls_srtp_profile_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_srtp_get_profile_id(
        name: *const ::std::os::raw::c_char,
        profile: *mut gnutls_srtp_profile_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_srtp_get_keys(
        session: gnutls_session_t,
        key_material: *mut ::std::os::raw::c_void,
        key_material_size: ::std::os::raw::c_uint,
        client_key: *mut gnutls_datum_t,
        client_salt: *mut gnutls_datum_t,
        server_key: *mut gnutls_datum_t,
        server_salt: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_srtp_set_mki(
        session: gnutls_session_t,
        mki: *const gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_srtp_get_mki(
        session: gnutls_session_t,
        mki: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
pub const gnutls_alpn_flags_t_GNUTLS_ALPN_MANDATORY: gnutls_alpn_flags_t = 1;
pub const gnutls_alpn_flags_t_GNUTLS_ALPN_SERVER_PRECEDENCE: gnutls_alpn_flags_t = 2;
#[doc = " gnutls_alpn_flags_t:"]
#[doc = " @GNUTLS_ALPN_MANDATORY: Require ALPN negotiation. The connection will be"]
#[doc = "   aborted if no matching ALPN protocol is found."]
#[doc = " @GNUTLS_ALPN_SERVER_PRECEDENCE: The choices set by the server"]
#[doc = "   will take precedence over the client's."]
#[doc = ""]
#[doc = " Enumeration of different ALPN flags. These are used by gnutls_alpn_set_protocols()."]
pub type gnutls_alpn_flags_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn gnutls_alpn_get_selected_protocol(
        session: gnutls_session_t,
        protocol: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_alpn_set_protocols(
        session: gnutls_session_t,
        protocols: *const gnutls_datum_t,
        protocols_size: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_key_generate(
        key: *mut gnutls_datum_t,
        key_size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_priority_init(
        priority_cache: *mut gnutls_priority_t,
        priorities: *const ::std::os::raw::c_char,
        err_pos: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_priority_init2(
        priority_cache: *mut gnutls_priority_t,
        priorities: *const ::std::os::raw::c_char,
        err_pos: *mut *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_priority_deinit(priority_cache: gnutls_priority_t);
}
extern "C" {
    pub fn gnutls_priority_get_cipher_suite_index(
        pcache: gnutls_priority_t,
        idx: ::std::os::raw::c_uint,
        sidx: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_priority_string_list(
        iter: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_priority_set(
        session: gnutls_session_t,
        priority: gnutls_priority_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_priority_set_direct(
        session: gnutls_session_t,
        priorities: *const ::std::os::raw::c_char,
        err_pos: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_priority_certificate_type_list(
        pcache: gnutls_priority_t,
        list: *mut *const ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_priority_certificate_type_list2(
        pcache: gnutls_priority_t,
        list: *mut *const ::std::os::raw::c_uint,
        target: gnutls_ctype_target_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_priority_sign_list(
        pcache: gnutls_priority_t,
        list: *mut *const ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_priority_protocol_list(
        pcache: gnutls_priority_t,
        list: *mut *const ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_priority_ecc_curve_list(
        pcache: gnutls_priority_t,
        list: *mut *const ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_priority_group_list(
        pcache: gnutls_priority_t,
        list: *mut *const ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_priority_kx_list(
        pcache: gnutls_priority_t,
        list: *mut *const ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_priority_cipher_list(
        pcache: gnutls_priority_t,
        list: *mut *const ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_priority_mac_list(
        pcache: gnutls_priority_t,
        list: *mut *const ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_get_system_config_file() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_set_default_priority(session: gnutls_session_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_set_default_priority_append(
        session: gnutls_session_t,
        add_prio: *const ::std::os::raw::c_char,
        err_pos: *mut *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_cipher_suite_get_name(
        kx_algorithm: gnutls_kx_algorithm_t,
        cipher_algorithm: gnutls_cipher_algorithm_t,
        mac_algorithm: gnutls_mac_algorithm_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_protocol_get_version(session: gnutls_session_t) -> gnutls_protocol_t;
}
extern "C" {
    pub fn gnutls_protocol_get_name(version: gnutls_protocol_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_session_set_data(
        session: gnutls_session_t,
        session_data: *const ::std::os::raw::c_void,
        session_data_size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_session_get_data(
        session: gnutls_session_t,
        session_data: *mut ::std::os::raw::c_void,
        session_data_size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_session_get_data2(
        session: gnutls_session_t,
        data: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_session_get_random(
        session: gnutls_session_t,
        client: *mut gnutls_datum_t,
        server: *mut gnutls_datum_t,
    );
}
extern "C" {
    pub fn gnutls_session_get_master_secret(session: gnutls_session_t, secret: *mut gnutls_datum_t);
}
extern "C" {
    pub fn gnutls_session_get_desc(session: gnutls_session_t) -> *mut ::std::os::raw::c_char;
}
pub type gnutls_certificate_verify_function =
    ::std::option::Option<unsafe extern "C" fn(arg1: gnutls_session_t) -> ::std::os::raw::c_int>;
extern "C" {
    pub fn gnutls_session_set_verify_function(
        session: gnutls_session_t,
        func: gnutls_certificate_verify_function,
    );
}
pub const gnutls_vdata_types_t_GNUTLS_DT_UNKNOWN: gnutls_vdata_types_t = 0;
pub const gnutls_vdata_types_t_GNUTLS_DT_DNS_HOSTNAME: gnutls_vdata_types_t = 1;
pub const gnutls_vdata_types_t_GNUTLS_DT_KEY_PURPOSE_OID: gnutls_vdata_types_t = 2;
pub const gnutls_vdata_types_t_GNUTLS_DT_RFC822NAME: gnutls_vdata_types_t = 3;
pub const gnutls_vdata_types_t_GNUTLS_DT_IP_ADDRESS: gnutls_vdata_types_t = 4;
#[doc = " gnutls_vdata_types_t:"]
#[doc = " @GNUTLS_DT_UNKNOWN: Unknown data type."]
#[doc = " @GNUTLS_DT_DNS_HOSTNAME: The data contain a null-terminated DNS hostname; the hostname will be"]
#[doc = "   matched using the RFC6125 rules. If the data contain a textual IP (v4 or v6) address it will"]
#[doc = "   be marched against the IPAddress Alternative name, unless the verification flag %GNUTLS_VERIFY_DO_NOT_ALLOW_IP_MATCHES"]
#[doc = "   is specified."]
#[doc = " @GNUTLS_DT_IP_ADDRESS: The data contain a raw IP address (4 or 16 bytes). If will be matched"]
#[doc = "   against the IPAddress Alternative name; option available since 3.6.0."]
#[doc = " @GNUTLS_DT_RFC822NAME: The data contain a null-terminated email address; the email will be"]
#[doc = "   matched against the RFC822Name Alternative name of the certificate, or the EMAIL DN component if the"]
#[doc = "   former isn't available. Prior to matching the email address will be converted to ACE"]
#[doc = "   (ASCII-compatible-encoding)."]
#[doc = " @GNUTLS_DT_KEY_PURPOSE_OID: The data contain a null-terminated key purpose OID. It will be matched"]
#[doc = "   against the certificate's Extended Key Usage extension."]
#[doc = ""]
#[doc = " Enumeration of different typed-data options. They are used as input to certificate"]
#[doc = " verification functions to provide information about the name and purpose of the"]
#[doc = " certificate. Only a single option of a type can be provided to the relevant functions"]
#[doc = " (i.e., options %GNUTLS_DT_DNS_HOSTNAME, %GNUTLS_DT_IP_ADDRESS and"]
#[doc = " %GNUTLS_DT_RFC822NAME cannot be combined)."]
pub type gnutls_vdata_types_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_typed_vdata_st {
    pub type_: gnutls_vdata_types_t,
    pub data: *mut ::std::os::raw::c_uchar,
    pub size: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_gnutls_typed_vdata_st() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_typed_vdata_st>(),
        24usize,
        concat!("Size of: ", stringify!(gnutls_typed_vdata_st))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_typed_vdata_st>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_typed_vdata_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_typed_vdata_st>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_typed_vdata_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_typed_vdata_st>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_typed_vdata_st),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_typed_vdata_st>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_typed_vdata_st),
            "::",
            stringify!(size)
        )
    );
}
extern "C" {
    pub fn gnutls_session_set_verify_cert(
        session: gnutls_session_t,
        hostname: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn gnutls_session_set_verify_cert2(
        session: gnutls_session_t,
        data: *mut gnutls_typed_vdata_st,
        elements: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn gnutls_session_get_verify_cert_status(arg1: gnutls_session_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnutls_session_set_premaster(
        session: gnutls_session_t,
        entity: ::std::os::raw::c_uint,
        version: gnutls_protocol_t,
        kx: gnutls_kx_algorithm_t,
        cipher: gnutls_cipher_algorithm_t,
        mac: gnutls_mac_algorithm_t,
        comp: gnutls_compression_method_t,
        master: *const gnutls_datum_t,
        session_id: *const gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_session_get_id(
        session: gnutls_session_t,
        session_id: *mut ::std::os::raw::c_void,
        session_id_size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_session_get_id2(
        session: gnutls_session_t,
        session_id: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_session_set_id(
        session: gnutls_session_t,
        sid: *const gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_session_channel_binding(
        session: gnutls_session_t,
        cbtype: gnutls_channel_binding_t,
        cb: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_session_is_resumed(session: gnutls_session_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_session_resumption_requested(session: gnutls_session_t) -> ::std::os::raw::c_int;
}
pub type gnutls_db_store_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        key: gnutls_datum_t,
        data: gnutls_datum_t,
    ) -> ::std::os::raw::c_int,
>;
pub type gnutls_db_remove_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        key: gnutls_datum_t,
    ) -> ::std::os::raw::c_int,
>;
pub type gnutls_db_retr_func = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, key: gnutls_datum_t) -> gnutls_datum_t,
>;
extern "C" {
    pub fn gnutls_db_set_cache_expiration(
        session: gnutls_session_t,
        seconds: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn gnutls_db_get_default_cache_expiration() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnutls_db_remove_session(session: gnutls_session_t);
}
extern "C" {
    pub fn gnutls_db_set_retrieve_function(
        session: gnutls_session_t,
        retr_func: gnutls_db_retr_func,
    );
}
extern "C" {
    pub fn gnutls_db_set_remove_function(
        session: gnutls_session_t,
        rem_func: gnutls_db_remove_func,
    );
}
extern "C" {
    pub fn gnutls_db_set_store_function(
        session: gnutls_session_t,
        store_func: gnutls_db_store_func,
    );
}
extern "C" {
    pub fn gnutls_db_set_ptr(session: gnutls_session_t, ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn gnutls_db_get_ptr(session: gnutls_session_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gnutls_db_check_entry(
        session: gnutls_session_t,
        session_entry: gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_db_check_entry_time(entry: *mut gnutls_datum_t) -> time_t;
}
extern "C" {
    pub fn gnutls_db_check_entry_expire_time(entry: *mut gnutls_datum_t) -> time_t;
}
pub type gnutls_handshake_hook_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_session_t,
        htype: ::std::os::raw::c_uint,
        when: ::std::os::raw::c_uint,
        incoming: ::std::os::raw::c_uint,
        msg: *const gnutls_datum_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_handshake_set_hook_function(
        session: gnutls_session_t,
        htype: ::std::os::raw::c_uint,
        when: ::std::os::raw::c_int,
        func: gnutls_handshake_hook_func,
    );
}
pub type gnutls_handshake_simple_hook_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: gnutls_session_t) -> ::std::os::raw::c_int>;
extern "C" {
    pub fn gnutls_handshake_set_post_client_hello_function(
        session: gnutls_session_t,
        func: gnutls_handshake_simple_hook_func,
    );
}
extern "C" {
    pub fn gnutls_handshake_set_max_packet_length(session: gnutls_session_t, max: size_t);
}
extern "C" {
    pub fn gnutls_check_version(
        req_version: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_credentials_clear(session: gnutls_session_t);
}
extern "C" {
    pub fn gnutls_credentials_set(
        session: gnutls_session_t,
        type_: gnutls_credentials_type_t,
        cred: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_credentials_get(
        session: gnutls_session_t,
        type_: gnutls_credentials_type_t,
        cred: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_pubkey_st {
    _unused: [u8; 0],
}
pub type gnutls_pubkey_t = *mut gnutls_pubkey_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_privkey_st {
    _unused: [u8; 0],
}
pub type gnutls_privkey_t = *mut gnutls_privkey_st;
pub type gnutls_x509_privkey_t = *mut gnutls_x509_privkey_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_x509_crl_int {
    _unused: [u8; 0],
}
pub type gnutls_x509_crl_t = *mut gnutls_x509_crl_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_x509_crt_int {
    _unused: [u8; 0],
}
pub type gnutls_x509_crt_t = *mut gnutls_x509_crt_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_x509_crq_int {
    _unused: [u8; 0],
}
pub type gnutls_x509_crq_t = *mut gnutls_x509_crq_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_openpgp_keyring_int {
    _unused: [u8; 0],
}
pub type gnutls_openpgp_keyring_t = *mut gnutls_openpgp_keyring_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_certificate_credentials_st {
    _unused: [u8; 0],
}
pub type gnutls_certificate_credentials_t = *mut gnutls_certificate_credentials_st;
pub type gnutls_certificate_server_credentials = gnutls_certificate_credentials_t;
pub type gnutls_certificate_client_credentials = gnutls_certificate_credentials_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_anon_server_credentials_st {
    _unused: [u8; 0],
}
pub type gnutls_anon_server_credentials_t = *mut gnutls_anon_server_credentials_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_anon_client_credentials_st {
    _unused: [u8; 0],
}
pub type gnutls_anon_client_credentials_t = *mut gnutls_anon_client_credentials_st;
extern "C" {
    pub fn gnutls_anon_free_server_credentials(sc: gnutls_anon_server_credentials_t);
}
extern "C" {
    pub fn gnutls_anon_allocate_server_credentials(
        sc: *mut gnutls_anon_server_credentials_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_anon_set_server_dh_params(
        res: gnutls_anon_server_credentials_t,
        dh_params: gnutls_dh_params_t,
    );
}
extern "C" {
    pub fn gnutls_anon_set_server_known_dh_params(
        res: gnutls_anon_server_credentials_t,
        sec_param: gnutls_sec_param_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_anon_set_server_params_function(
        res: gnutls_anon_server_credentials_t,
        func: gnutls_params_function,
    );
}
extern "C" {
    pub fn gnutls_anon_free_client_credentials(sc: gnutls_anon_client_credentials_t);
}
extern "C" {
    pub fn gnutls_anon_allocate_client_credentials(
        sc: *mut gnutls_anon_client_credentials_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_free_credentials(sc: gnutls_certificate_credentials_t);
}
extern "C" {
    pub fn gnutls_certificate_allocate_credentials(
        res: *mut gnutls_certificate_credentials_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_get_issuer(
        sc: gnutls_certificate_credentials_t,
        cert: gnutls_x509_crt_t,
        issuer: *mut gnutls_x509_crt_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_get_crt_raw(
        sc: gnutls_certificate_credentials_t,
        idx1: ::std::os::raw::c_uint,
        idx2: ::std::os::raw::c_uint,
        cert: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_free_keys(sc: gnutls_certificate_credentials_t);
}
extern "C" {
    pub fn gnutls_certificate_free_cas(sc: gnutls_certificate_credentials_t);
}
extern "C" {
    pub fn gnutls_certificate_free_ca_names(sc: gnutls_certificate_credentials_t);
}
extern "C" {
    pub fn gnutls_certificate_free_crls(sc: gnutls_certificate_credentials_t);
}
extern "C" {
    pub fn gnutls_certificate_set_dh_params(
        res: gnutls_certificate_credentials_t,
        dh_params: gnutls_dh_params_t,
    );
}
extern "C" {
    pub fn gnutls_certificate_set_known_dh_params(
        res: gnutls_certificate_credentials_t,
        sec_param: gnutls_sec_param_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_verify_flags(
        res: gnutls_certificate_credentials_t,
        flags: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn gnutls_certificate_get_verify_flags(
        res: gnutls_certificate_credentials_t,
    ) -> ::std::os::raw::c_uint;
}
pub const gnutls_certificate_flags_GNUTLS_CERTIFICATE_SKIP_KEY_CERT_MATCH:
    gnutls_certificate_flags = 1;
pub const gnutls_certificate_flags_GNUTLS_CERTIFICATE_API_V2: gnutls_certificate_flags = 2;
pub const gnutls_certificate_flags_GNUTLS_CERTIFICATE_SKIP_OCSP_RESPONSE_CHECK:
    gnutls_certificate_flags = 4;
pub const gnutls_certificate_flags_GNUTLS_CERTIFICATE_VERIFY_CRLS: gnutls_certificate_flags = 8;
#[doc = " gnutls_certificate_flags:"]
#[doc = " @GNUTLS_CERTIFICATE_SKIP_KEY_CERT_MATCH: Skip the key and certificate matching check."]
#[doc = " @GNUTLS_CERTIFICATE_API_V2: If set the gnutls_certificate_set_*key* functions will return an index of the added key pair instead of zero."]
#[doc = " @GNUTLS_CERTIFICATE_SKIP_OCSP_RESPONSE_CHECK: If set, the gnutls_certificate_set_ocsp_status_request_file"]
#[doc = "    function, will not check whether the response set matches any of the certificates."]
#[doc = " @GNUTLS_CERTIFICATE_VERIFY_CRLS: This will enable CRL verification when added in the certificate structure."]
#[doc = "    When used, it requires CAs to be added before CRLs."]
#[doc = ""]
#[doc = " Enumeration of different certificate credentials flags."]
pub type gnutls_certificate_flags = ::std::os::raw::c_uint;
extern "C" {
    pub fn gnutls_certificate_set_flags(
        arg1: gnutls_certificate_credentials_t,
        flags: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn gnutls_certificate_set_verify_limits(
        res: gnutls_certificate_credentials_t,
        max_bits: ::std::os::raw::c_uint,
        max_depth: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn gnutls_certificate_set_x509_system_trust(
        cred: gnutls_certificate_credentials_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_trust_file(
        cred: gnutls_certificate_credentials_t,
        cafile: *const ::std::os::raw::c_char,
        type_: gnutls_x509_crt_fmt_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_trust_dir(
        cred: gnutls_certificate_credentials_t,
        ca_dir: *const ::std::os::raw::c_char,
        type_: gnutls_x509_crt_fmt_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_trust_mem(
        res: gnutls_certificate_credentials_t,
        ca: *const gnutls_datum_t,
        type_: gnutls_x509_crt_fmt_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_crl_file(
        res: gnutls_certificate_credentials_t,
        crlfile: *const ::std::os::raw::c_char,
        type_: gnutls_x509_crt_fmt_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_crl_mem(
        res: gnutls_certificate_credentials_t,
        CRL: *const gnutls_datum_t,
        type_: gnutls_x509_crt_fmt_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_key_file(
        res: gnutls_certificate_credentials_t,
        certfile: *const ::std::os::raw::c_char,
        keyfile: *const ::std::os::raw::c_char,
        type_: gnutls_x509_crt_fmt_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_key_file2(
        res: gnutls_certificate_credentials_t,
        certfile: *const ::std::os::raw::c_char,
        keyfile: *const ::std::os::raw::c_char,
        type_: gnutls_x509_crt_fmt_t,
        pass: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_key_mem(
        res: gnutls_certificate_credentials_t,
        cert: *const gnutls_datum_t,
        key: *const gnutls_datum_t,
        type_: gnutls_x509_crt_fmt_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_key_mem2(
        res: gnutls_certificate_credentials_t,
        cert: *const gnutls_datum_t,
        key: *const gnutls_datum_t,
        type_: gnutls_x509_crt_fmt_t,
        pass: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_send_x509_rdn_sequence(
        session: gnutls_session_t,
        status: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn gnutls_certificate_set_x509_simple_pkcs12_file(
        res: gnutls_certificate_credentials_t,
        pkcs12file: *const ::std::os::raw::c_char,
        type_: gnutls_x509_crt_fmt_t,
        password: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_simple_pkcs12_mem(
        res: gnutls_certificate_credentials_t,
        p12blob: *const gnutls_datum_t,
        type_: gnutls_x509_crt_fmt_t,
        password: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_key(
        res: gnutls_certificate_credentials_t,
        cert_list: *mut gnutls_x509_crt_t,
        cert_list_size: ::std::os::raw::c_int,
        key: gnutls_x509_privkey_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_trust(
        res: gnutls_certificate_credentials_t,
        ca_list: *mut gnutls_x509_crt_t,
        ca_list_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_crl(
        res: gnutls_certificate_credentials_t,
        crl_list: *mut gnutls_x509_crl_t,
        crl_list_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_get_x509_key(
        res: gnutls_certificate_credentials_t,
        index: ::std::os::raw::c_uint,
        key: *mut gnutls_x509_privkey_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_get_x509_crt(
        res: gnutls_certificate_credentials_t,
        index: ::std::os::raw::c_uint,
        crt_list: *mut *mut gnutls_x509_crt_t,
        crt_list_size: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type gnutls_status_request_ocsp_func = ::std::option::Option<
    unsafe extern "C" fn(
        session: gnutls_session_t,
        ptr: *mut ::std::os::raw::c_void,
        ocsp_response: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_certificate_set_ocsp_status_request_function(
        res: gnutls_certificate_credentials_t,
        ocsp_func: gnutls_status_request_ocsp_func,
        ptr: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn gnutls_certificate_set_ocsp_status_request_function2(
        res: gnutls_certificate_credentials_t,
        idx: ::std::os::raw::c_uint,
        ocsp_func: gnutls_status_request_ocsp_func,
        ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_ocsp_status_request_file(
        res: gnutls_certificate_credentials_t,
        response_file: *const ::std::os::raw::c_char,
        idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_ocsp_status_request_file2(
        res: gnutls_certificate_credentials_t,
        response_file: *const ::std::os::raw::c_char,
        idx: ::std::os::raw::c_uint,
        fmt: gnutls_x509_crt_fmt_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_ocsp_status_request_mem(
        res: gnutls_certificate_credentials_t,
        resp: *const gnutls_datum_t,
        idx: ::std::os::raw::c_uint,
        fmt: gnutls_x509_crt_fmt_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_ocsp_data_st {
    pub version: ::std::os::raw::c_uint,
    pub response: gnutls_datum_t,
    pub exptime: time_t,
    pub padding: [::std::os::raw::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_gnutls_ocsp_data_st() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_ocsp_data_st>(),
        64usize,
        concat!("Size of: ", stringify!(gnutls_ocsp_data_st))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_ocsp_data_st>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_ocsp_data_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_ocsp_data_st>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_ocsp_data_st),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_ocsp_data_st>())).response as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_ocsp_data_st),
            "::",
            stringify!(response)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_ocsp_data_st>())).exptime as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_ocsp_data_st),
            "::",
            stringify!(exptime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_ocsp_data_st>())).padding as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_ocsp_data_st),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn gnutls_certificate_get_ocsp_expiration(
        sc: gnutls_certificate_credentials_t,
        idx: ::std::os::raw::c_uint,
        oidx: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> time_t;
}
extern "C" {
    pub fn gnutls_ocsp_status_request_enable_client(
        session: gnutls_session_t,
        responder_id: *mut gnutls_datum_t,
        responder_id_size: size_t,
        request_extensions: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_ocsp_status_request_get(
        session: gnutls_session_t,
        response: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_ocsp_status_request_is_checked(
        session: gnutls_session_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnutls_ocsp_status_request_get2(
        session: gnutls_session_t,
        idx: ::std::os::raw::c_uint,
        response: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_rawpk_key_mem(
        cred: gnutls_certificate_credentials_t,
        spki: *const gnutls_datum_t,
        pkey: *const gnutls_datum_t,
        format: gnutls_x509_crt_fmt_t,
        pass: *const ::std::os::raw::c_char,
        key_usage: ::std::os::raw::c_uint,
        names: *mut *const ::std::os::raw::c_char,
        names_length: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_rawpk_key_file(
        cred: gnutls_certificate_credentials_t,
        rawpkfile: *const ::std::os::raw::c_char,
        privkeyfile: *const ::std::os::raw::c_char,
        format: gnutls_x509_crt_fmt_t,
        pass: *const ::std::os::raw::c_char,
        key_usage: ::std::os::raw::c_uint,
        names: *mut *const ::std::os::raw::c_char,
        names_length: ::std::os::raw::c_uint,
        privkey_flags: ::std::os::raw::c_uint,
        pkcs11_flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_global_init() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_global_deinit();
}
#[doc = " gnutls_time_func:"]
#[doc = " @t: where to store time."]
#[doc = ""]
#[doc = " Function prototype for time()-like function.  Set with"]
#[doc = " gnutls_global_set_time_function()."]
#[doc = ""]
#[doc = " Returns: Number of seconds since the epoch, or (time_t)-1 on errors."]
pub type gnutls_time_func = ::std::option::Option<unsafe extern "C" fn(t: *mut time_t) -> time_t>;
pub type mutex_init_func = ::std::option::Option<
    unsafe extern "C" fn(mutex: *mut *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
pub type mutex_lock_func = ::std::option::Option<
    unsafe extern "C" fn(mutex: *mut *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
pub type mutex_unlock_func = ::std::option::Option<
    unsafe extern "C" fn(mutex: *mut *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
pub type mutex_deinit_func = ::std::option::Option<
    unsafe extern "C" fn(mutex: *mut *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_global_set_mutex(
        init: mutex_init_func,
        deinit: mutex_deinit_func,
        lock: mutex_lock_func,
        unlock: mutex_unlock_func,
    );
}
pub type gnutls_alloc_function =
    ::std::option::Option<unsafe extern "C" fn(arg1: size_t) -> *mut ::std::os::raw::c_void>;
pub type gnutls_calloc_function = ::std::option::Option<
    unsafe extern "C" fn(arg1: size_t, arg2: size_t) -> *mut ::std::os::raw::c_void,
>;
pub type gnutls_is_secure_function = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
pub type gnutls_free_function =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
pub type gnutls_realloc_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: size_t,
    ) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    pub fn gnutls_global_set_time_function(time_func: gnutls_time_func);
}
extern "C" {
    pub static mut gnutls_malloc: gnutls_alloc_function;
}
extern "C" {
    pub static mut gnutls_realloc: gnutls_realloc_function;
}
extern "C" {
    pub static mut gnutls_calloc: gnutls_calloc_function;
}
extern "C" {
    pub static mut gnutls_free: gnutls_free_function;
}
extern "C" {
    pub static mut gnutls_strdup: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char,
    >;
}
extern "C" {
    pub fn gnutls_memset(data: *mut ::std::os::raw::c_void, c: ::std::os::raw::c_int, size: size_t);
}
extern "C" {
    pub fn gnutls_memcmp(
        s1: *const ::std::os::raw::c_void,
        s2: *const ::std::os::raw::c_void,
        n: size_t,
    ) -> ::std::os::raw::c_int;
}
pub type gnutls_log_func = ::std::option::Option<
    unsafe extern "C" fn(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char),
>;
pub type gnutls_audit_log_func = ::std::option::Option<
    unsafe extern "C" fn(arg1: gnutls_session_t, arg2: *const ::std::os::raw::c_char),
>;
extern "C" {
    pub fn gnutls_global_set_log_function(log_func: gnutls_log_func);
}
extern "C" {
    pub fn gnutls_global_set_audit_log_function(log_func: gnutls_audit_log_func);
}
extern "C" {
    pub fn gnutls_global_set_log_level(level: ::std::os::raw::c_int);
}
#[doc = " gnutls_keylog_func:"]
#[doc = " @session: the current session"]
#[doc = " @label: the keylog label"]
#[doc = " @secret: the (const) data of the derived secret."]
#[doc = ""]
#[doc = " Function prototype for keylog hooks. It is set using"]
#[doc = " gnutls_session_set_keylog_function()."]
#[doc = ""]
#[doc = " Returns: Non zero on error."]
#[doc = " Since: 3.6.13"]
pub type gnutls_keylog_func = ::std::option::Option<
    unsafe extern "C" fn(
        session: gnutls_session_t,
        label: *const ::std::os::raw::c_char,
        secret: *const gnutls_datum_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_session_get_keylog_function(session: gnutls_session_t) -> gnutls_keylog_func;
}
extern "C" {
    pub fn gnutls_session_set_keylog_function(session: gnutls_session_t, func: gnutls_keylog_func);
}
extern "C" {
    pub fn gnutls_dh_params_init(dh_params: *mut gnutls_dh_params_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_dh_params_deinit(dh_params: gnutls_dh_params_t);
}
extern "C" {
    pub fn gnutls_dh_params_import_raw(
        dh_params: gnutls_dh_params_t,
        prime: *const gnutls_datum_t,
        generator: *const gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_dh_params_import_dsa(
        dh_params: gnutls_dh_params_t,
        key: gnutls_x509_privkey_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_dh_params_import_raw2(
        dh_params: gnutls_dh_params_t,
        prime: *const gnutls_datum_t,
        generator: *const gnutls_datum_t,
        key_bits: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_dh_params_import_raw3(
        dh_params: gnutls_dh_params_t,
        prime: *const gnutls_datum_t,
        q: *const gnutls_datum_t,
        generator: *const gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_dh_params_import_pkcs3(
        params: gnutls_dh_params_t,
        pkcs3_params: *const gnutls_datum_t,
        format: gnutls_x509_crt_fmt_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_dh_params_generate2(
        params: gnutls_dh_params_t,
        bits: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_dh_params_export_pkcs3(
        params: gnutls_dh_params_t,
        format: gnutls_x509_crt_fmt_t,
        params_data: *mut ::std::os::raw::c_uchar,
        params_data_size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_dh_params_export2_pkcs3(
        params: gnutls_dh_params_t,
        format: gnutls_x509_crt_fmt_t,
        out: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_dh_params_export_raw(
        params: gnutls_dh_params_t,
        prime: *mut gnutls_datum_t,
        generator: *mut gnutls_datum_t,
        bits: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_dh_params_cpy(
        dst: gnutls_dh_params_t,
        src: gnutls_dh_params_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: size_t,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
pub const uio_rw_UIO_READ: uio_rw = 0;
pub const uio_rw_UIO_WRITE: uio_rw = 1;
pub type uio_rw = ::std::os::raw::c_uint;
extern "C" {
    pub fn readv(
        arg1: ::std::os::raw::c_int,
        arg2: *const iovec,
        arg3: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn writev(
        arg1: ::std::os::raw::c_int,
        arg2: *const iovec,
        arg3: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn preadv(
        arg1: ::std::os::raw::c_int,
        arg2: *const iovec,
        arg3: ::std::os::raw::c_int,
        arg4: off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pwritev(
        arg1: ::std::os::raw::c_int,
        arg2: *const iovec,
        arg3: ::std::os::raw::c_int,
        arg4: off_t,
    ) -> ssize_t;
}
pub type giovec_t = iovec;
pub type gnutls_pull_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_transport_ptr_t,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
    ) -> ssize_t,
>;
pub type gnutls_push_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_transport_ptr_t,
        arg2: *const ::std::os::raw::c_void,
        arg3: size_t,
    ) -> ssize_t,
>;
extern "C" {
    pub fn gnutls_system_recv_timeout(
        ptr: gnutls_transport_ptr_t,
        ms: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type gnutls_pull_timeout_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_transport_ptr_t,
        ms: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
pub type gnutls_vec_push_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_transport_ptr_t,
        iov: *const giovec_t,
        iovcnt: ::std::os::raw::c_int,
    ) -> ssize_t,
>;
pub type gnutls_errno_func = ::std::option::Option<
    unsafe extern "C" fn(arg1: gnutls_transport_ptr_t) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_transport_set_int2(
        session: gnutls_session_t,
        r: ::std::os::raw::c_int,
        s: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn gnutls_transport_get_int2(
        session: gnutls_session_t,
        r: *mut ::std::os::raw::c_int,
        s: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn gnutls_transport_get_int(session: gnutls_session_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_transport_set_ptr(session: gnutls_session_t, ptr: gnutls_transport_ptr_t);
}
extern "C" {
    pub fn gnutls_transport_set_ptr2(
        session: gnutls_session_t,
        recv_ptr: gnutls_transport_ptr_t,
        send_ptr: gnutls_transport_ptr_t,
    );
}
extern "C" {
    pub fn gnutls_transport_get_ptr(session: gnutls_session_t) -> gnutls_transport_ptr_t;
}
extern "C" {
    pub fn gnutls_transport_get_ptr2(
        session: gnutls_session_t,
        recv_ptr: *mut gnutls_transport_ptr_t,
        send_ptr: *mut gnutls_transport_ptr_t,
    );
}
extern "C" {
    pub fn gnutls_transport_set_vec_push_function(
        session: gnutls_session_t,
        vec_func: gnutls_vec_push_func,
    );
}
extern "C" {
    pub fn gnutls_transport_set_push_function(
        session: gnutls_session_t,
        push_func: gnutls_push_func,
    );
}
extern "C" {
    pub fn gnutls_transport_set_pull_function(
        session: gnutls_session_t,
        pull_func: gnutls_pull_func,
    );
}
extern "C" {
    pub fn gnutls_transport_set_pull_timeout_function(
        session: gnutls_session_t,
        func: gnutls_pull_timeout_func,
    );
}
extern "C" {
    pub fn gnutls_transport_set_errno_function(
        session: gnutls_session_t,
        errno_func: gnutls_errno_func,
    );
}
extern "C" {
    pub fn gnutls_transport_set_errno(session: gnutls_session_t, err: ::std::os::raw::c_int);
}
extern "C" {
    pub fn gnutls_session_set_ptr(session: gnutls_session_t, ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn gnutls_session_get_ptr(session: gnutls_session_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gnutls_openpgp_send_cert(session: gnutls_session_t, status: gnutls_openpgp_crt_status_t);
}
extern "C" {
    pub fn gnutls_fingerprint(
        algo: gnutls_digest_algorithm_t,
        data: *const gnutls_datum_t,
        result: *mut ::std::os::raw::c_void,
        result_size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
pub const gnutls_random_art_GNUTLS_RANDOM_ART_OPENSSH: gnutls_random_art = 1;
#[doc = " gnutls_random_art_t:"]
#[doc = " @GNUTLS_RANDOM_ART_OPENSSH: OpenSSH-style random art."]
#[doc = ""]
#[doc = " Enumeration of different random art types."]
pub type gnutls_random_art = ::std::os::raw::c_uint;
#[doc = " gnutls_random_art_t:"]
#[doc = " @GNUTLS_RANDOM_ART_OPENSSH: OpenSSH-style random art."]
#[doc = ""]
#[doc = " Enumeration of different random art types."]
pub use self::gnutls_random_art as gnutls_random_art_t;
extern "C" {
    pub fn gnutls_random_art(
        type_: gnutls_random_art_t,
        key_type: *const ::std::os::raw::c_char,
        key_size: ::std::os::raw::c_uint,
        fpr: *mut ::std::os::raw::c_void,
        fpr_size: size_t,
        art: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_idna_map(
        input: *const ::std::os::raw::c_char,
        ilen: ::std::os::raw::c_uint,
        out: *mut gnutls_datum_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_idna_reverse_map(
        input: *const ::std::os::raw::c_char,
        ilen: ::std::os::raw::c_uint,
        out: *mut gnutls_datum_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_srp_server_credentials_st {
    _unused: [u8; 0],
}
pub type gnutls_srp_server_credentials_t = *mut gnutls_srp_server_credentials_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_srp_client_credentials_st {
    _unused: [u8; 0],
}
pub type gnutls_srp_client_credentials_t = *mut gnutls_srp_client_credentials_st;
extern "C" {
    pub fn gnutls_srp_free_client_credentials(sc: gnutls_srp_client_credentials_t);
}
extern "C" {
    pub fn gnutls_srp_allocate_client_credentials(
        sc: *mut gnutls_srp_client_credentials_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_srp_set_client_credentials(
        res: gnutls_srp_client_credentials_t,
        username: *const ::std::os::raw::c_char,
        password: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_srp_free_server_credentials(sc: gnutls_srp_server_credentials_t);
}
extern "C" {
    pub fn gnutls_srp_allocate_server_credentials(
        sc: *mut gnutls_srp_server_credentials_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_srp_set_server_credentials_file(
        res: gnutls_srp_server_credentials_t,
        password_file: *const ::std::os::raw::c_char,
        password_conf_file: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_srp_server_get_username(
        session: gnutls_session_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_srp_set_prime_bits(session: gnutls_session_t, bits: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn gnutls_srp_verifier(
        username: *const ::std::os::raw::c_char,
        password: *const ::std::os::raw::c_char,
        salt: *const gnutls_datum_t,
        generator: *const gnutls_datum_t,
        prime: *const gnutls_datum_t,
        res: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static gnutls_srp_8192_group_prime: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_srp_8192_group_generator: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_srp_4096_group_prime: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_srp_4096_group_generator: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_srp_3072_group_prime: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_srp_3072_group_generator: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_srp_2048_group_prime: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_srp_2048_group_generator: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_srp_1536_group_prime: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_srp_1536_group_generator: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_srp_1024_group_prime: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_srp_1024_group_generator: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_ffdhe_8192_group_prime: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_ffdhe_8192_group_q: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_ffdhe_8192_group_generator: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_ffdhe_8192_key_bits: ::std::os::raw::c_uint;
}
extern "C" {
    pub static gnutls_ffdhe_6144_group_prime: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_ffdhe_6144_group_q: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_ffdhe_6144_group_generator: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_ffdhe_6144_key_bits: ::std::os::raw::c_uint;
}
extern "C" {
    pub static gnutls_ffdhe_4096_group_prime: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_ffdhe_4096_group_q: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_ffdhe_4096_group_generator: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_ffdhe_4096_key_bits: ::std::os::raw::c_uint;
}
extern "C" {
    pub static gnutls_ffdhe_3072_group_prime: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_ffdhe_3072_group_q: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_ffdhe_3072_group_generator: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_ffdhe_3072_key_bits: ::std::os::raw::c_uint;
}
extern "C" {
    pub static gnutls_ffdhe_2048_group_prime: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_ffdhe_2048_group_q: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_ffdhe_2048_group_generator: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_ffdhe_2048_key_bits: ::std::os::raw::c_uint;
}
pub type gnutls_srp_server_credentials_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_session_t,
        username: *const ::std::os::raw::c_char,
        salt: *mut gnutls_datum_t,
        verifier: *mut gnutls_datum_t,
        generator: *mut gnutls_datum_t,
        prime: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_srp_set_server_credentials_function(
        cred: gnutls_srp_server_credentials_t,
        func: gnutls_srp_server_credentials_function,
    );
}
pub type gnutls_srp_client_credentials_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_session_t,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_srp_set_client_credentials_function(
        cred: gnutls_srp_client_credentials_t,
        func: gnutls_srp_client_credentials_function,
    );
}
extern "C" {
    pub fn gnutls_srp_base64_encode(
        data: *const gnutls_datum_t,
        result: *mut ::std::os::raw::c_char,
        result_size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_srp_base64_encode2(
        data: *const gnutls_datum_t,
        result: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_srp_base64_decode(
        b64_data: *const gnutls_datum_t,
        result: *mut ::std::os::raw::c_char,
        result_size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_srp_base64_decode2(
        b64_data: *const gnutls_datum_t,
        result: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_srp_set_server_fake_salt_seed(
        sc: gnutls_srp_server_credentials_t,
        seed: *const gnutls_datum_t,
        salt_length: ::std::os::raw::c_uint,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_psk_server_credentials_st {
    _unused: [u8; 0],
}
pub type gnutls_psk_server_credentials_t = *mut gnutls_psk_server_credentials_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_psk_client_credentials_st {
    _unused: [u8; 0],
}
pub type gnutls_psk_client_credentials_t = *mut gnutls_psk_client_credentials_st;
pub const gnutls_psk_key_flags_GNUTLS_PSK_KEY_RAW: gnutls_psk_key_flags = 0;
pub const gnutls_psk_key_flags_GNUTLS_PSK_KEY_HEX: gnutls_psk_key_flags = 1;
#[doc = " gnutls_psk_key_flags:"]
#[doc = " @GNUTLS_PSK_KEY_RAW: PSK-key in raw format."]
#[doc = " @GNUTLS_PSK_KEY_HEX: PSK-key in hex format."]
#[doc = ""]
#[doc = " Enumeration of different PSK key flags."]
pub type gnutls_psk_key_flags = ::std::os::raw::c_uint;
extern "C" {
    pub fn gnutls_psk_free_client_credentials(sc: gnutls_psk_client_credentials_t);
}
extern "C" {
    pub fn gnutls_psk_allocate_client_credentials(
        sc: *mut gnutls_psk_client_credentials_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_psk_set_client_credentials(
        res: gnutls_psk_client_credentials_t,
        username: *const ::std::os::raw::c_char,
        key: *const gnutls_datum_t,
        flags: gnutls_psk_key_flags,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_psk_set_client_credentials2(
        res: gnutls_psk_client_credentials_t,
        username: *const gnutls_datum_t,
        key: *const gnutls_datum_t,
        flags: gnutls_psk_key_flags,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_psk_free_server_credentials(sc: gnutls_psk_server_credentials_t);
}
extern "C" {
    pub fn gnutls_psk_allocate_server_credentials(
        sc: *mut gnutls_psk_server_credentials_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_psk_set_server_credentials_file(
        res: gnutls_psk_server_credentials_t,
        password_file: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_psk_set_server_credentials_hint(
        res: gnutls_psk_server_credentials_t,
        hint: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_psk_server_get_username(
        session: gnutls_session_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_psk_server_get_username2(
        session: gnutls_session_t,
        out: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_psk_client_get_hint(session: gnutls_session_t) -> *const ::std::os::raw::c_char;
}
pub type gnutls_psk_server_credentials_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_session_t,
        username: *const ::std::os::raw::c_char,
        key: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int,
>;
pub type gnutls_psk_server_credentials_function2 = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_session_t,
        username: *const gnutls_datum_t,
        key: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_psk_set_server_credentials_function(
        cred: gnutls_psk_server_credentials_t,
        func: gnutls_psk_server_credentials_function,
    );
}
extern "C" {
    pub fn gnutls_psk_set_server_credentials_function2(
        cred: gnutls_psk_server_credentials_t,
        func: gnutls_psk_server_credentials_function2,
    );
}
pub type gnutls_psk_client_credentials_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_session_t,
        username: *mut *mut ::std::os::raw::c_char,
        key: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int,
>;
pub type gnutls_psk_client_credentials_function2 = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_session_t,
        username: *mut gnutls_datum_t,
        key: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_psk_set_client_credentials_function(
        cred: gnutls_psk_client_credentials_t,
        func: gnutls_psk_client_credentials_function,
    );
}
extern "C" {
    pub fn gnutls_psk_set_client_credentials_function2(
        cred: gnutls_psk_client_credentials_t,
        func: gnutls_psk_client_credentials_function2,
    );
}
extern "C" {
    pub fn gnutls_hex_encode(
        data: *const gnutls_datum_t,
        result: *mut ::std::os::raw::c_char,
        result_size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_hex_decode(
        hex_data: *const gnutls_datum_t,
        result: *mut ::std::os::raw::c_void,
        result_size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_hex_encode2(
        data: *const gnutls_datum_t,
        result: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_hex_decode2(
        data: *const gnutls_datum_t,
        result: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_psk_set_server_dh_params(
        res: gnutls_psk_server_credentials_t,
        dh_params: gnutls_dh_params_t,
    );
}
extern "C" {
    pub fn gnutls_psk_set_server_known_dh_params(
        res: gnutls_psk_server_credentials_t,
        sec_param: gnutls_sec_param_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_psk_set_server_params_function(
        res: gnutls_psk_server_credentials_t,
        func: gnutls_params_function,
    );
}
pub const gnutls_x509_subject_alt_name_t_GNUTLS_SAN_DNSNAME: gnutls_x509_subject_alt_name_t = 1;
pub const gnutls_x509_subject_alt_name_t_GNUTLS_SAN_RFC822NAME: gnutls_x509_subject_alt_name_t = 2;
pub const gnutls_x509_subject_alt_name_t_GNUTLS_SAN_URI: gnutls_x509_subject_alt_name_t = 3;
pub const gnutls_x509_subject_alt_name_t_GNUTLS_SAN_IPADDRESS: gnutls_x509_subject_alt_name_t = 4;
pub const gnutls_x509_subject_alt_name_t_GNUTLS_SAN_OTHERNAME: gnutls_x509_subject_alt_name_t = 5;
pub const gnutls_x509_subject_alt_name_t_GNUTLS_SAN_DN: gnutls_x509_subject_alt_name_t = 6;
pub const gnutls_x509_subject_alt_name_t_GNUTLS_SAN_REGISTERED_ID: gnutls_x509_subject_alt_name_t =
    7;
pub const gnutls_x509_subject_alt_name_t_GNUTLS_SAN_MAX: gnutls_x509_subject_alt_name_t = 7;
pub const gnutls_x509_subject_alt_name_t_GNUTLS_SAN_OTHERNAME_XMPP: gnutls_x509_subject_alt_name_t =
    1000;
pub const gnutls_x509_subject_alt_name_t_GNUTLS_SAN_OTHERNAME_KRB5PRINCIPAL:
    gnutls_x509_subject_alt_name_t = 1001;
#[doc = " gnutls_x509_subject_alt_name_t:"]
#[doc = " @GNUTLS_SAN_DNSNAME: DNS-name SAN."]
#[doc = " @GNUTLS_SAN_RFC822NAME: E-mail address SAN."]
#[doc = " @GNUTLS_SAN_URI: URI SAN."]
#[doc = " @GNUTLS_SAN_IPADDRESS: IP address SAN."]
#[doc = " @GNUTLS_SAN_OTHERNAME: OtherName SAN."]
#[doc = " @GNUTLS_SAN_DN: DN SAN."]
#[doc = " @GNUTLS_SAN_REGISTERED_ID: RegisteredID."]
#[doc = " @GNUTLS_SAN_OTHERNAME_XMPP: Virtual SAN, used by certain functions for convenience."]
#[doc = " @GNUTLS_SAN_OTHERNAME_KRB5PRINCIPAL: Virtual SAN, used by certain functions for convenience."]
#[doc = ""]
#[doc = " Enumeration of different subject alternative names types."]
pub type gnutls_x509_subject_alt_name_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_openpgp_crt_int {
    _unused: [u8; 0],
}
pub type gnutls_openpgp_crt_t = *mut gnutls_openpgp_crt_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_openpgp_privkey_int {
    _unused: [u8; 0],
}
pub type gnutls_openpgp_privkey_t = *mut gnutls_openpgp_privkey_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_pkcs11_privkey_st {
    _unused: [u8; 0],
}
pub type gnutls_pkcs11_privkey_t = *mut gnutls_pkcs11_privkey_st;
pub const gnutls_privkey_type_t_GNUTLS_PRIVKEY_X509: gnutls_privkey_type_t = 0;
pub const gnutls_privkey_type_t_GNUTLS_PRIVKEY_OPENPGP: gnutls_privkey_type_t = 1;
pub const gnutls_privkey_type_t_GNUTLS_PRIVKEY_PKCS11: gnutls_privkey_type_t = 2;
pub const gnutls_privkey_type_t_GNUTLS_PRIVKEY_EXT: gnutls_privkey_type_t = 3;
#[doc = " gnutls_privkey_type_t:"]
#[doc = " @GNUTLS_PRIVKEY_X509: X.509 private key, #gnutls_x509_privkey_t."]
#[doc = " @GNUTLS_PRIVKEY_OPENPGP: OpenPGP private key, #gnutls_openpgp_privkey_t."]
#[doc = " @GNUTLS_PRIVKEY_PKCS11: PKCS11 private key, #gnutls_pkcs11_privkey_t."]
#[doc = " @GNUTLS_PRIVKEY_EXT: External private key, operating using callbacks."]
#[doc = ""]
#[doc = " Enumeration of different private key types."]
pub type gnutls_privkey_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gnutls_retr2_st {
    pub cert_type: gnutls_certificate_type_t,
    pub key_type: gnutls_privkey_type_t,
    pub cert: gnutls_retr2_st__bindgen_ty_1,
    pub ncerts: ::std::os::raw::c_uint,
    pub key: gnutls_retr2_st__bindgen_ty_2,
    pub deinit_all: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gnutls_retr2_st__bindgen_ty_1 {
    pub x509: *mut gnutls_x509_crt_t,
    pub pgp: gnutls_openpgp_crt_t,
}
#[test]
fn bindgen_test_layout_gnutls_retr2_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_retr2_st__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(gnutls_retr2_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_retr2_st__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_retr2_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gnutls_retr2_st__bindgen_ty_1>())).x509 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st__bindgen_ty_1),
            "::",
            stringify!(x509)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gnutls_retr2_st__bindgen_ty_1>())).pgp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st__bindgen_ty_1),
            "::",
            stringify!(pgp)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gnutls_retr2_st__bindgen_ty_2 {
    pub x509: gnutls_x509_privkey_t,
    pub pgp: gnutls_openpgp_privkey_t,
    pub pkcs11: gnutls_pkcs11_privkey_t,
}
#[test]
fn bindgen_test_layout_gnutls_retr2_st__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_retr2_st__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(gnutls_retr2_st__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_retr2_st__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_retr2_st__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gnutls_retr2_st__bindgen_ty_2>())).x509 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st__bindgen_ty_2),
            "::",
            stringify!(x509)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gnutls_retr2_st__bindgen_ty_2>())).pgp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st__bindgen_ty_2),
            "::",
            stringify!(pgp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gnutls_retr2_st__bindgen_ty_2>())).pkcs11 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st__bindgen_ty_2),
            "::",
            stringify!(pkcs11)
        )
    );
}
#[test]
fn bindgen_test_layout_gnutls_retr2_st() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_retr2_st>(),
        40usize,
        concat!("Size of: ", stringify!(gnutls_retr2_st))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_retr2_st>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_retr2_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_retr2_st>())).cert_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st),
            "::",
            stringify!(cert_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_retr2_st>())).key_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st),
            "::",
            stringify!(key_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_retr2_st>())).cert as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st),
            "::",
            stringify!(cert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_retr2_st>())).ncerts as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st),
            "::",
            stringify!(ncerts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_retr2_st>())).key as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_retr2_st>())).deinit_all as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st),
            "::",
            stringify!(deinit_all)
        )
    );
}
extern "C" {
    pub fn gnutls_auth_get_type(session: gnutls_session_t) -> gnutls_credentials_type_t;
}
extern "C" {
    pub fn gnutls_auth_server_get_type(session: gnutls_session_t) -> gnutls_credentials_type_t;
}
extern "C" {
    pub fn gnutls_auth_client_get_type(session: gnutls_session_t) -> gnutls_credentials_type_t;
}
extern "C" {
    pub fn gnutls_dh_set_prime_bits(session: gnutls_session_t, bits: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn gnutls_dh_get_secret_bits(session: gnutls_session_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_dh_get_peers_public_bits(session: gnutls_session_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_dh_get_prime_bits(session: gnutls_session_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_dh_get_group(
        session: gnutls_session_t,
        raw_gen: *mut gnutls_datum_t,
        raw_prime: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_dh_get_pubkey(
        session: gnutls_session_t,
        raw_key: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
pub type gnutls_certificate_retrieve_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_session_t,
        req_ca_rdn: *const gnutls_datum_t,
        nreqs: ::std::os::raw::c_int,
        pk_algos: *const gnutls_pk_algorithm_t,
        pk_algos_length: ::std::os::raw::c_int,
        arg2: *mut gnutls_retr2_st,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_certificate_set_retrieve_function(
        cred: gnutls_certificate_credentials_t,
        func: gnutls_certificate_retrieve_function,
    );
}
extern "C" {
    pub fn gnutls_certificate_set_verify_function(
        cred: gnutls_certificate_credentials_t,
        func: gnutls_certificate_verify_function,
    );
}
extern "C" {
    pub fn gnutls_certificate_server_set_request(
        session: gnutls_session_t,
        req: gnutls_certificate_request_t,
    );
}
extern "C" {
    pub fn gnutls_certificate_get_peers(
        session: gnutls_session_t,
        list_size: *mut ::std::os::raw::c_uint,
    ) -> *const gnutls_datum_t;
}
extern "C" {
    pub fn gnutls_certificate_get_ours(session: gnutls_session_t) -> *const gnutls_datum_t;
}
extern "C" {
    pub fn gnutls_certificate_get_peers_subkey_id(
        session: gnutls_session_t,
        id: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_activation_time_peers(session: gnutls_session_t) -> time_t;
}
extern "C" {
    pub fn gnutls_certificate_expiration_time_peers(session: gnutls_session_t) -> time_t;
}
extern "C" {
    pub fn gnutls_certificate_client_get_request_status(
        session: gnutls_session_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnutls_certificate_verify_peers2(
        session: gnutls_session_t,
        status: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_verify_peers3(
        session: gnutls_session_t,
        hostname: *const ::std::os::raw::c_char,
        status: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_verify_peers(
        session: gnutls_session_t,
        data: *mut gnutls_typed_vdata_st,
        elements: ::std::os::raw::c_uint,
        status: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_verification_status_print(
        status: ::std::os::raw::c_uint,
        type_: gnutls_certificate_type_t,
        out: *mut gnutls_datum_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_pem_base64_encode(
        msg: *const ::std::os::raw::c_char,
        data: *const gnutls_datum_t,
        result: *mut ::std::os::raw::c_char,
        result_size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_pem_base64_decode(
        header: *const ::std::os::raw::c_char,
        b64_data: *const gnutls_datum_t,
        result: *mut ::std::os::raw::c_uchar,
        result_size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_pem_base64_encode2(
        msg: *const ::std::os::raw::c_char,
        data: *const gnutls_datum_t,
        result: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_pem_base64_decode2(
        header: *const ::std::os::raw::c_char,
        b64_data: *const gnutls_datum_t,
        result: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_base64_encode2(
        data: *const gnutls_datum_t,
        result: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_base64_decode2(
        b64_data: *const gnutls_datum_t,
        result: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_params_function(
        res: gnutls_certificate_credentials_t,
        func: gnutls_params_function,
    );
}
extern "C" {
    pub fn gnutls_anon_set_params_function(
        res: gnutls_anon_server_credentials_t,
        func: gnutls_params_function,
    );
}
extern "C" {
    pub fn gnutls_psk_set_params_function(
        res: gnutls_psk_server_credentials_t,
        func: gnutls_params_function,
    );
}
extern "C" {
    pub fn gnutls_hex2bin(
        hex_data: *const ::std::os::raw::c_char,
        hex_size: size_t,
        bin_data: *mut ::std::os::raw::c_void,
        bin_size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
pub type gnutls_tdb_store_func = ::std::option::Option<
    unsafe extern "C" fn(
        db_name: *const ::std::os::raw::c_char,
        host: *const ::std::os::raw::c_char,
        service: *const ::std::os::raw::c_char,
        expiration: time_t,
        pubkey: *const gnutls_datum_t,
    ) -> ::std::os::raw::c_int,
>;
pub type gnutls_tdb_store_commitment_func = ::std::option::Option<
    unsafe extern "C" fn(
        db_name: *const ::std::os::raw::c_char,
        host: *const ::std::os::raw::c_char,
        service: *const ::std::os::raw::c_char,
        expiration: time_t,
        hash_algo: gnutls_digest_algorithm_t,
        hash: *const gnutls_datum_t,
    ) -> ::std::os::raw::c_int,
>;
pub type gnutls_tdb_verify_func = ::std::option::Option<
    unsafe extern "C" fn(
        db_name: *const ::std::os::raw::c_char,
        host: *const ::std::os::raw::c_char,
        service: *const ::std::os::raw::c_char,
        pubkey: *const gnutls_datum_t,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_tdb_int {
    _unused: [u8; 0],
}
pub type gnutls_tdb_t = *mut gnutls_tdb_int;
extern "C" {
    pub fn gnutls_tdb_init(tdb: *mut gnutls_tdb_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_tdb_set_store_func(tdb: gnutls_tdb_t, store: gnutls_tdb_store_func);
}
extern "C" {
    pub fn gnutls_tdb_set_store_commitment_func(
        tdb: gnutls_tdb_t,
        cstore: gnutls_tdb_store_commitment_func,
    );
}
extern "C" {
    pub fn gnutls_tdb_set_verify_func(tdb: gnutls_tdb_t, verify: gnutls_tdb_verify_func);
}
extern "C" {
    pub fn gnutls_tdb_deinit(tdb: gnutls_tdb_t);
}
extern "C" {
    pub fn gnutls_verify_stored_pubkey(
        db_name: *const ::std::os::raw::c_char,
        tdb: gnutls_tdb_t,
        host: *const ::std::os::raw::c_char,
        service: *const ::std::os::raw::c_char,
        cert_type: gnutls_certificate_type_t,
        cert: *const gnutls_datum_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_store_commitment(
        db_name: *const ::std::os::raw::c_char,
        tdb: gnutls_tdb_t,
        host: *const ::std::os::raw::c_char,
        service: *const ::std::os::raw::c_char,
        hash_algo: gnutls_digest_algorithm_t,
        hash: *const gnutls_datum_t,
        expiration: time_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_store_pubkey(
        db_name: *const ::std::os::raw::c_char,
        tdb: gnutls_tdb_t,
        host: *const ::std::os::raw::c_char,
        service: *const ::std::os::raw::c_char,
        cert_type: gnutls_certificate_type_t,
        cert: *const gnutls_datum_t,
        expiration: time_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_load_file(
        filename: *const ::std::os::raw::c_char,
        data: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_url_is_supported(url: *const ::std::os::raw::c_char) -> ::std::os::raw::c_uint;
}
pub const gnutls_pin_flag_t_GNUTLS_PIN_USER: gnutls_pin_flag_t = 1;
pub const gnutls_pin_flag_t_GNUTLS_PIN_SO: gnutls_pin_flag_t = 2;
pub const gnutls_pin_flag_t_GNUTLS_PIN_FINAL_TRY: gnutls_pin_flag_t = 4;
pub const gnutls_pin_flag_t_GNUTLS_PIN_COUNT_LOW: gnutls_pin_flag_t = 8;
pub const gnutls_pin_flag_t_GNUTLS_PIN_CONTEXT_SPECIFIC: gnutls_pin_flag_t = 16;
pub const gnutls_pin_flag_t_GNUTLS_PIN_WRONG: gnutls_pin_flag_t = 32;
#[doc = " gnutls_pin_flag_t:"]
#[doc = " @GNUTLS_PIN_USER: The PIN for the user."]
#[doc = " @GNUTLS_PIN_SO: The PIN for the security officer (admin)."]
#[doc = " @GNUTLS_PIN_CONTEXT_SPECIFIC: The PIN is for a specific action and key like signing."]
#[doc = " @GNUTLS_PIN_FINAL_TRY: This is the final try before blocking."]
#[doc = " @GNUTLS_PIN_COUNT_LOW: Few tries remain before token blocks."]
#[doc = " @GNUTLS_PIN_WRONG: Last given PIN was not correct."]
#[doc = ""]
#[doc = " Enumeration of different flags that are input to the PIN function."]
pub type gnutls_pin_flag_t = ::std::os::raw::c_uint;
#[doc = " gnutls_pin_callback_t:"]
#[doc = " @userdata: user-controlled data from gnutls_pkcs11_set_pin_function()."]
#[doc = " @attempt: pin-attempt counter, initially 0."]
#[doc = " @token_url: URL of token."]
#[doc = " @token_label: label of token."]
#[doc = " @flags: a #gnutls_pin_flag_t flag."]
#[doc = " @pin: buffer to hold PIN, of size @pin_max."]
#[doc = " @pin_max: size of @pin buffer."]
#[doc = ""]
#[doc = " Callback function type for PKCS#11 or TPM PIN entry.  It is set by"]
#[doc = " functions like gnutls_pkcs11_set_pin_function()."]
#[doc = ""]
#[doc = " The callback should provides the PIN code to unlock the token with"]
#[doc = " label @token_label, specified by the URL @token_url."]
#[doc = ""]
#[doc = " The PIN code, as a NUL-terminated ASCII string, should be copied"]
#[doc = " into the @pin buffer (of maximum size @pin_max), and return 0 to"]
#[doc = " indicate success.  Alternatively, the callback may return a"]
#[doc = " negative gnutls error code to indicate failure and cancel PIN entry"]
#[doc = " (in which case, the contents of the @pin parameter are ignored)."]
#[doc = ""]
#[doc = " When a PIN is required, the callback will be invoked repeatedly"]
#[doc = " (and indefinitely) until either the returned PIN code is correct,"]
#[doc = " the callback returns failure, or the token refuses login (e.g. when"]
#[doc = " the token is locked due to too many incorrect PINs!).  For the"]
#[doc = " first such invocation, the @attempt counter will have value zero;"]
#[doc = " it will increase by one for each subsequent attempt."]
#[doc = ""]
#[doc = " Returns: %GNUTLS_E_SUCCESS (0) on success or a negative error code on error."]
#[doc = ""]
#[doc = " Since: 2.12.0"]
pub type gnutls_pin_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        userdata: *mut ::std::os::raw::c_void,
        attempt: ::std::os::raw::c_int,
        token_url: *const ::std::os::raw::c_char,
        token_label: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
        pin: *mut ::std::os::raw::c_char,
        pin_max: size_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_certificate_set_pin_function(
        arg1: gnutls_certificate_credentials_t,
        fn_: gnutls_pin_callback_t,
        userdata: *mut ::std::os::raw::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_buffer_st {
    _unused: [u8; 0],
}
pub type gnutls_buffer_t = *mut gnutls_buffer_st;
extern "C" {
    pub fn gnutls_buffer_append_data(
        arg1: gnutls_buffer_t,
        data: *const ::std::os::raw::c_void,
        data_size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_utf8_password_normalize(
        password: *const ::std::os::raw::c_uchar,
        password_len: ::std::os::raw::c_uint,
        out: *mut gnutls_datum_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type gnutls_ext_priv_data_t = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn gnutls_ext_set_data(
        session: gnutls_session_t,
        type_: ::std::os::raw::c_uint,
        arg1: gnutls_ext_priv_data_t,
    );
}
extern "C" {
    pub fn gnutls_ext_get_data(
        session: gnutls_session_t,
        type_: ::std::os::raw::c_uint,
        arg1: *mut gnutls_ext_priv_data_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_ext_get_current_msg(session: gnutls_session_t) -> ::std::os::raw::c_uint;
}
pub type gnutls_ext_recv_func = ::std::option::Option<
    unsafe extern "C" fn(
        session: gnutls_session_t,
        data: *const ::std::os::raw::c_uchar,
        len: size_t,
    ) -> ::std::os::raw::c_int,
>;
pub type gnutls_ext_send_func = ::std::option::Option<
    unsafe extern "C" fn(
        session: gnutls_session_t,
        extdata: gnutls_buffer_t,
    ) -> ::std::os::raw::c_int,
>;
pub type gnutls_ext_deinit_data_func =
    ::std::option::Option<unsafe extern "C" fn(data: gnutls_ext_priv_data_t)>;
pub type gnutls_ext_pack_func = ::std::option::Option<
    unsafe extern "C" fn(
        data: gnutls_ext_priv_data_t,
        packed_data: gnutls_buffer_t,
    ) -> ::std::os::raw::c_int,
>;
pub type gnutls_ext_unpack_func = ::std::option::Option<
    unsafe extern "C" fn(
        packed_data: gnutls_buffer_t,
        data: *mut gnutls_ext_priv_data_t,
    ) -> ::std::os::raw::c_int,
>;
pub type gnutls_ext_raw_process_func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        tls_id: ::std::os::raw::c_uint,
        data: *const ::std::os::raw::c_uchar,
        data_size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_ext_raw_parse(
        ctx: *mut ::std::os::raw::c_void,
        cb: gnutls_ext_raw_process_func,
        data: *const gnutls_datum_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub const gnutls_ext_parse_type_t_GNUTLS_EXT_ANY: gnutls_ext_parse_type_t = 0;
pub const gnutls_ext_parse_type_t_GNUTLS_EXT_APPLICATION: gnutls_ext_parse_type_t = 1;
pub const gnutls_ext_parse_type_t_GNUTLS_EXT_TLS: gnutls_ext_parse_type_t = 2;
pub const gnutls_ext_parse_type_t_GNUTLS_EXT_MANDATORY: gnutls_ext_parse_type_t = 3;
pub const gnutls_ext_parse_type_t_GNUTLS_EXT_NONE: gnutls_ext_parse_type_t = 4;
pub const gnutls_ext_parse_type_t_GNUTLS_EXT_VERSION_NEG: gnutls_ext_parse_type_t = 5;
#[doc = " gnutls_ext_parse_type_t:"]
#[doc = " @GNUTLS_EXT_NONE: Never to be parsed"]
#[doc = " @GNUTLS_EXT_ANY: Any extension type (should not be used as it is used only internally)."]
#[doc = " @GNUTLS_EXT_VERSION_NEG: Extensions to be parsed first for TLS version negotiation."]
#[doc = " @GNUTLS_EXT_MANDATORY: Parsed after @GNUTLS_EXT_VERSION_NEG and even when resuming."]
#[doc = " @GNUTLS_EXT_APPLICATION: Parsed after @GNUTLS_EXT_MANDATORY"]
#[doc = " @GNUTLS_EXT_TLS: TLS-internal extensions, parsed after @GNUTLS_EXT_APPLICATION."]
#[doc = ""]
#[doc = " Enumeration of different TLS extension parsing phases.  The @gnutls_ext_parse_type_t"]
#[doc = " indicates the time/phase an extension is parsed during Client or Server hello parsing."]
#[doc = ""]
pub type gnutls_ext_parse_type_t = ::std::os::raw::c_uint;
pub const gnutls_ext_flags_t_GNUTLS_EXT_FLAG_OVERRIDE_INTERNAL: gnutls_ext_flags_t = 1;
pub const gnutls_ext_flags_t_GNUTLS_EXT_FLAG_CLIENT_HELLO: gnutls_ext_flags_t = 2;
pub const gnutls_ext_flags_t_GNUTLS_EXT_FLAG_TLS12_SERVER_HELLO: gnutls_ext_flags_t = 4;
pub const gnutls_ext_flags_t_GNUTLS_EXT_FLAG_TLS13_SERVER_HELLO: gnutls_ext_flags_t = 8;
pub const gnutls_ext_flags_t_GNUTLS_EXT_FLAG_EE: gnutls_ext_flags_t = 16;
pub const gnutls_ext_flags_t_GNUTLS_EXT_FLAG_HRR: gnutls_ext_flags_t = 32;
pub const gnutls_ext_flags_t_GNUTLS_EXT_FLAG_IGNORE_CLIENT_REQUEST: gnutls_ext_flags_t = 64;
pub const gnutls_ext_flags_t_GNUTLS_EXT_FLAG_TLS: gnutls_ext_flags_t = 128;
pub const gnutls_ext_flags_t_GNUTLS_EXT_FLAG_DTLS: gnutls_ext_flags_t = 256;
#[doc = " gnutls_ext_flags_t:"]
#[doc = " @GNUTLS_EXT_FLAG_OVERRIDE_INTERNAL: If specified the extension registered will override the internal; this does not work with extensions existing prior to 3.6.0."]
#[doc = " @GNUTLS_EXT_FLAG_CLIENT_HELLO: This extension can be present in a client hello"]
#[doc = " @GNUTLS_EXT_FLAG_TLS12_SERVER_HELLO: This extension can be present in a TLS1.2 or earlier server hello"]
#[doc = " @GNUTLS_EXT_FLAG_TLS13_SERVER_HELLO: This extension can be present in a TLS1.3 server hello"]
#[doc = " @GNUTLS_EXT_FLAG_EE: This extension can be present in encrypted extensions message"]
#[doc = " @GNUTLS_EXT_FLAG_HRR: This extension can be present in hello retry request message"]
#[doc = " @GNUTLS_EXT_FLAG_IGNORE_CLIENT_REQUEST: When flag is present, this extension will be send even if the client didn't advertise it. An extension of this type is the Cookie TLS1.3 extension."]
#[doc = " @GNUTLS_EXT_FLAG_DTLS: This extension can be present under DTLS; otherwise ignored."]
#[doc = " @GNUTLS_EXT_FLAG_TLS: This extension can be present under TLS; otherwise ignored."]
#[doc = ""]
#[doc = " Enumeration of different TLS extension registration flags."]
pub type gnutls_ext_flags_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn gnutls_ext_register(
        name: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
        parse_point: gnutls_ext_parse_type_t,
        recv_func: gnutls_ext_recv_func,
        send_func: gnutls_ext_send_func,
        deinit_func: gnutls_ext_deinit_data_func,
        pack_func: gnutls_ext_pack_func,
        unpack_func: gnutls_ext_unpack_func,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_session_ext_register(
        arg1: gnutls_session_t,
        name: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
        parse_point: gnutls_ext_parse_type_t,
        recv_func: gnutls_ext_recv_func,
        send_func: gnutls_ext_send_func,
        deinit_func: gnutls_ext_deinit_data_func,
        pack_func: gnutls_ext_pack_func,
        unpack_func: gnutls_ext_unpack_func,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_ext_get_name(ext: ::std::os::raw::c_uint) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_ext_get_name2(
        session: gnutls_session_t,
        tls_id: ::std::os::raw::c_uint,
        parse_point: gnutls_ext_parse_type_t,
    ) -> *const ::std::os::raw::c_char;
}
pub type gnutls_supp_recv_func = ::std::option::Option<
    unsafe extern "C" fn(
        session: gnutls_session_t,
        data: *const ::std::os::raw::c_uchar,
        data_size: size_t,
    ) -> ::std::os::raw::c_int,
>;
pub type gnutls_supp_send_func = ::std::option::Option<
    unsafe extern "C" fn(session: gnutls_session_t, buf: gnutls_buffer_t) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_supplemental_register(
        name: *const ::std::os::raw::c_char,
        type_: gnutls_supplemental_data_format_type_t,
        supp_recv_func: gnutls_supp_recv_func,
        supp_send_func: gnutls_supp_send_func,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_session_supplemental_register(
        session: gnutls_session_t,
        name: *const ::std::os::raw::c_char,
        type_: gnutls_supplemental_data_format_type_t,
        supp_recv_func: gnutls_supp_recv_func,
        supp_send_func: gnutls_supp_send_func,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_supplemental_recv(
        session: gnutls_session_t,
        do_recv_supplemental: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn gnutls_supplemental_send(
        session: gnutls_session_t,
        do_send_supplemental: ::std::os::raw::c_uint,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_anti_replay_st {
    _unused: [u8; 0],
}
pub type gnutls_anti_replay_t = *mut gnutls_anti_replay_st;
extern "C" {
    pub fn gnutls_anti_replay_init(anti_replay: *mut gnutls_anti_replay_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_anti_replay_deinit(anti_replay: gnutls_anti_replay_t);
}
extern "C" {
    pub fn gnutls_anti_replay_set_window(
        anti_replay: gnutls_anti_replay_t,
        window: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn gnutls_anti_replay_enable(session: gnutls_session_t, anti_replay: gnutls_anti_replay_t);
}
pub type gnutls_db_add_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        exp_time: time_t,
        key: *const gnutls_datum_t,
        data: *const gnutls_datum_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_anti_replay_set_add_function(
        arg1: gnutls_anti_replay_t,
        add_func: gnutls_db_add_func,
    );
}
extern "C" {
    pub fn gnutls_anti_replay_set_ptr(arg1: gnutls_anti_replay_t, ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn gnutls_fips140_mode_enabled() -> ::std::os::raw::c_uint;
}
pub const gnutls_fips_mode_t_GNUTLS_FIPS140_DISABLED: gnutls_fips_mode_t = 0;
pub const gnutls_fips_mode_t_GNUTLS_FIPS140_STRICT: gnutls_fips_mode_t = 1;
pub const gnutls_fips_mode_t_GNUTLS_FIPS140_SELFTESTS: gnutls_fips_mode_t = 2;
pub const gnutls_fips_mode_t_GNUTLS_FIPS140_LAX: gnutls_fips_mode_t = 3;
pub const gnutls_fips_mode_t_GNUTLS_FIPS140_LOG: gnutls_fips_mode_t = 4;
#[doc = " gnutls_fips_mode_t:"]
#[doc = " @GNUTLS_FIPS140_DISABLED: The FIPS140-2 mode is disabled."]
#[doc = " @GNUTLS_FIPS140_STRICT: The default mode; all forbidden operations will cause an"]
#[doc = "                         operation failure via error code."]
#[doc = " @GNUTLS_FIPS140_LAX: The library still uses the FIPS140-2 relevant algorithms but all"]
#[doc = "                      forbidden by FIPS140-2 operations are allowed; this is useful when the"]
#[doc = "                      application is aware of the followed security policy, and needs"]
#[doc = "                      to utilize disallowed operations for other reasons (e.g., compatibility)."]
#[doc = " @GNUTLS_FIPS140_LOG: Similarly to %GNUTLS_FIPS140_LAX, it allows forbidden operations; any use of them results"]
#[doc = "                      to a message to the audit callback functions."]
#[doc = " @GNUTLS_FIPS140_SELFTESTS: A transient state during library initialization. That state"]
#[doc = "\t\t\tcannot be set or seen by applications."]
#[doc = ""]
#[doc = " Enumeration of different operational modes under FIPS140-2."]
pub type gnutls_fips_mode_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn gnutls_fips140_set_mode(mode: gnutls_fips_mode_t, flags: ::std::os::raw::c_uint);
}
pub type gnutls_connection_end_t = ::std::os::raw::c_uint;
pub use self::gnutls_compression_method_t as gnutls_compression_method;
pub use self::gnutls_digest_algorithm_t as gnutls_digest_algorithm;
pub use self::gnutls_kx_algorithm_t as gnutls_kx_algorithm;
pub use self::gnutls_mac_algorithm_t as gnutls_mac_algorithm;
pub type gnutls_connection_end = gnutls_connection_end_t;
pub use self::gnutls_certificate_request_t as gnutls_certificate_request;
pub use self::gnutls_certificate_status_t as gnutls_certificate_status;
pub use self::gnutls_close_request_t as gnutls_close_request;
pub use self::gnutls_pk_algorithm_t as gnutls_pk_algorithm;
pub use self::gnutls_sign_algorithm_t as gnutls_sign_algorithm;
pub use self::gnutls_x509_crt_fmt_t as gnutls_x509_crt_fmt;
pub type gnutls_session = gnutls_session_t;
pub use self::gnutls_alert_description_t as gnutls_alert_description;
pub use self::gnutls_alert_level_t as gnutls_alert_level;
pub use self::gnutls_x509_subject_alt_name_t as gnutls_x509_subject_alt_name;
pub type gnutls_openpgp_privkey = gnutls_openpgp_privkey_t;
pub type gnutls_openpgp_keyring = gnutls_openpgp_keyring_t;
pub type gnutls_x509_crt = gnutls_x509_crt_t;
pub type gnutls_x509_privkey = gnutls_x509_privkey_t;
pub type gnutls_x509_crl = gnutls_x509_crl_t;
pub type gnutls_x509_crq = gnutls_x509_crq_t;
pub type gnutls_certificate_credentials = gnutls_certificate_credentials_t;
pub type gnutls_anon_server_credentials = gnutls_anon_server_credentials_t;
pub type gnutls_anon_client_credentials = gnutls_anon_client_credentials_t;
pub type gnutls_srp_client_credentials = gnutls_srp_client_credentials_t;
pub type gnutls_srp_server_credentials = gnutls_srp_server_credentials_t;
pub type gnutls_dh_params = gnutls_dh_params_t;
pub type gnutls_rsa_params = gnutls_rsa_params_t;
pub use self::gnutls_certificate_type_t as gnutls_certificate_type;
pub use self::gnutls_credentials_type_t as gnutls_credentials_type;
pub use self::gnutls_params_type_t as gnutls_params_type;
pub type gnutls_datum = gnutls_datum_t;
pub type gnutls_transport_ptr = gnutls_transport_ptr_t;
pub use self::gnutls_openpgp_crt_status_t as gnutls_openpgp_key_status_t;
pub type gnutls_openpgp_key_t = gnutls_openpgp_crt_t;
extern "C" {
    pub fn gnutls_x509_privkey_sign_hash(
        key: gnutls_x509_privkey_t,
        hash: *const gnutls_datum_t,
        signature: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_openpgp_privkey_sign_hash(
        key: gnutls_openpgp_privkey_t,
        hash: *const gnutls_datum_t,
        signature: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_preferred_hash_algorithm(
        crt: gnutls_x509_crt_t,
        hash: *mut gnutls_digest_algorithm_t,
        mand: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_global_set_mem_functions(
        alloc_func: gnutls_alloc_function,
        secure_alloc_func: gnutls_alloc_function,
        is_secure_func: gnutls_is_secure_function,
        realloc_func: gnutls_realloc_function,
        free_func: gnutls_free_function,
    );
}
extern "C" {
    pub fn gnutls_compression_get(session: gnutls_session_t) -> gnutls_compression_method_t;
}
extern "C" {
    pub fn gnutls_compression_get_name(
        algorithm: gnutls_compression_method_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_compression_get_id(
        name: *const ::std::os::raw::c_char,
    ) -> gnutls_compression_method_t;
}
extern "C" {
    pub fn gnutls_compression_list() -> *const gnutls_compression_method_t;
}
extern "C" {
    pub fn gnutls_priority_compression_list(
        pcache: gnutls_priority_t,
        list: *mut *const ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type key_data_t = gnutls_datum_t;
pub const userpref_error_t_USERPREF_E_SUCCESS: userpref_error_t = 0;
pub const userpref_error_t_USERPREF_E_INVALID_ARG: userpref_error_t = -1;
pub const userpref_error_t_USERPREF_E_NOENT: userpref_error_t = -2;
pub const userpref_error_t_USERPREF_E_INVALID_CONF: userpref_error_t = -3;
pub const userpref_error_t_USERPREF_E_SSL_ERROR: userpref_error_t = -4;
pub const userpref_error_t_USERPREF_E_READ_ERROR: userpref_error_t = -5;
pub const userpref_error_t_USERPREF_E_WRITE_ERROR: userpref_error_t = -6;
pub const userpref_error_t_USERPREF_E_UNKNOWN_ERROR: userpref_error_t = -256;
#[doc = " Error Codes"]
pub type userpref_error_t = ::std::os::raw::c_int;
extern "C" {
    pub fn userpref_get_config_dir() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn userpref_read_system_buid(
        system_buid: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn userpref_read_pair_record(
        udid: *const ::std::os::raw::c_char,
        pair_record: *mut plist_t,
    ) -> userpref_error_t;
}
extern "C" {
    pub fn userpref_save_pair_record(
        udid: *const ::std::os::raw::c_char,
        device_id: u32,
        pair_record: plist_t,
    ) -> userpref_error_t;
}
extern "C" {
    pub fn userpref_delete_pair_record(udid: *const ::std::os::raw::c_char) -> userpref_error_t;
}
extern "C" {
    pub fn pair_record_generate_keys_and_certs(
        pair_record: plist_t,
        public_key: key_data_t,
    ) -> userpref_error_t;
}
extern "C" {
    pub fn pair_record_import_key_with_name(
        pair_record: plist_t,
        name: *const ::std::os::raw::c_char,
        key: gnutls_x509_privkey_t,
    ) -> userpref_error_t;
}
extern "C" {
    pub fn pair_record_import_crt_with_name(
        pair_record: plist_t,
        name: *const ::std::os::raw::c_char,
        cert: gnutls_x509_crt_t,
    ) -> userpref_error_t;
}
extern "C" {
    pub fn pair_record_get_host_id(
        pair_record: plist_t,
        host_id: *mut *mut ::std::os::raw::c_char,
    ) -> userpref_error_t;
}
extern "C" {
    pub fn pair_record_set_host_id(
        pair_record: plist_t,
        host_id: *const ::std::os::raw::c_char,
    ) -> userpref_error_t;
}
extern "C" {
    pub fn pair_record_get_item_as_key_data(
        pair_record: plist_t,
        name: *const ::std::os::raw::c_char,
        value: *mut key_data_t,
    ) -> userpref_error_t;
}
extern "C" {
    pub fn pair_record_set_item_from_key_data(
        pair_record: plist_t,
        name: *const ::std::os::raw::c_char,
        value: *mut key_data_t,
    ) -> userpref_error_t;
}
extern "C" {
    pub fn userpref_get_paired_udids(
        list: *mut *mut *mut ::std::os::raw::c_char,
        count: *mut ::std::os::raw::c_uint,
    ) -> userpref_error_t;
}
extern "C" {
    pub fn userpref_has_pair_record(udid: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_data_private {}
#[test]
fn bindgen_test_layout_ssl_data_private() {
    assert_eq!(
        ::std::mem::size_of::<ssl_data_private>(),
        0usize,
        concat!("Size of: ", stringify!(ssl_data_private))
    );
    assert_eq!(
        ::std::mem::align_of::<ssl_data_private>(),
        1usize,
        concat!("Alignment of ", stringify!(ssl_data_private))
    );
}
pub type ssl_data_t = *mut ssl_data_private;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct idevice_connection_private {
    pub device: idevice_t,
    pub type_: idevice_connection_type,
    pub data: *mut ::std::os::raw::c_void,
    pub ssl_data: ssl_data_t,
    pub ssl_recv_timeout: ::std::os::raw::c_uint,
    pub status: idevice_error_t,
}
#[test]
fn bindgen_test_layout_idevice_connection_private() {
    assert_eq!(
        ::std::mem::size_of::<idevice_connection_private>(),
        40usize,
        concat!("Size of: ", stringify!(idevice_connection_private))
    );
    assert_eq!(
        ::std::mem::align_of::<idevice_connection_private>(),
        8usize,
        concat!("Alignment of ", stringify!(idevice_connection_private))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<idevice_connection_private>())).device as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_connection_private),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<idevice_connection_private>())).type_ as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_connection_private),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idevice_connection_private>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_connection_private),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<idevice_connection_private>())).ssl_data as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_connection_private),
            "::",
            stringify!(ssl_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<idevice_connection_private>())).ssl_recv_timeout as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_connection_private),
            "::",
            stringify!(ssl_recv_timeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<idevice_connection_private>())).status as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_connection_private),
            "::",
            stringify!(status)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct idevice_private {
    pub udid: *mut ::std::os::raw::c_char,
    pub mux_id: u32,
    pub conn_type: idevice_connection_type,
    pub conn_data: *mut ::std::os::raw::c_void,
    pub version: ::std::os::raw::c_int,
    pub device_class: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_idevice_private() {
    assert_eq!(
        ::std::mem::size_of::<idevice_private>(),
        32usize,
        concat!("Size of: ", stringify!(idevice_private))
    );
    assert_eq!(
        ::std::mem::align_of::<idevice_private>(),
        8usize,
        concat!("Alignment of ", stringify!(idevice_private))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idevice_private>())).udid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_private),
            "::",
            stringify!(udid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idevice_private>())).mux_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_private),
            "::",
            stringify!(mux_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idevice_private>())).conn_type as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_private),
            "::",
            stringify!(conn_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idevice_private>())).conn_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_private),
            "::",
            stringify!(conn_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idevice_private>())).version as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_private),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idevice_private>())).device_class as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_private),
            "::",
            stringify!(device_class)
        )
    );
}
pub const property_list_service_error_t_PROPERTY_LIST_SERVICE_E_SUCCESS:
    property_list_service_error_t = 0;
pub const property_list_service_error_t_PROPERTY_LIST_SERVICE_E_INVALID_ARG:
    property_list_service_error_t = -1;
pub const property_list_service_error_t_PROPERTY_LIST_SERVICE_E_PLIST_ERROR:
    property_list_service_error_t = -2;
pub const property_list_service_error_t_PROPERTY_LIST_SERVICE_E_MUX_ERROR:
    property_list_service_error_t = -3;
pub const property_list_service_error_t_PROPERTY_LIST_SERVICE_E_SSL_ERROR:
    property_list_service_error_t = -4;
pub const property_list_service_error_t_PROPERTY_LIST_SERVICE_E_RECEIVE_TIMEOUT:
    property_list_service_error_t = -5;
pub const property_list_service_error_t_PROPERTY_LIST_SERVICE_E_NOT_ENOUGH_DATA:
    property_list_service_error_t = -6;
pub const property_list_service_error_t_PROPERTY_LIST_SERVICE_E_UNKNOWN_ERROR:
    property_list_service_error_t = -256;
pub type property_list_service_error_t = ::std::os::raw::c_int;
pub type property_list_service_private = property_list_service_client_private;
pub type property_list_service_client_t = *mut property_list_service_private;
extern "C" {
    #[doc = " Creates a new property list service for the specified port."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param service The service descriptor returned by lockdownd_start_service."]
    #[doc = " @param client Pointer that will be set to a newly allocated"]
    #[doc = "     property_list_service_client_t upon successful return."]
    #[doc = ""]
    #[doc = " @return PROPERTY_LIST_SERVICE_E_SUCCESS on success,"]
    #[doc = "     PROPERTY_LIST_SERVICE_E_INVALID_ARG when one of the arguments is invalid,"]
    #[doc = "     or PROPERTY_LIST_SERVICE_E_MUX_ERROR when connecting to the device failed."]
    pub fn property_list_service_client_new(
        device: idevice_t,
        service: lockdownd_service_descriptor_t,
        client: *mut property_list_service_client_t,
    ) -> property_list_service_error_t;
}
extern "C" {
    #[doc = " Frees a PropertyList service."]
    #[doc = ""]
    #[doc = " @param client The property list service to free."]
    #[doc = ""]
    #[doc = " @return PROPERTY_LIST_SERVICE_E_SUCCESS on success,"]
    #[doc = "     PROPERTY_LIST_SERVICE_E_INVALID_ARG when client is invalid, or a"]
    #[doc = "     PROPERTY_LIST_SERVICE_E_UNKNOWN_ERROR when another error occurred."]
    pub fn property_list_service_client_free(
        client: property_list_service_client_t,
    ) -> property_list_service_error_t;
}
extern "C" {
    #[doc = " Sends an XML plist."]
    #[doc = ""]
    #[doc = " @param client The property list service client to use for sending."]
    #[doc = " @param plist plist to send"]
    #[doc = ""]
    #[doc = " @return PROPERTY_LIST_SERVICE_E_SUCCESS on success,"]
    #[doc = "      PROPERTY_LIST_SERVICE_E_INVALID_ARG when client or plist is NULL,"]
    #[doc = "      PROPERTY_LIST_SERVICE_E_PLIST_ERROR when dict is not a valid plist,"]
    #[doc = "      or PROPERTY_LIST_SERVICE_E_UNKNOWN_ERROR when an unspecified error occurs."]
    pub fn property_list_service_send_xml_plist(
        client: property_list_service_client_t,
        plist: plist_t,
    ) -> property_list_service_error_t;
}
extern "C" {
    #[doc = " Sends a binary plist."]
    #[doc = ""]
    #[doc = " @param client The property list service client to use for sending."]
    #[doc = " @param plist plist to send"]
    #[doc = ""]
    #[doc = " @return PROPERTY_LIST_SERVICE_E_SUCCESS on success,"]
    #[doc = "      PROPERTY_LIST_SERVICE_E_INVALID_ARG when client or plist is NULL,"]
    #[doc = "      PROPERTY_LIST_SERVICE_E_PLIST_ERROR when dict is not a valid plist,"]
    #[doc = "      or PROPERTY_LIST_SERVICE_E_UNKNOWN_ERROR when an unspecified error occurs."]
    pub fn property_list_service_send_binary_plist(
        client: property_list_service_client_t,
        plist: plist_t,
    ) -> property_list_service_error_t;
}
extern "C" {
    #[doc = " Receives a plist using the given property list service client with specified"]
    #[doc = " timeout."]
    #[doc = " Binary or XML plists are automatically handled."]
    #[doc = ""]
    #[doc = " @param client The property list service client to use for receiving"]
    #[doc = " @param plist pointer to a plist_t that will point to the received plist"]
    #[doc = "              upon successful return"]
    #[doc = " @param timeout Maximum time in milliseconds to wait for data."]
    #[doc = ""]
    #[doc = " @return PROPERTY_LIST_SERVICE_E_SUCCESS on success,"]
    #[doc = "      PROPERTY_LIST_SERVICE_E_INVALID_ARG when connection or *plist is NULL,"]
    #[doc = "      PROPERTY_LIST_SERVICE_E_PLIST_ERROR when the received data cannot be"]
    #[doc = "      converted to a plist, PROPERTY_LIST_SERVICE_E_MUX_ERROR when a"]
    #[doc = "      communication error occurs, or PROPERTY_LIST_SERVICE_E_UNKNOWN_ERROR when"]
    #[doc = "      an unspecified error occurs."]
    pub fn property_list_service_receive_plist_with_timeout(
        client: property_list_service_client_t,
        plist: *mut plist_t,
        timeout: ::std::os::raw::c_uint,
    ) -> property_list_service_error_t;
}
extern "C" {
    #[doc = " Receives a plist using the given property list service client."]
    #[doc = " Binary or XML plists are automatically handled."]
    #[doc = ""]
    #[doc = " This function is like property_list_service_receive_plist_with_timeout"]
    #[doc = "   using a timeout of 10 seconds."]
    #[doc = " @see property_list_service_receive_plist_with_timeout"]
    #[doc = ""]
    #[doc = " @param client The property list service client to use for receiving"]
    #[doc = " @param plist pointer to a plist_t that will point to the received plist"]
    #[doc = "      upon successful return"]
    #[doc = ""]
    #[doc = " @return PROPERTY_LIST_SERVICE_E_SUCCESS on success,"]
    #[doc = "      PROPERTY_LIST_SERVICE_E_INVALID_ARG when client or *plist is NULL,"]
    #[doc = "      PROPERTY_LIST_SERVICE_E_NOT_ENOUGH_DATA when not enough data"]
    #[doc = "      received, PROPERTY_LIST_SERVICE_E_RECEIVE_TIMEOUT when the connection times out,"]
    #[doc = "      PROPERTY_LIST_SERVICE_E_PLIST_ERROR when the received data cannot be"]
    #[doc = "      converted to a plist, PROPERTY_LIST_SERVICE_E_MUX_ERROR when a"]
    #[doc = "      communication error occurs, or PROPERTY_LIST_SERVICE_E_UNKNOWN_ERROR when"]
    #[doc = "      an unspecified error occurs."]
    pub fn property_list_service_receive_plist(
        client: property_list_service_client_t,
        plist: *mut plist_t,
    ) -> property_list_service_error_t;
}
extern "C" {
    #[doc = " Enable SSL for the given property list service client."]
    #[doc = ""]
    #[doc = " @param client The connected property list service client for which SSL"]
    #[doc = "     should be enabled."]
    #[doc = ""]
    #[doc = " @return PROPERTY_LIST_SERVICE_E_SUCCESS on success,"]
    #[doc = "     PROPERTY_LIST_SERVICE_E_INVALID_ARG if client or client->connection is"]
    #[doc = "     NULL, PROPERTY_LIST_SERVICE_E_SSL_ERROR when SSL could not be enabled,"]
    #[doc = "     or PROPERTY_LIST_SERVICE_E_UNKNOWN_ERROR otherwise."]
    pub fn property_list_service_enable_ssl(
        client: property_list_service_client_t,
    ) -> property_list_service_error_t;
}
extern "C" {
    #[doc = " Disable SSL for the given property list service client."]
    #[doc = ""]
    #[doc = " @param client The connected property list service client for which SSL"]
    #[doc = "     should be disabled."]
    #[doc = ""]
    #[doc = " @return PROPERTY_LIST_SERVICE_E_SUCCESS on success,"]
    #[doc = "     PROPERTY_LIST_SERVICE_E_INVALID_ARG if client or client->connection is"]
    #[doc = "     NULL, or PROPERTY_LIST_SERVICE_E_UNKNOWN_ERROR otherwise."]
    pub fn property_list_service_disable_ssl(
        client: property_list_service_client_t,
    ) -> property_list_service_error_t;
}
pub const service_error_t_SERVICE_E_SUCCESS: service_error_t = 0;
pub const service_error_t_SERVICE_E_INVALID_ARG: service_error_t = -1;
pub const service_error_t_SERVICE_E_MUX_ERROR: service_error_t = -3;
pub const service_error_t_SERVICE_E_SSL_ERROR: service_error_t = -4;
pub const service_error_t_SERVICE_E_START_SERVICE_ERROR: service_error_t = -5;
pub const service_error_t_SERVICE_E_NOT_ENOUGH_DATA: service_error_t = -6;
pub const service_error_t_SERVICE_E_TIMEOUT: service_error_t = -7;
pub const service_error_t_SERVICE_E_UNKNOWN_ERROR: service_error_t = -256;
#[doc = " Error Codes"]
pub type service_error_t = ::std::os::raw::c_int;
pub type service_client_t = *mut service_client_private;
extern "C" {
    #[doc = " Creates a new service for the specified service descriptor."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param service The service descriptor returned by lockdownd_start_service."]
    #[doc = " @param client Pointer that will be set to a newly allocated"]
    #[doc = "     service_client_t upon successful return."]
    #[doc = ""]
    #[doc = " @return SERVICE_E_SUCCESS on success,"]
    #[doc = "     SERVICE_E_INVALID_ARG when one of the arguments is invalid,"]
    #[doc = "     or SERVICE_E_MUX_ERROR when connecting to the device failed."]
    pub fn service_client_new(
        device: idevice_t,
        service: lockdownd_service_descriptor_t,
        client: *mut service_client_t,
    ) -> service_error_t;
}
extern "C" {
    #[doc = " Starts a new service on the specified device with given name and"]
    #[doc = " connects to it."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param service_name The name of the service to start."]
    #[doc = " @param client Pointer that will point to a newly allocated service_client_t"]
    #[doc = "     upon successful return. Must be freed using service_client_free() after"]
    #[doc = "     use."]
    #[doc = " @param label The label to use for communication. Usually the program name."]
    #[doc = "  Pass NULL to disable sending the label in requests to lockdownd."]
    #[doc = ""]
    #[doc = " @return SERVICE_E_SUCCESS on success, or a SERVICE_E_* error code"]
    #[doc = "     otherwise."]
    pub fn service_client_factory_start_service(
        device: idevice_t,
        service_name: *const ::std::os::raw::c_char,
        client: *mut *mut ::std::os::raw::c_void,
        label: *const ::std::os::raw::c_char,
        constructor_func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: idevice_t,
                arg2: lockdownd_service_descriptor_t,
                arg3: *mut *mut ::std::os::raw::c_void,
            ) -> i32,
        >,
        error_code: *mut i32,
    ) -> service_error_t;
}
extern "C" {
    #[doc = " Frees a service instance."]
    #[doc = ""]
    #[doc = " @param client The service instance to free."]
    #[doc = ""]
    #[doc = " @return SERVICE_E_SUCCESS on success,"]
    #[doc = "     SERVICE_E_INVALID_ARG when client is invalid, or a"]
    #[doc = "     SERVICE_E_UNKNOWN_ERROR when another error occurred."]
    pub fn service_client_free(client: service_client_t) -> service_error_t;
}
extern "C" {
    #[doc = " Sends data using the given service client."]
    #[doc = ""]
    #[doc = " @param client The service client to use for sending."]
    #[doc = " @param data Data to send"]
    #[doc = " @param size Size of the data to send"]
    #[doc = " @param sent Number of bytes sent (can be NULL to ignore)"]
    #[doc = ""]
    #[doc = " @return SERVICE_E_SUCCESS on success,"]
    #[doc = "      SERVICE_E_INVALID_ARG when one or more parameters are"]
    #[doc = "      invalid, or SERVICE_E_UNKNOWN_ERROR when an unspecified"]
    #[doc = "      error occurs."]
    pub fn service_send(
        client: service_client_t,
        data: *const ::std::os::raw::c_char,
        size: u32,
        sent: *mut u32,
    ) -> service_error_t;
}
extern "C" {
    #[doc = " Receives data using the given service client with specified timeout."]
    #[doc = ""]
    #[doc = " @param client The service client to use for receiving"]
    #[doc = " @param data Buffer that will be filled with the data received"]
    #[doc = " @param size Number of bytes to receive"]
    #[doc = " @param received Number of bytes received (can be NULL to ignore)"]
    #[doc = " @param timeout Maximum time in milliseconds to wait for data."]
    #[doc = ""]
    #[doc = " @return SERVICE_E_SUCCESS on success,"]
    #[doc = "      SERVICE_E_INVALID_ARG when one or more parameters are"]
    #[doc = "      invalid, SERVICE_E_MUX_ERROR when a communication error"]
    #[doc = "      occurs, or SERVICE_E_UNKNOWN_ERROR when an unspecified"]
    #[doc = "      error occurs."]
    pub fn service_receive_with_timeout(
        client: service_client_t,
        data: *mut ::std::os::raw::c_char,
        size: u32,
        received: *mut u32,
        timeout: ::std::os::raw::c_uint,
    ) -> service_error_t;
}
extern "C" {
    #[doc = " Receives data using the given service client."]
    #[doc = ""]
    #[doc = " @param client The service client to use for receiving"]
    #[doc = " @param data Buffer that will be filled with the data received"]
    #[doc = " @param size Number of bytes to receive"]
    #[doc = " @param received Number of bytes received (can be NULL to ignore)"]
    #[doc = ""]
    #[doc = " @return SERVICE_E_SUCCESS on success,"]
    #[doc = "      SERVICE_E_INVALID_ARG when one or more parameters are"]
    #[doc = "      invalid, SERVICE_E_NOT_ENOUGH_DATA when not enough data"]
    #[doc = "      received, SERVICE_E_TIMEOUT when the connection times out,"]
    #[doc = "      SERVICE_E_MUX_ERROR when a communication error"]
    #[doc = "      occurs, or SERVICE_E_UNKNOWN_ERROR when an unspecified"]
    #[doc = "      error occurs."]
    pub fn service_receive(
        client: service_client_t,
        data: *mut ::std::os::raw::c_char,
        size: u32,
        received: *mut u32,
    ) -> service_error_t;
}
extern "C" {
    #[doc = " Enable SSL for the given service client."]
    #[doc = ""]
    #[doc = " @param client The connected service client for that SSL should be enabled."]
    #[doc = ""]
    #[doc = " @return SERVICE_E_SUCCESS on success,"]
    #[doc = "     SERVICE_E_INVALID_ARG if client or client->connection is"]
    #[doc = "     NULL, SERVICE_E_NOT_ENOUGH_DATA when not enough data"]
    #[doc = "     received, SERVICE_E_TIMEOUT when the connection times out,"]
    #[doc = "     SERVICE_E_SSL_ERROR when SSL could not be enabled,"]
    #[doc = "     or SERVICE_E_UNKNOWN_ERROR otherwise."]
    pub fn service_enable_ssl(client: service_client_t) -> service_error_t;
}
extern "C" {
    #[doc = " Disable SSL for the given service client."]
    #[doc = ""]
    #[doc = " @param client The connected service client for that SSL should be disabled."]
    #[doc = ""]
    #[doc = " @return SERVICE_E_SUCCESS on success,"]
    #[doc = "     SERVICE_E_INVALID_ARG if client or client->connection is"]
    #[doc = "     NULL, or SERVICE_E_UNKNOWN_ERROR otherwise."]
    pub fn service_disable_ssl(client: service_client_t) -> service_error_t;
}
extern "C" {
    #[doc = " Disable SSL for the given service client without sending SSL terminate messages."]
    #[doc = ""]
    #[doc = " @param client The connected service client for that SSL should be disabled."]
    #[doc = ""]
    #[doc = " @return SERVICE_E_SUCCESS on success,"]
    #[doc = "     SERVICE_E_INVALID_ARG if client or client->connection is"]
    #[doc = "     NULL, or SERVICE_E_UNKNOWN_ERROR otherwise."]
    pub fn service_disable_bypass_ssl(client: service_client_t, sslBypass: u8) -> service_error_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct service_client_private {
    pub connection: idevice_connection_t,
}
#[test]
fn bindgen_test_layout_service_client_private() {
    assert_eq!(
        ::std::mem::size_of::<service_client_private>(),
        8usize,
        concat!("Size of: ", stringify!(service_client_private))
    );
    assert_eq!(
        ::std::mem::align_of::<service_client_private>(),
        8usize,
        concat!("Alignment of ", stringify!(service_client_private))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<service_client_private>())).connection as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(service_client_private),
            "::",
            stringify!(connection)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct property_list_service_client_private {
    pub parent: service_client_t,
}
#[test]
fn bindgen_test_layout_property_list_service_client_private() {
    assert_eq!(
        ::std::mem::size_of::<property_list_service_client_private>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(property_list_service_client_private)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<property_list_service_client_private>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(property_list_service_client_private)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<property_list_service_client_private>())).parent as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(property_list_service_client_private),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lockdownd_client_private {
    pub parent: property_list_service_client_t,
    pub ssl_enabled: ::std::os::raw::c_int,
    pub session_id: *mut ::std::os::raw::c_char,
    pub label: *mut ::std::os::raw::c_char,
    pub device: idevice_t,
}
#[test]
fn bindgen_test_layout_lockdownd_client_private() {
    assert_eq!(
        ::std::mem::size_of::<lockdownd_client_private>(),
        40usize,
        concat!("Size of: ", stringify!(lockdownd_client_private))
    );
    assert_eq!(
        ::std::mem::align_of::<lockdownd_client_private>(),
        8usize,
        concat!("Alignment of ", stringify!(lockdownd_client_private))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lockdownd_client_private>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_client_private),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lockdownd_client_private>())).ssl_enabled as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_client_private),
            "::",
            stringify!(ssl_enabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lockdownd_client_private>())).session_id as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_client_private),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lockdownd_client_private>())).label as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_client_private),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lockdownd_client_private>())).device as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_client_private),
            "::",
            stringify!(device)
        )
    );
}
pub const instproxy_error_t_INSTPROXY_E_SUCCESS: instproxy_error_t = 0;
pub const instproxy_error_t_INSTPROXY_E_INVALID_ARG: instproxy_error_t = -1;
pub const instproxy_error_t_INSTPROXY_E_PLIST_ERROR: instproxy_error_t = -2;
pub const instproxy_error_t_INSTPROXY_E_CONN_FAILED: instproxy_error_t = -3;
pub const instproxy_error_t_INSTPROXY_E_OP_IN_PROGRESS: instproxy_error_t = -4;
pub const instproxy_error_t_INSTPROXY_E_OP_FAILED: instproxy_error_t = -5;
pub const instproxy_error_t_INSTPROXY_E_RECEIVE_TIMEOUT: instproxy_error_t = -6;
pub const instproxy_error_t_INSTPROXY_E_ALREADY_ARCHIVED: instproxy_error_t = -7;
pub const instproxy_error_t_INSTPROXY_E_API_INTERNAL_ERROR: instproxy_error_t = -8;
pub const instproxy_error_t_INSTPROXY_E_APPLICATION_ALREADY_INSTALLED: instproxy_error_t = -9;
pub const instproxy_error_t_INSTPROXY_E_APPLICATION_MOVE_FAILED: instproxy_error_t = -10;
pub const instproxy_error_t_INSTPROXY_E_APPLICATION_SINF_CAPTURE_FAILED: instproxy_error_t = -11;
pub const instproxy_error_t_INSTPROXY_E_APPLICATION_SANDBOX_FAILED: instproxy_error_t = -12;
pub const instproxy_error_t_INSTPROXY_E_APPLICATION_VERIFICATION_FAILED: instproxy_error_t = -13;
pub const instproxy_error_t_INSTPROXY_E_ARCHIVE_DESTRUCTION_FAILED: instproxy_error_t = -14;
pub const instproxy_error_t_INSTPROXY_E_BUNDLE_VERIFICATION_FAILED: instproxy_error_t = -15;
pub const instproxy_error_t_INSTPROXY_E_CARRIER_BUNDLE_COPY_FAILED: instproxy_error_t = -16;
pub const instproxy_error_t_INSTPROXY_E_CARRIER_BUNDLE_DIRECTORY_CREATION_FAILED:
    instproxy_error_t = -17;
pub const instproxy_error_t_INSTPROXY_E_CARRIER_BUNDLE_MISSING_SUPPORTED_SIMS: instproxy_error_t =
    -18;
pub const instproxy_error_t_INSTPROXY_E_COMM_CENTER_NOTIFICATION_FAILED: instproxy_error_t = -19;
pub const instproxy_error_t_INSTPROXY_E_CONTAINER_CREATION_FAILED: instproxy_error_t = -20;
pub const instproxy_error_t_INSTPROXY_E_CONTAINER_P0WN_FAILED: instproxy_error_t = -21;
pub const instproxy_error_t_INSTPROXY_E_CONTAINER_REMOVAL_FAILED: instproxy_error_t = -22;
pub const instproxy_error_t_INSTPROXY_E_EMBEDDED_PROFILE_INSTALL_FAILED: instproxy_error_t = -23;
pub const instproxy_error_t_INSTPROXY_E_EXECUTABLE_TWIDDLE_FAILED: instproxy_error_t = -24;
pub const instproxy_error_t_INSTPROXY_E_EXISTENCE_CHECK_FAILED: instproxy_error_t = -25;
pub const instproxy_error_t_INSTPROXY_E_INSTALL_MAP_UPDATE_FAILED: instproxy_error_t = -26;
pub const instproxy_error_t_INSTPROXY_E_MANIFEST_CAPTURE_FAILED: instproxy_error_t = -27;
pub const instproxy_error_t_INSTPROXY_E_MAP_GENERATION_FAILED: instproxy_error_t = -28;
pub const instproxy_error_t_INSTPROXY_E_MISSING_BUNDLE_EXECUTABLE: instproxy_error_t = -29;
pub const instproxy_error_t_INSTPROXY_E_MISSING_BUNDLE_IDENTIFIER: instproxy_error_t = -30;
pub const instproxy_error_t_INSTPROXY_E_MISSING_BUNDLE_PATH: instproxy_error_t = -31;
pub const instproxy_error_t_INSTPROXY_E_MISSING_CONTAINER: instproxy_error_t = -32;
pub const instproxy_error_t_INSTPROXY_E_NOTIFICATION_FAILED: instproxy_error_t = -33;
pub const instproxy_error_t_INSTPROXY_E_PACKAGE_EXTRACTION_FAILED: instproxy_error_t = -34;
pub const instproxy_error_t_INSTPROXY_E_PACKAGE_INSPECTION_FAILED: instproxy_error_t = -35;
pub const instproxy_error_t_INSTPROXY_E_PACKAGE_MOVE_FAILED: instproxy_error_t = -36;
pub const instproxy_error_t_INSTPROXY_E_PATH_CONVERSION_FAILED: instproxy_error_t = -37;
pub const instproxy_error_t_INSTPROXY_E_RESTORE_CONTAINER_FAILED: instproxy_error_t = -38;
pub const instproxy_error_t_INSTPROXY_E_SEATBELT_PROFILE_REMOVAL_FAILED: instproxy_error_t = -39;
pub const instproxy_error_t_INSTPROXY_E_STAGE_CREATION_FAILED: instproxy_error_t = -40;
pub const instproxy_error_t_INSTPROXY_E_SYMLINK_FAILED: instproxy_error_t = -41;
pub const instproxy_error_t_INSTPROXY_E_UNKNOWN_COMMAND: instproxy_error_t = -42;
pub const instproxy_error_t_INSTPROXY_E_ITUNES_ARTWORK_CAPTURE_FAILED: instproxy_error_t = -43;
pub const instproxy_error_t_INSTPROXY_E_ITUNES_METADATA_CAPTURE_FAILED: instproxy_error_t = -44;
pub const instproxy_error_t_INSTPROXY_E_DEVICE_OS_VERSION_TOO_LOW: instproxy_error_t = -45;
pub const instproxy_error_t_INSTPROXY_E_DEVICE_FAMILY_NOT_SUPPORTED: instproxy_error_t = -46;
pub const instproxy_error_t_INSTPROXY_E_PACKAGE_PATCH_FAILED: instproxy_error_t = -47;
pub const instproxy_error_t_INSTPROXY_E_INCORRECT_ARCHITECTURE: instproxy_error_t = -48;
pub const instproxy_error_t_INSTPROXY_E_PLUGIN_COPY_FAILED: instproxy_error_t = -49;
pub const instproxy_error_t_INSTPROXY_E_BREADCRUMB_FAILED: instproxy_error_t = -50;
pub const instproxy_error_t_INSTPROXY_E_BREADCRUMB_UNLOCK_FAILED: instproxy_error_t = -51;
pub const instproxy_error_t_INSTPROXY_E_GEOJSON_CAPTURE_FAILED: instproxy_error_t = -52;
pub const instproxy_error_t_INSTPROXY_E_NEWSSTAND_ARTWORK_CAPTURE_FAILED: instproxy_error_t = -53;
pub const instproxy_error_t_INSTPROXY_E_MISSING_COMMAND: instproxy_error_t = -54;
pub const instproxy_error_t_INSTPROXY_E_NOT_ENTITLED: instproxy_error_t = -55;
pub const instproxy_error_t_INSTPROXY_E_MISSING_PACKAGE_PATH: instproxy_error_t = -56;
pub const instproxy_error_t_INSTPROXY_E_MISSING_CONTAINER_PATH: instproxy_error_t = -57;
pub const instproxy_error_t_INSTPROXY_E_MISSING_APPLICATION_IDENTIFIER: instproxy_error_t = -58;
pub const instproxy_error_t_INSTPROXY_E_MISSING_ATTRIBUTE_VALUE: instproxy_error_t = -59;
pub const instproxy_error_t_INSTPROXY_E_LOOKUP_FAILED: instproxy_error_t = -60;
pub const instproxy_error_t_INSTPROXY_E_DICT_CREATION_FAILED: instproxy_error_t = -61;
pub const instproxy_error_t_INSTPROXY_E_INSTALL_PROHIBITED: instproxy_error_t = -62;
pub const instproxy_error_t_INSTPROXY_E_UNINSTALL_PROHIBITED: instproxy_error_t = -63;
pub const instproxy_error_t_INSTPROXY_E_MISSING_BUNDLE_VERSION: instproxy_error_t = -64;
pub const instproxy_error_t_INSTPROXY_E_UNKNOWN_ERROR: instproxy_error_t = -256;
#[doc = " Error Codes"]
pub type instproxy_error_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct instproxy_client_private {
    _unused: [u8; 0],
}
pub type instproxy_client_t = *mut instproxy_client_private;
#[doc = " Reports the status response of the given command"]
pub type instproxy_status_cb_t = ::std::option::Option<
    unsafe extern "C" fn(command: plist_t, status: plist_t, user_data: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " Connects to the installation_proxy service on the specified device."]
    #[doc = ""]
    #[doc = " @param device The device to connect to"]
    #[doc = " @param service The service descriptor returned by lockdownd_start_service."]
    #[doc = " @param client Pointer that will be set to a newly allocated"]
    #[doc = "        instproxy_client_t upon successful return."]
    #[doc = ""]
    #[doc = " @return INSTPROXY_E_SUCCESS on success, or an INSTPROXY_E_* error value"]
    #[doc = "         when an error occurred."]
    pub fn instproxy_client_new(
        device: idevice_t,
        service: lockdownd_service_descriptor_t,
        client: *mut instproxy_client_t,
    ) -> instproxy_error_t;
}
extern "C" {
    #[doc = " Starts a new installation_proxy service on the specified device and connects to it."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param client Pointer that will point to a newly allocated"]
    #[doc = "        instproxy_client_t upon successful return. Must be freed using"]
    #[doc = "        instproxy_client_free() after use."]
    #[doc = " @param label The label to use for communication. Usually the program name."]
    #[doc = "        Pass NULL to disable sending the label in requests to lockdownd."]
    #[doc = ""]
    #[doc = " @return INSTPROXY_E_SUCCESS on success, or an INSTPROXY_E_* error"]
    #[doc = "         code otherwise."]
    pub fn instproxy_client_start_service(
        device: idevice_t,
        client: *mut instproxy_client_t,
        label: *const ::std::os::raw::c_char,
    ) -> instproxy_error_t;
}
extern "C" {
    #[doc = " Disconnects an installation_proxy client from the device and frees up the"]
    #[doc = " installation_proxy client data."]
    #[doc = ""]
    #[doc = " @param client The installation_proxy client to disconnect and free."]
    #[doc = ""]
    #[doc = " @return INSTPROXY_E_SUCCESS on success"]
    #[doc = "         or INSTPROXY_E_INVALID_ARG if client is NULL."]
    pub fn instproxy_client_free(client: instproxy_client_t) -> instproxy_error_t;
}
extern "C" {
    #[doc = " List installed applications. This function runs synchronously."]
    #[doc = ""]
    #[doc = " @param client The connected installation_proxy client"]
    #[doc = " @param client_options The client options to use, as PLIST_DICT, or NULL."]
    #[doc = "        Valid client options include:"]
    #[doc = "          \"ApplicationType\" -> \"System\""]
    #[doc = "          \"ApplicationType\" -> \"User\""]
    #[doc = "          \"ApplicationType\" -> \"Internal\""]
    #[doc = "          \"ApplicationType\" -> \"Any\""]
    #[doc = " @param result Pointer that will be set to a plist that will hold an array"]
    #[doc = "        of PLIST_DICT holding information about the applications found."]
    #[doc = ""]
    #[doc = " @return INSTPROXY_E_SUCCESS on success or an INSTPROXY_E_* error value if"]
    #[doc = "         an error occurred."]
    pub fn instproxy_browse(
        client: instproxy_client_t,
        client_options: plist_t,
        result: *mut plist_t,
    ) -> instproxy_error_t;
}
extern "C" {
    #[doc = " List pages of installed applications in a callback."]
    #[doc = ""]
    #[doc = " @param client The connected installation_proxy client"]
    #[doc = " @param client_options The client options to use, as PLIST_DICT, or NULL."]
    #[doc = "        Valid client options include:"]
    #[doc = "          \"ApplicationType\" -> \"System\""]
    #[doc = "          \"ApplicationType\" -> \"User\""]
    #[doc = "          \"ApplicationType\" -> \"Internal\""]
    #[doc = "          \"ApplicationType\" -> \"Any\""]
    #[doc = " @param status_cb Callback function to process each page of application"]
    #[doc = "        information. Passing a callback is required."]
    #[doc = " @param user_data Callback data passed to status_cb."]
    #[doc = ""]
    #[doc = " @return INSTPROXY_E_SUCCESS on success or an INSTPROXY_E_* error value if"]
    #[doc = "         an error occurred."]
    pub fn instproxy_browse_with_callback(
        client: instproxy_client_t,
        client_options: plist_t,
        status_cb: instproxy_status_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> instproxy_error_t;
}
extern "C" {
    #[doc = " Lookup information about specific applications from the device."]
    #[doc = ""]
    #[doc = " @param client The connected installation_proxy client"]
    #[doc = " @param appids An array of bundle identifiers that MUST have a terminating"]
    #[doc = "        NULL entry or NULL to lookup all."]
    #[doc = " @param client_options The client options to use, as PLIST_DICT, or NULL."]
    #[doc = "        Currently there are no known client options, so pass NULL here."]
    #[doc = " @param result Pointer that will be set to a plist containing a PLIST_DICT"]
    #[doc = "        holding requested information about the application or NULL on errors."]
    #[doc = ""]
    #[doc = " @return INSTPROXY_E_SUCCESS on success or an INSTPROXY_E_* error value if"]
    #[doc = "         an error occurred."]
    pub fn instproxy_lookup(
        client: instproxy_client_t,
        appids: *mut *const ::std::os::raw::c_char,
        client_options: plist_t,
        result: *mut plist_t,
    ) -> instproxy_error_t;
}
extern "C" {
    #[doc = " Install an application on the device."]
    #[doc = ""]
    #[doc = " @param client The connected installation_proxy client"]
    #[doc = " @param pkg_path Path of the installation package (inside the AFC jail)"]
    #[doc = " @param client_options The client options to use, as PLIST_DICT, or NULL."]
    #[doc = "        Valid options include:"]
    #[doc = "          \"iTunesMetadata\" -> PLIST_DATA"]
    #[doc = "          \"ApplicationSINF\" -> PLIST_DATA"]
    #[doc = "          \"PackageType\" -> \"Developer\""]
    #[doc = "        If PackageType -> Developer is specified, then pkg_path points to"]
    #[doc = "        an .app directory instead of an install package."]
    #[doc = " @param status_cb Callback function for progress and status information. If"]
    #[doc = "        NULL is passed, this function will run synchronously."]
    #[doc = " @param user_data Callback data passed to status_cb."]
    #[doc = ""]
    #[doc = " @return INSTPROXY_E_SUCCESS on success or an INSTPROXY_E_* error value if"]
    #[doc = "         an error occurred."]
    #[doc = ""]
    #[doc = " @note If a callback function is given (async mode), this function returns"]
    #[doc = "       INSTPROXY_E_SUCCESS immediately if the status updater thread has been"]
    #[doc = "       created successfully; any error occurring during the command has to be"]
    #[doc = "       handled inside the specified callback function."]
    pub fn instproxy_install(
        client: instproxy_client_t,
        pkg_path: *const ::std::os::raw::c_char,
        client_options: plist_t,
        status_cb: instproxy_status_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> instproxy_error_t;
}
extern "C" {
    #[doc = " Upgrade an application on the device. This function is nearly the same as"]
    #[doc = " instproxy_install; the difference is that the installation progress on the"]
    #[doc = " device is faster if the application is already installed."]
    #[doc = ""]
    #[doc = " @param client The connected installation_proxy client"]
    #[doc = " @param pkg_path Path of the installation package (inside the AFC jail)"]
    #[doc = " @param client_options The client options to use, as PLIST_DICT, or NULL."]
    #[doc = "        Valid options include:"]
    #[doc = "          \"iTunesMetadata\" -> PLIST_DATA"]
    #[doc = "          \"ApplicationSINF\" -> PLIST_DATA"]
    #[doc = "          \"PackageType\" -> \"Developer\""]
    #[doc = "        If PackageType -> Developer is specified, then pkg_path points to"]
    #[doc = "        an .app directory instead of an install package."]
    #[doc = " @param status_cb Callback function for progress and status information. If"]
    #[doc = "        NULL is passed, this function will run synchronously."]
    #[doc = " @param user_data Callback data passed to status_cb."]
    #[doc = ""]
    #[doc = " @return INSTPROXY_E_SUCCESS on success or an INSTPROXY_E_* error value if"]
    #[doc = "         an error occurred."]
    #[doc = ""]
    #[doc = " @note If a callback function is given (async mode), this function returns"]
    #[doc = "       INSTPROXY_E_SUCCESS immediately if the status updater thread has been"]
    #[doc = "       created successfully; any error occurring during the command has to be"]
    #[doc = "       handled inside the specified callback function."]
    pub fn instproxy_upgrade(
        client: instproxy_client_t,
        pkg_path: *const ::std::os::raw::c_char,
        client_options: plist_t,
        status_cb: instproxy_status_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> instproxy_error_t;
}
extern "C" {
    #[doc = " Uninstall an application from the device."]
    #[doc = ""]
    #[doc = " @param client The connected installation proxy client"]
    #[doc = " @param appid ApplicationIdentifier of the app to uninstall"]
    #[doc = " @param client_options The client options to use, as PLIST_DICT, or NULL."]
    #[doc = "        Currently there are no known client options, so pass NULL here."]
    #[doc = " @param status_cb Callback function for progress and status information. If"]
    #[doc = "        NULL is passed, this function will run synchronously."]
    #[doc = " @param user_data Callback data passed to status_cb."]
    #[doc = ""]
    #[doc = " @return INSTPROXY_E_SUCCESS on success or an INSTPROXY_E_* error value if"]
    #[doc = "     an error occurred."]
    #[doc = ""]
    #[doc = " @note If a callback function is given (async mode), this function returns"]
    #[doc = "       INSTPROXY_E_SUCCESS immediately if the status updater thread has been"]
    #[doc = "       created successfully; any error occurring during the command has to be"]
    #[doc = "       handled inside the specified callback function."]
    pub fn instproxy_uninstall(
        client: instproxy_client_t,
        appid: *const ::std::os::raw::c_char,
        client_options: plist_t,
        status_cb: instproxy_status_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> instproxy_error_t;
}
extern "C" {
    #[doc = " List archived applications. This function runs synchronously."]
    #[doc = ""]
    #[doc = " @see instproxy_archive"]
    #[doc = ""]
    #[doc = " @param client The connected installation_proxy client"]
    #[doc = " @param client_options The client options to use, as PLIST_DICT, or NULL."]
    #[doc = "        Currently there are no known client options, so pass NULL here."]
    #[doc = " @param result Pointer that will be set to a plist containing a PLIST_DICT"]
    #[doc = "        holding information about the archived applications found."]
    #[doc = ""]
    #[doc = " @return INSTPROXY_E_SUCCESS on success or an INSTPROXY_E_* error value if"]
    #[doc = "         an error occurred."]
    pub fn instproxy_lookup_archives(
        client: instproxy_client_t,
        client_options: plist_t,
        result: *mut plist_t,
    ) -> instproxy_error_t;
}
extern "C" {
    #[doc = " Archive an application on the device."]
    #[doc = " This function tells the device to make an archive of the specified"]
    #[doc = " application. This results in the device creating a ZIP archive in the"]
    #[doc = " 'ApplicationArchives' directory and uninstalling the application."]
    #[doc = ""]
    #[doc = " @param client The connected installation proxy client"]
    #[doc = " @param appid ApplicationIdentifier of the app to archive."]
    #[doc = " @param client_options The client options to use, as PLIST_DICT, or NULL."]
    #[doc = "        Valid options include:"]
    #[doc = "          \"SkipUninstall\" -> Boolean"]
    #[doc = "          \"ArchiveType\" -> \"ApplicationOnly\""]
    #[doc = " @param status_cb Callback function for progress and status information. If"]
    #[doc = "        NULL is passed, this function will run synchronously."]
    #[doc = " @param user_data Callback data passed to status_cb."]
    #[doc = ""]
    #[doc = " @return INSTPROXY_E_SUCCESS on success or an INSTPROXY_E_* error value if"]
    #[doc = "     an error occurred."]
    #[doc = ""]
    #[doc = " @note If a callback function is given (async mode), this function returns"]
    #[doc = "       INSTPROXY_E_SUCCESS immediately if the status updater thread has been"]
    #[doc = "       created successfully; any error occurring during the command has to be"]
    #[doc = "       handled inside the specified callback function."]
    pub fn instproxy_archive(
        client: instproxy_client_t,
        appid: *const ::std::os::raw::c_char,
        client_options: plist_t,
        status_cb: instproxy_status_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> instproxy_error_t;
}
extern "C" {
    #[doc = " Restore a previously archived application on the device."]
    #[doc = " This function is the counterpart to instproxy_archive."]
    #[doc = " @see instproxy_archive"]
    #[doc = ""]
    #[doc = " @param client The connected installation proxy client"]
    #[doc = " @param appid ApplicationIdentifier of the app to restore."]
    #[doc = " @param client_options The client options to use, as PLIST_DICT, or NULL."]
    #[doc = "        Valid options include:"]
    #[doc = "          \"ArchiveType\" -> \"DocumentsOnly\""]
    #[doc = " @param status_cb Callback function for progress and status information. If"]
    #[doc = "        NULL is passed, this function will run synchronously."]
    #[doc = " @param user_data Callback data passed to status_cb."]
    #[doc = ""]
    #[doc = " @return INSTPROXY_E_SUCCESS on success or an INSTPROXY_E_* error value if"]
    #[doc = "     an error occurred."]
    #[doc = ""]
    #[doc = " @note If a callback function is given (async mode), this function returns"]
    #[doc = "       INSTPROXY_E_SUCCESS immediately if the status updater thread has been"]
    #[doc = "       created successfully; any error occurring during the command has to be"]
    #[doc = "       handled inside the specified callback function."]
    pub fn instproxy_restore(
        client: instproxy_client_t,
        appid: *const ::std::os::raw::c_char,
        client_options: plist_t,
        status_cb: instproxy_status_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> instproxy_error_t;
}
extern "C" {
    #[doc = " Removes a previously archived application from the device."]
    #[doc = " This function removes the ZIP archive from the 'ApplicationArchives'"]
    #[doc = " directory."]
    #[doc = ""]
    #[doc = " @param client The connected installation proxy client"]
    #[doc = " @param appid ApplicationIdentifier of the archived app to remove."]
    #[doc = " @param client_options The client options to use, as PLIST_DICT, or NULL."]
    #[doc = "        Currently there are no known client options, so passing NULL is fine."]
    #[doc = " @param status_cb Callback function for progress and status information. If"]
    #[doc = "        NULL is passed, this function will run synchronously."]
    #[doc = " @param user_data Callback data passed to status_cb."]
    #[doc = ""]
    #[doc = " @return INSTPROXY_E_SUCCESS on success or an INSTPROXY_E_* error value if"]
    #[doc = "         an error occurred."]
    #[doc = ""]
    #[doc = " @note If a callback function is given (async mode), this function returns"]
    #[doc = "       INSTPROXY_E_SUCCESS immediately if the status updater thread has been"]
    #[doc = "       created successfully; any error occurring during the command has to be"]
    #[doc = "       handled inside the specified callback function."]
    pub fn instproxy_remove_archive(
        client: instproxy_client_t,
        appid: *const ::std::os::raw::c_char,
        client_options: plist_t,
        status_cb: instproxy_status_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> instproxy_error_t;
}
extern "C" {
    #[doc = " Checks a device for certain capabilities."]
    #[doc = ""]
    #[doc = " @param client The connected installation_proxy client"]
    #[doc = " @param capabilities An array of char* with capability names that MUST have a"]
    #[doc = "        terminating\u{a0}NULL entry."]
    #[doc = " @param client_options The client options to use, as PLIST_DICT, or NULL."]
    #[doc = "        Currently there are no known client options, so pass NULL here."]
    #[doc = " @param result Pointer that will be set to a plist containing a PLIST_DICT"]
    #[doc = "        holding information if the capabilities matched or NULL on errors."]
    #[doc = ""]
    #[doc = " @return INSTPROXY_E_SUCCESS on success or an INSTPROXY_E_* error value if"]
    #[doc = "         an error occurred."]
    pub fn instproxy_check_capabilities_match(
        client: instproxy_client_t,
        capabilities: *mut *const ::std::os::raw::c_char,
        client_options: plist_t,
        result: *mut plist_t,
    ) -> instproxy_error_t;
}
extern "C" {
    #[doc = " Gets the name from a command dictionary."]
    #[doc = ""]
    #[doc = " @param command The dictionary describing the command."]
    #[doc = " @param name Pointer to store the name of the command."]
    pub fn instproxy_command_get_name(command: plist_t, name: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Gets the name of a status."]
    #[doc = ""]
    #[doc = " @param status The dictionary status response to use."]
    #[doc = " @param name Pointer to store the name of the status."]
    pub fn instproxy_status_get_name(status: plist_t, name: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Gets error name, code and description from a response if available."]
    #[doc = ""]
    #[doc = " @param status The dictionary status response to use."]
    #[doc = " @param name Pointer to store the name of an error."]
    #[doc = " @param description Pointer to store error description text if available."]
    #[doc = "        The caller is reponsible for freeing the allocated buffer after use."]
    #[doc = "        If NULL is passed no description will be returned."]
    #[doc = " @param code Pointer to store the returned error code if available."]
    #[doc = "        If NULL is passed no error code will be returned."]
    #[doc = ""]
    #[doc = " @return INSTPROXY_E_SUCCESS if no error is found or an INSTPROXY_E_* error"]
    #[doc = "   value matching the error that as found in the status."]
    pub fn instproxy_status_get_error(
        status: plist_t,
        name: *mut *mut ::std::os::raw::c_char,
        description: *mut *mut ::std::os::raw::c_char,
        code: *mut u64,
    ) -> instproxy_error_t;
}
extern "C" {
    #[doc = " Gets total and current item information from a browse response if available."]
    #[doc = ""]
    #[doc = " @param status The dictionary status response to use."]
    #[doc = " @param total Pointer to store the total number of items."]
    #[doc = " @param current_index Pointer to store the current index of all browsed items."]
    #[doc = " @param current_amount Pointer to store the amount of items in the"]
    #[doc = "        current list."]
    #[doc = " @param list Pointer to store a newly allocated plist with items."]
    #[doc = "        The caller is reponsible for freeing the list after use."]
    #[doc = "        If NULL is passed no list will be returned. If NULL is returned no"]
    #[doc = "        list was found in the status."]
    pub fn instproxy_status_get_current_list(
        status: plist_t,
        total: *mut u64,
        current_index: *mut u64,
        current_amount: *mut u64,
        list: *mut plist_t,
    );
}
extern "C" {
    #[doc = " Gets progress in percentage from a status if available."]
    #[doc = ""]
    #[doc = " @param status The dictionary status response to use."]
    #[doc = " @param name Pointer to store the progress in percent (0-100) or -1 if not"]
    #[doc = "        progress was found in the status."]
    pub fn instproxy_status_get_percent_complete(
        status: plist_t,
        percent: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Creates a new client_options plist."]
    #[doc = ""]
    #[doc = " @return A new plist_t of type PLIST_DICT."]
    pub fn instproxy_client_options_new() -> plist_t;
}
extern "C" {
    #[doc = " Adds one or more new key:value pairs to the given client_options."]
    #[doc = ""]
    #[doc = " @param client_options The client options to modify."]
    #[doc = " @param ... KEY, VALUE, [KEY, VALUE], NULL"]
    #[doc = ""]
    #[doc = " @note The keys and values passed are expected to be strings, except for the"]
    #[doc = "       keys \"ApplicationSINF\", \"iTunesMetadata\", \"ReturnAttributes\" which are"]
    #[doc = "       expecting a plist_t node as value and \"SkipUninstall\" expects int."]
    pub fn instproxy_client_options_add(client_options: plist_t, ...);
}
extern "C" {
    #[doc = " Adds attributes to the given client_options to filter browse results."]
    #[doc = ""]
    #[doc = " @param client_options The client options to modify."]
    #[doc = " @param ... VALUE, VALUE, [VALUE], NULL"]
    #[doc = ""]
    #[doc = " @note The values passed are expected to be strings."]
    pub fn instproxy_client_options_set_return_attributes(client_options: plist_t, ...);
}
extern "C" {
    #[doc = " Frees client_options plist."]
    #[doc = ""]
    #[doc = " @param client_options The client options plist to free. Does nothing if NULL"]
    #[doc = "        is passed."]
    pub fn instproxy_client_options_free(client_options: plist_t);
}
extern "C" {
    #[doc = " Queries the device for the path of an application."]
    #[doc = ""]
    #[doc = " @param client The connected installation proxy client."]
    #[doc = " @param appid ApplicationIdentifier of app to retrieve the path for."]
    #[doc = " @param path Pointer to store the device path for the application"]
    #[doc = "        which is set to NULL if it could not be determined."]
    #[doc = ""]
    #[doc = " @return INSTPROXY_E_SUCCESS on success, INSTPROXY_E_OP_FAILED if"]
    #[doc = "         the path could not be determined or an INSTPROXY_E_* error"]
    #[doc = "         value if an error occurred."]
    pub fn instproxy_client_get_path_for_bundle_identifier(
        client: instproxy_client_t,
        bundle_id: *const ::std::os::raw::c_char,
        path: *mut *mut ::std::os::raw::c_char,
    ) -> instproxy_error_t;
}
pub const debugserver_error_t_DEBUGSERVER_E_SUCCESS: debugserver_error_t = 0;
pub const debugserver_error_t_DEBUGSERVER_E_INVALID_ARG: debugserver_error_t = -1;
pub const debugserver_error_t_DEBUGSERVER_E_MUX_ERROR: debugserver_error_t = -2;
pub const debugserver_error_t_DEBUGSERVER_E_SSL_ERROR: debugserver_error_t = -3;
pub const debugserver_error_t_DEBUGSERVER_E_RESPONSE_ERROR: debugserver_error_t = -4;
pub const debugserver_error_t_DEBUGSERVER_E_TIMEOUT: debugserver_error_t = -5;
pub const debugserver_error_t_DEBUGSERVER_E_UNKNOWN_ERROR: debugserver_error_t = -256;
#[doc = " Error Codes"]
pub type debugserver_error_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct debugserver_client_private {
    _unused: [u8; 0],
}
pub type debugserver_client_t = *mut debugserver_client_private;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct debugserver_command_private {
    _unused: [u8; 0],
}
pub type debugserver_command_t = *mut debugserver_command_private;
extern "C" {
    #[doc = " Connects to the debugserver service on the specified device."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param service The service descriptor returned by lockdownd_start_service."]
    #[doc = " @param client Pointer that will point to a newly allocated"]
    #[doc = "     debugserver_client_t upon successful return. Must be freed using"]
    #[doc = "     debugserver_client_free() after use."]
    #[doc = ""]
    #[doc = " @return DEBUGSERVER_E_SUCCESS on success, DEBUGSERVER_E_INVALID_ARG when"]
    #[doc = "     client is NULL, or an DEBUGSERVER_E_* error code otherwise."]
    pub fn debugserver_client_new(
        device: idevice_t,
        service: lockdownd_service_descriptor_t,
        client: *mut debugserver_client_t,
    ) -> debugserver_error_t;
}
extern "C" {
    #[doc = " Starts a new debugserver service on the specified device and connects to it."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param client Pointer that will point to a newly allocated"]
    #[doc = "     debugserver_client_t upon successful return. Must be freed using"]
    #[doc = "     debugserver_client_free() after use."]
    #[doc = " @param label The label to use for communication. Usually the program name."]
    #[doc = "  Pass NULL to disable sending the label in requests to lockdownd."]
    #[doc = ""]
    #[doc = " @return DEBUGSERVER_E_SUCCESS on success, or an DEBUGSERVER_E_* error"]
    #[doc = "     code otherwise."]
    pub fn debugserver_client_start_service(
        device: idevice_t,
        client: *mut debugserver_client_t,
        label: *const ::std::os::raw::c_char,
    ) -> debugserver_error_t;
}
extern "C" {
    #[doc = " Disconnects a debugserver client from the device and frees up the"]
    #[doc = " debugserver client data."]
    #[doc = ""]
    #[doc = " @param client The debugserver client to disconnect and free."]
    #[doc = ""]
    #[doc = " @return DEBUGSERVER_E_SUCCESS on success, DEBUGSERVER_E_INVALID_ARG when"]
    #[doc = "     client is NULL, or an DEBUGSERVER_E_* error code otherwise."]
    pub fn debugserver_client_free(client: debugserver_client_t) -> debugserver_error_t;
}
extern "C" {
    #[doc = " Sends raw data using the given debugserver service client."]
    #[doc = ""]
    #[doc = " @param client The debugserver client to use for sending"]
    #[doc = " @param data Data to send"]
    #[doc = " @param size Size of the data to send"]
    #[doc = " @param sent Number of bytes sent (can be NULL to ignore)"]
    #[doc = ""]
    #[doc = " @return DEBUGSERVER_E_SUCCESS on success,"]
    #[doc = "      DEBUGSERVER_E_INVALID_ARG when one or more parameters are"]
    #[doc = "      invalid, or DEBUGSERVER_E_UNKNOWN_ERROR when an unspecified"]
    #[doc = "      error occurs."]
    pub fn debugserver_client_send(
        client: debugserver_client_t,
        data: *const ::std::os::raw::c_char,
        size: u32,
        sent: *mut u32,
    ) -> debugserver_error_t;
}
extern "C" {
    #[doc = " Receives raw data using the given debugserver client with specified timeout."]
    #[doc = ""]
    #[doc = " @param client The debugserver client to use for receiving"]
    #[doc = " @param data Buffer that will be filled with the data received"]
    #[doc = " @param size Number of bytes to receive"]
    #[doc = " @param received Number of bytes received (can be NULL to ignore)"]
    #[doc = " @param timeout Maximum time in milliseconds to wait for data."]
    #[doc = ""]
    #[doc = " @return DEBUGSERVER_E_SUCCESS on success,"]
    #[doc = "      DEBUGSERVER_E_INVALID_ARG when one or more parameters are"]
    #[doc = "      invalid, DEBUGSERVER_E_MUX_ERROR when a communication error"]
    #[doc = "      occurs, or DEBUGSERVER_E_UNKNOWN_ERROR when an unspecified"]
    #[doc = "      error occurs."]
    pub fn debugserver_client_receive_with_timeout(
        client: debugserver_client_t,
        data: *mut ::std::os::raw::c_char,
        size: u32,
        received: *mut u32,
        timeout: ::std::os::raw::c_uint,
    ) -> debugserver_error_t;
}
extern "C" {
    #[doc = " Receives raw data from the debugserver service."]
    #[doc = ""]
    #[doc = " @param client The debugserver client"]
    #[doc = " @param data Buffer that will be filled with the data received"]
    #[doc = " @param size Number of bytes to receive"]
    #[doc = " @param received Number of bytes received (can be NULL to ignore)"]
    #[doc = " @note The default read timeout is 10 seconds."]
    #[doc = ""]
    #[doc = " @return DEBUGSERVER_E_SUCCESS on success,"]
    #[doc = "  DEBUGSERVER_E_INVALID_ARG when client or plist is NULL"]
    pub fn debugserver_client_receive(
        client: debugserver_client_t,
        data: *mut ::std::os::raw::c_char,
        size: u32,
        received: *mut u32,
    ) -> debugserver_error_t;
}
extern "C" {
    #[doc = " Sends a command to the debugserver service."]
    #[doc = ""]
    #[doc = " @param client The debugserver client"]
    #[doc = " @param command Command to process and send"]
    #[doc = " @param response Response received for the command (can be NULL to ignore)"]
    #[doc = " @param response_size Pointer to receive response size. Set to NULL to ignore."]
    #[doc = ""]
    #[doc = " @return DEBUGSERVER_E_SUCCESS on success,"]
    #[doc = "  DEBUGSERVER_E_INVALID_ARG when client or command is NULL"]
    pub fn debugserver_client_send_command(
        client: debugserver_client_t,
        command: debugserver_command_t,
        response: *mut *mut ::std::os::raw::c_char,
        response_size: *mut size_t,
    ) -> debugserver_error_t;
}
extern "C" {
    #[doc = " Receives and parses response of debugserver service."]
    #[doc = ""]
    #[doc = " @param client The debugserver client"]
    #[doc = " @param response Response received for last command (can be NULL to ignore)"]
    #[doc = " @param response_size Pointer to receive response size. Set to NULL to ignore."]
    #[doc = ""]
    #[doc = " @return DEBUGSERVER_E_SUCCESS on success,"]
    #[doc = "  DEBUGSERVER_E_INVALID_ARG when client is NULL"]
    pub fn debugserver_client_receive_response(
        client: debugserver_client_t,
        response: *mut *mut ::std::os::raw::c_char,
        response_size: *mut size_t,
    ) -> debugserver_error_t;
}
extern "C" {
    #[doc = " Controls status of ACK mode when sending commands or receiving responses."]
    #[doc = ""]
    #[doc = " @see debugserver_client_send_command, debugserver_client_receive_response"]
    #[doc = ""]
    #[doc = " @param client The debugserver client"]
    #[doc = " @param enabled A boolean flag indicating whether the internal ACK mode"]
    #[doc = "   handling should be enabled or disabled."]
    #[doc = ""]
    #[doc = " @return DEBUGSERVER_E_SUCCESS on success, or an DEBUGSERVER_E_* error"]
    #[doc = "     code otherwise."]
    pub fn debugserver_client_set_ack_mode(
        client: debugserver_client_t,
        enabled: ::std::os::raw::c_int,
    ) -> debugserver_error_t;
}
extern "C" {
    #[doc = " Sets the argv which launches an app."]
    #[doc = ""]
    #[doc = " @param client The debugserver client"]
    #[doc = " @param argc Number of arguments"]
    #[doc = " @param argv Array starting with the executable to be run followed by it's arguments"]
    #[doc = " @param response Response received for the command (can be NULL to ignore)"]
    #[doc = ""]
    #[doc = " @return DEBUGSERVER_E_SUCCESS on success,"]
    #[doc = "  DEBUGSERVER_E_INVALID_ARG when client is NULL"]
    pub fn debugserver_client_set_argv(
        client: debugserver_client_t,
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
        response: *mut *mut ::std::os::raw::c_char,
    ) -> debugserver_error_t;
}
extern "C" {
    #[doc = " Adds or sets an environment variable."]
    #[doc = ""]
    #[doc = " @param client The debugserver client"]
    #[doc = " @param env The environment variable in \"KEY=VALUE\" notation"]
    #[doc = " @param response Response received for the command (can be NULL to ignore)"]
    #[doc = ""]
    #[doc = " @return DEBUGSERVER_E_SUCCESS on success,"]
    #[doc = "  DEBUGSERVER_E_INVALID_ARG when client is NULL"]
    pub fn debugserver_client_set_environment_hex_encoded(
        client: debugserver_client_t,
        env: *const ::std::os::raw::c_char,
        response: *mut *mut ::std::os::raw::c_char,
    ) -> debugserver_error_t;
}
extern "C" {
    #[doc = " Creates and initializes a new command object."]
    #[doc = ""]
    #[doc = " @param name The name of the command which is sent in plain text"]
    #[doc = " @param argv Array of tokens for the command ment to be encoded"]
    #[doc = " @param argc Number of items in the token array"]
    #[doc = " @param command New command object"]
    #[doc = ""]
    #[doc = " @return DEBUGSERVER_E_SUCCESS on success,"]
    #[doc = "  DEBUGSERVER_E_INVALID_ARG when name or command is NULL"]
    pub fn debugserver_command_new(
        name: *const ::std::os::raw::c_char,
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
        command: *mut debugserver_command_t,
    ) -> debugserver_error_t;
}
extern "C" {
    #[doc = " Frees memory of command object."]
    #[doc = ""]
    #[doc = " @param command The command object"]
    #[doc = ""]
    #[doc = " @return DEBUGSERVER_E_SUCCESS on success,"]
    #[doc = "  DEBUGSERVER_E_INVALID_ARG when command is NULL"]
    pub fn debugserver_command_free(command: debugserver_command_t) -> debugserver_error_t;
}
extern "C" {
    #[doc = " Encodes a string into hex notation."]
    #[doc = ""]
    #[doc = " @param buffer String to encode into hex notiation"]
    #[doc = " @param encoded_buffer The buffer receives a hex encoded string"]
    #[doc = " @param encoded_length Length of the hex encoded string"]
    pub fn debugserver_encode_string(
        buffer: *const ::std::os::raw::c_char,
        encoded_buffer: *mut *mut ::std::os::raw::c_char,
        encoded_length: *mut u32,
    );
}
extern "C" {
    #[doc = " Decodes a hex encoded string."]
    #[doc = ""]
    #[doc = " @param encoded_buffer The buffer with a hex encoded string"]
    #[doc = " @param encoded_length Length of the encoded buffer"]
    #[doc = " @param buffer Decoded string to be freed by the caller"]
    pub fn debugserver_decode_string(
        encoded_buffer: *const ::std::os::raw::c_char,
        encoded_length: size_t,
        buffer: *mut *mut ::std::os::raw::c_char,
    );
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
